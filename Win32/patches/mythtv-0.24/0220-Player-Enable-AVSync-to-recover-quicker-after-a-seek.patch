From e702d2206570c73e20420fc4b362a00b568d0e8d Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Fri, 14 Jun 2013 19:53:14 +0100
Subject: [PATCH 220/285] Player: Enable AVSync to recover quicker after a
 seek or program change

The a/v timecodes can get out of step by 10's of seconds after a seek
or a livetv program change.  This can cause frames to be doubled or dropped
until the a/v streams get back in step.

This patch checks the a/v timecode difference and if larger than 1 second
disables frame dropping or doubling.

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythtv/libs/libmythtv/mythplayer.cpp |   81 +++++++++++++++++++++++++++++-----
 mythtv/libs/libmythtv/mythplayer.h   |    4 +-
 2 files changed, 74 insertions(+), 11 deletions(-)

diff --git a/mythtv/libs/libmythtv/mythplayer.cpp b/mythtv/libs/libmythtv/mythplayer.cpp
index 9475f77..7da2848 100644
--- a/mythtv/libs/libmythtv/mythplayer.cpp
+++ b/mythtv/libs/libmythtv/mythplayer.cpp
@@ -203,8 +203,10 @@ MythPlayer::MythPlayer(bool muted)
       refreshrate(0),
       lastsync(false),              repeat_delay(0),
       disp_timecode(0),             avsync_audiopaused(false),
+      avsync_holdoff(0),
       // Time Code stuff
-      prevtc(0),                    prevrp(0),
+      prevtc(0),                    prev_audiotime(0),
+      prevrp(0),
       savedAudioTimecodeOffset(0),
       // LiveTVChain stuff
       m_tv(NULL),                   isDummy(false),
@@ -1590,6 +1592,11 @@ void MythPlayer::InitAVSync(void)
     videosync->Start();
 
     avsync_adjustment = 0;
+    avsync_avg = 0;
+    lastsync = false;
+    avsync_holdoff = 0;
+    prev_audiotime = 0;
+    prevtc = 0;
 
     repeat_delay = 0;
 
@@ -1618,7 +1625,7 @@ void MythPlayer::InitAVSync(void)
 void MythPlayer::AVSync(VideoFrame *buffer, bool limit_delay)
 {
     int repeat_pict  = 0;
-    int64_t timecode = audio.GetAudioTime();
+    int64_t timecode = 0;
 
     if (buffer)
     {
@@ -1767,6 +1774,7 @@ void MythPlayer::AVSync(VideoFrame *buffer, bool limit_delay)
                         "\t\t\tdoubling video frame interval to slow down.").arg(diverge));
     }
 
+    bool bOK = false;
     if (audio.HasAudioOut() && normal_speed)
     {
         int64_t currentaudiotime = audio.GetAudioTime();
@@ -1780,12 +1788,51 @@ void MythPlayer::AVSync(VideoFrame *buffer, bool limit_delay)
                 .arg(avsync_avg)
                 .arg(tc_wrap[TC_AUDIO])
                  );
-        if (currentaudiotime != 0 && timecode != 0)
-        { // currentaudiotime == 0 after a seek
+
+        // Max acceptable difference in timecodes
+        int maxdiff = (10 * frame_interval) / 1000;
+
+        if (avsync_holdoff > 0)
+            --avsync_holdoff;
+        // currentaudiotime == 0 after a seek
+        else if (timecode == 0 || currentaudiotime == 0 || prevtc == 0)
+            avsync_holdoff = 1;
+        else if (abs(timecode - prevtc) > maxdiff)
+        {
+            VERBOSE(VB_PLAYBACK, QString(
+                    "Discontinuous video timecodes %1 -> %2")
+                .arg(prevtc)
+                .arg(timecode)
+            );
+            avsync_holdoff = 5;
+        }
+        else if (abs(currentaudiotime - prev_audiotime) > maxdiff)
+        {
+            VERBOSE(VB_PLAYBACK, QString(
+                    "Discontinuous audio timecodes %1 -> %2")
+                .arg(prev_audiotime)
+                .arg(currentaudiotime)
+            );
+            // This is most common after SwitchToProgram
+            int frames = (currentaudiotime - prev_audiotime) / ((frame_interval + 999) / 1000);
+            avsync_holdoff = min(max(frames, 10), 50);
+        }
+        else if (abs(timecode - currentaudiotime) > 4000)
+        {
+            VERBOSE(VB_PLAYBACK, QString(
+                    "Excessive A/V timecode difference: audio %1 video %2")
+                .arg(currentaudiotime)
+                .arg(timecode)
+            );
+            avsync_holdoff = 10;
+        }
+        else
+        {
+            bOK = true;
+
             // The time at the start of this frame (ie, now) is given by
             // last->timecode
             int delta = (int)((timecode - prevtc)/play_speed) - (frame_interval / 1000);
-            prevtc = timecode;
             //cerr << delta << " ";
 
             // If the timecode is off by a frame (dropped frame) wait to sync
@@ -1822,11 +1869,18 @@ void MythPlayer::AVSync(VideoFrame *buffer, bool limit_delay)
             else
                 lastsync = false;
         }
-        else
-        {
-            avsync_avg = 0;
-        }
+
+        prev_audiotime = currentaudiotime;
     }
+
+    if (!bOK)
+    {
+        avsync_avg = 0;
+        avsync_adjustment = 0;
+        lastsync = false;
+    }
+
+    prevtc = timecode;
 }
 
 void MythPlayer::RefreshPauseFrame(void)
@@ -2305,6 +2359,9 @@ void MythPlayer::SwitchToProgram(void)
         }
     }
 
+    // Holdoff a/v sync while decoder and ringbuffer settle down
+    avsync_holdoff = 25;
+
     VERBOSE(VB_PLAYBACK, LOC + "SwitchToProgram - end");
 }
 
@@ -2414,12 +2471,16 @@ void MythPlayer::JumpToProgram(void)
 
     // Delay starting a/v playback until enough video buffers
     // This avoids stutters during initial few secs on remote frontends
-    while (!noVideoTracks && !PrebufferEnoughFrames() && !IsErrored())
+    audio.Pause(true);
+    while (!noVideoTracks && !PrebufferEnoughFrames(false) && !IsErrored())
         usleep(10000);
 
     Play();
     ChangeSpeed();
 
+    // Holdoff a/v sync while decoder and ringbuffer settle down
+    avsync_holdoff = 25;
+
     VERBOSE(VB_PLAYBACK, LOC + "JumpToProgram - end");
 }
 
diff --git a/mythtv/libs/libmythtv/mythplayer.h b/mythtv/libs/libmythtv/mythplayer.h
index 8edb838..2a783e5 100644
--- a/mythtv/libs/libmythtv/mythplayer.h
+++ b/mythtv/libs/libmythtv/mythplayer.h
@@ -714,9 +714,11 @@ class MPUBLIC MythPlayer
     int        repeat_delay;
     int64_t    disp_timecode;
     bool       avsync_audiopaused;
+    int        avsync_holdoff;
 
     // Time Code stuff
-    int        prevtc;        ///< 32 bit timecode if last VideoFrame shown
+    int64_t    prevtc;        ///< timecode if last VideoFrame shown
+    int64_t    prev_audiotime; // audio timecode at last a/v sync
     int        prevrp;        ///< repeat_pict of last frame
     int64_t    tc_wrap[TCTYPESMAX];
     int64_t    tc_lastval[TCTYPESMAX];
-- 
1.7.9.5

