From 75ef9262eb1b51132b7aafb89e5e9508ca403ba5 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Tue, 19 Jul 2011 14:52:25 +0200
Subject: [PATCH 059/285] freemheg: Add InteractionChannel streaming from
 network URI's

This patch adds BBC iPlayer functionality to the MHEG library.

NB This patch must be applied in conjunction with that to MythPlayer
which supports Interactive TV program streams.

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythtv/libs/libmythfreemheg/Actions.cpp     |   13 +-
 mythtv/libs/libmythfreemheg/BaseClasses.cpp |    2 +
 mythtv/libs/libmythfreemheg/BaseClasses.h   |    2 +-
 mythtv/libs/libmythfreemheg/Engine.cpp      |  217 ++++++++++----
 mythtv/libs/libmythfreemheg/Engine.h        |    1 +
 mythtv/libs/libmythfreemheg/Presentable.h   |    1 -
 mythtv/libs/libmythfreemheg/Programs.cpp    |  113 +++++++-
 mythtv/libs/libmythfreemheg/Root.cpp        |    2 +-
 mythtv/libs/libmythfreemheg/Root.h          |    4 +
 mythtv/libs/libmythfreemheg/Stream.cpp      |  122 ++++----
 mythtv/libs/libmythfreemheg/Stream.h        |   66 ++++-
 mythtv/libs/libmythfreemheg/freemheg.h      |   34 ++-
 mythtv/libs/libmythtv/libmythtv.pro         |    4 +-
 mythtv/libs/libmythtv/mhegic.cpp            |  183 ++++++++++++
 mythtv/libs/libmythtv/mhegic.h              |   50 ++++
 mythtv/libs/libmythtv/mhi.cpp               |  409 ++++++++++++++++++--------
 mythtv/libs/libmythtv/mhi.h                 |   34 ++-
 mythtv/libs/libmythtv/netstream.cpp         |  412 +++++++++++++++++++--------
 mythtv/libs/libmythtv/netstream.h           |   40 ++-
 19 files changed, 1310 insertions(+), 399 deletions(-)
 create mode 100644 mythtv/libs/libmythtv/mhegic.cpp
 create mode 100644 mythtv/libs/libmythtv/mhegic.h

diff --git a/mythtv/libs/libmythfreemheg/Actions.cpp b/mythtv/libs/libmythfreemheg/Actions.cpp
index 50c46f6..c9ac254 100644
--- a/mythtv/libs/libmythfreemheg/Actions.cpp
+++ b/mythtv/libs/libmythfreemheg/Actions.cpp
@@ -44,7 +44,8 @@
 class MHUnimplementedAction: public MHElemAction
 {
 public:
-    MHUnimplementedAction(int nTag): MHElemAction("") { m_nTag = nTag; }
+    MHUnimplementedAction(int nTag): MHElemAction(""), m_nTag(nTag)
+    { MHLOG(MHLogWarning, QString("WARN Unimplemented action %1").arg(m_nTag) ); }
     virtual void Initialise(MHParseNode *, MHEngine *) {}
     virtual void PrintMe(FILE *fd, int /*nTabs*/) const { fprintf(fd, "****Missing action %d\n", m_nTag); }
     virtual void Perform(MHEngine *) { MHERROR(QString("Unimplemented action %1").arg(m_nTag)); }
@@ -136,7 +137,7 @@ void MHActionSequence::Initialise(MHParseNode *p, MHEngine *engine)
         case C_SET_BOX_SIZE: pAction = new MHSetBoxSize; break;
         case C_SET_CACHE_PRIORITY: pAction = new MHUnimplementedAction(pElemAction->GetTagNo()); break; // ?
         case C_SET_COUNTER_END_POSITION: pAction = new MHUnimplementedAction(pElemAction->GetTagNo()); break; // Stream
-        case C_SET_COUNTER_POSITION: pAction = new MHUnimplementedAction(pElemAction->GetTagNo()); break; // Stream
+        case C_SET_COUNTER_POSITION: pAction = new MHSetCounterPosition; break;
         case C_SET_COUNTER_TRIGGER: pAction = new MHUnimplementedAction(pElemAction->GetTagNo()); break; // Stream
         case C_SET_CURSOR_POSITION: pAction = new MHUnimplementedAction(pElemAction->GetTagNo()); break; // ?
         case C_SET_CURSOR_SHAPE: pAction = new MHUnimplementedAction(pElemAction->GetTagNo()); break; // ?
@@ -156,7 +157,7 @@ void MHActionSequence::Initialise(MHParseNode *p, MHEngine *engine)
         case C_SET_PORTION: pAction = new MHSetPortion; break;
         case C_SET_POSITION: pAction = new MHSetPosition; break;
         case C_SET_SLIDER_VALUE: pAction = new MHSetSliderValue; break;
-        case C_SET_SPEED: pAction = new MHUnimplementedAction(pElemAction->GetTagNo()); break; // ?
+        case C_SET_SPEED: pAction = new MHSetSpeed; break;
         case C_SET_TIMER: pAction = new MHSetTimer; break;
         case C_SET_TRANSPARENCY: pAction = new MHSetTransparency; break;
         case C_SET_VARIABLE: pAction = new MHSetVariable; break;
@@ -185,12 +186,16 @@ void MHActionSequence::Initialise(MHParseNode *p, MHEngine *engine)
         case C_SET_BITMAP_DECODE_OFFSET: pAction = new MHSetBitmapDecodeOffset; break;
         case C_GET_BITMAP_DECODE_OFFSET: pAction = new MHGetBitmapDecodeOffset; break;
         case C_SET_SLIDER_PARAMETERS: pAction = new MHSetSliderParameters; break;
+        // Added in ETSI ES 202 184 V2.1.1 (2010-01)
+        case C_GET_COUNTER_POSITION: pAction = new MHGetCounterPosition; break; // Stream position
+        case C_GET_COUNTER_MAX_POSITION: pAction = new MHGetCounterMaxPosition; break; // Stream total size
 
         default:
-            MHLOG(MHLogWarning, QString("Unknown action %1").arg(pElemAction->GetTagNo()));
+            MHLOG(MHLogWarning, QString("WARN Unknown action %1").arg(pElemAction->GetTagNo()));
             // Future proofing: ignore any actions that we don't know about.
             // Obviously these can only arise in the binary coding.
             pAction = NULL;
+            break;
         }
         if (pAction) {
             Append(pAction); // Add to the sequence.
diff --git a/mythtv/libs/libmythfreemheg/BaseClasses.cpp b/mythtv/libs/libmythfreemheg/BaseClasses.cpp
index ddcb43b..29a58ed 100644
--- a/mythtv/libs/libmythfreemheg/BaseClasses.cpp
+++ b/mythtv/libs/libmythfreemheg/BaseClasses.cpp
@@ -383,6 +383,8 @@ void MHGenericObjectRef::GetValue(MHObjectRef &ref, MHEngine *engine) const
 {
     if (m_fIsDirect) ref.Copy(m_ObjRef);
     else {
+        // LVR - Hmm I don't think this is right. Should be: ref.Copy(m_Indirect);
+        // But it's used in several places so workaround in Stream::MHActionGenericObjectRefFix
         MHUnion result;
         MHRoot *pBase = engine->FindObject(m_Indirect);
         pBase->GetVariableValue(result, engine);
diff --git a/mythtv/libs/libmythfreemheg/BaseClasses.h b/mythtv/libs/libmythfreemheg/BaseClasses.h
index a571744..075b659 100644
--- a/mythtv/libs/libmythfreemheg/BaseClasses.h
+++ b/mythtv/libs/libmythfreemheg/BaseClasses.h
@@ -184,8 +184,8 @@ class MHGenericBase
 {
 public:
     MHObjectRef *GetReference(); // Return the indirect reference or fail if it's direct
-protected:
     bool    m_fIsDirect;
+protected:
     MHObjectRef m_Indirect;
 };
 
diff --git a/mythtv/libs/libmythfreemheg/Engine.cpp b/mythtv/libs/libmythfreemheg/Engine.cpp
index dc3e201..288c924 100644
--- a/mythtv/libs/libmythfreemheg/Engine.cpp
+++ b/mythtv/libs/libmythfreemheg/Engine.cpp
@@ -32,6 +32,7 @@
 #include "Logging.h"
 #include "freemheg.h"
 #include "Visible.h"  // For MHInteractible
+#include "Stream.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -91,7 +92,7 @@ int MHEngine::RunAll()
              startObj.m_GroupId.Copy(MHOctetString("~//startup"));
              if (! Launch(startObj))
              {
-                 MHLOG(MHLogWarning, "MHEG engine auto-boot failed");
+                 MHLOG(MHLogNotifications, "NOTE Engine auto-boot failed");
                  return -1;
              }
         }
@@ -181,22 +182,43 @@ MHGroup *MHEngine::ParseProgram(QByteArray &text)
     return pRes;
 }
 
+// Determine protocol for a file
+enum EProtocol { kProtoUnknown, kProtoDSM, kProtoCI, kProtoHTTP, kProtoHybrid };
+static EProtocol PathProtocol(const QString& csPath)
+{
+    if (csPath.isEmpty() || csPath.startsWith("DSM:") || csPath.startsWith("~"))
+        return kProtoDSM;
+    if (csPath.startsWith("hybrid:"))
+        return kProtoHybrid;
+    if (csPath.startsWith("http:") || csPath.startsWith("https:"))
+        return kProtoHTTP;
+    if (csPath.startsWith("CI:"))
+        return kProtoCI;
+
+    int firstColon = csPath.indexOf(':'), firstSlash = csPath.indexOf('/');
+    if (firstColon > 0 && firstSlash > 0 && firstColon < firstSlash)
+        return kProtoUnknown;
+
+    return kProtoDSM;
+}
+
 // Launch and Spawn
 bool MHEngine::Launch(const MHObjectRef &target, bool fIsSpawn)
 {
-    QString csPath = GetPathName(target.m_GroupId); // Get path relative to root.
-    if (csPath.length() == 0) return false; // No file name.
     if (m_fInTransition) {
-        MHLOG(MHLogWarning, "Launch during transition - ignoring");
+        MHLOG(MHLogWarning, "WARN Launch during transition - ignoring");
         return false;
     }
-    QByteArray text;
+
+    if (target.m_GroupId.Size() == 0) return false; // No file name.
+    QString csPath = GetPathName(target.m_GroupId); // Get path relative to root.
+
     // Check that the file exists before we commit to the transition.
     // This may block if we cannot be sure whether the object is present.
-    if (! m_Context->GetCarouselData(csPath, text))
-    {
-        if (CurrentApp())
-            EventTriggered(CurrentApp(), EventEngineEvent, 2); // GroupIDRefError
+    QByteArray text;
+    if (! m_Context->GetCarouselData(csPath, text)) {
+        if (!m_fBooting)
+            EngineEvent(2); // GroupIDRefError
         return false;
     }
 
@@ -251,7 +273,7 @@ bool MHEngine::Launch(const MHObjectRef &target, bool fIsSpawn)
 void MHEngine::Quit()
 {
     if (m_fInTransition) {
-        MHLOG(MHLogWarning, "Quit during transition - ignoring");
+        MHLOG(MHLogWarning, "WARN Quit during transition - ignoring");
         return;
     }
     m_fInTransition = true; // Starting a transition
@@ -276,19 +298,20 @@ void MHEngine::Quit()
 
 void MHEngine::TransitionToScene(const MHObjectRef &target)
 {
-    int i;
     if (m_fInTransition) {
         // TransitionTo is not allowed in OnStartUp or OnCloseDown actions.
-        MHLOG(MHLogWarning, "TransitionTo during transition - ignoring");
+        MHLOG(MHLogWarning, "WARN TransitionTo during transition - ignoring");
         return;
     }
+
     if (target.m_GroupId.Size() == 0) return; // No file name.
     QString csPath = GetPathName(target.m_GroupId);
-    QByteArray text;
+
     // Check that the file exists before we commit to the transition.
-    if (! m_Context->GetCarouselData(csPath, text))
-    {
-        EventTriggered(CurrentApp(), EventEngineEvent, 2); // GroupIDRefError
+    // This may block if we cannot be sure whether the object is present.
+    QByteArray text;
+    if (! m_Context->GetCarouselData(csPath, text)) {
+        EngineEvent(2); // GroupIDRefError
         return;
     }
 
@@ -301,7 +324,7 @@ void MHEngine::TransitionToScene(const MHObjectRef &target)
     // At this point we have managed to load the scene.
     // Deactivate any non-shared ingredients in the application.
     MHApplication *pApp = CurrentApp();
-    for (i = pApp->m_Items.Size(); i > 0; i--) {
+    for (int i = pApp->m_Items.Size(); i > 0; i--) {
         MHIngredient *pItem = pApp->m_Items.GetAt(i-1);
         if (! pItem->IsShared()) pItem->Deactivation(this); // This does not remove them from the display stack.
     }
@@ -340,7 +363,7 @@ void MHEngine::TransitionToScene(const MHObjectRef &target)
     m_Interacting = 0;
 
     // Switch to the new scene.
-    CurrentApp()->m_pCurrentScene = (MHScene*) pProgram;
+    CurrentApp()->m_pCurrentScene = static_cast< MHScene* >(pProgram);
     SetInputRegister(CurrentScene()->m_nEventReg);
     m_redrawRegion = QRegion(0, 0, CurrentScene()->m_nSceneCoordX, CurrentScene()->m_nSceneCoordY); // Redraw the whole screen
 
@@ -360,17 +383,27 @@ void MHEngine::SetInputRegister(int nReg)
 // Create a canonical path name.  The rules are given in the UK MHEG document.
 QString MHEngine::GetPathName(const MHOctetString &str)
 {
-    QString csPath;
-    if (str.Size() != 0) csPath = QString::fromUtf8((const char *)str.Bytes(), str.Size());
-    if (csPath.left(4) == "DSM:") csPath = csPath.mid(4); // Remove DSM:
-    // If it has any other prefix this isn't a request for a carousel object.
-    int firstColon = csPath.indexOf(':'), firstSlash = csPath.indexOf('/');
-    if (firstColon > 0 && firstSlash > 0 && firstColon < firstSlash)
+    if (str.Size() == 0)
         return QString();
 
-    if (csPath.left(1) == "~") csPath = csPath.mid(1); // Remove ~
-    // Ignore "CI://"
-    if (csPath.left(2) != "//") { //
+    QString csPath = QString::fromUtf8((const char *)str.Bytes(), str.Size());
+    switch (PathProtocol(csPath))
+    {
+    default:
+    case kProtoUnknown:
+    case kProtoHybrid:
+    case kProtoHTTP:
+    case kProtoCI:
+        return csPath;
+    case kProtoDSM:
+        break;
+    }
+
+    if (csPath.startsWith("DSM:"))
+        csPath = csPath.mid(4); // Remove DSM:
+    else if (csPath.startsWith("~"))
+        csPath = csPath.mid(1); // Remove ~
+    if (!csPath.startsWith("//")) {
         // Add the current application's path name
         if (CurrentApp()) csPath = CurrentApp()->m_Path + csPath;
     }
@@ -401,7 +434,7 @@ MHRoot *MHEngine::FindObject(const MHObjectRef &oRef, bool failOnNotFound)
         // an object that may or may not exist at a particular time.
         // Another case was a call to CallActionSlot with an object reference variable
         // that had been initialised to zero.
-        MHLOG(MHLogWarning, QString("Reference %1 not found").arg(oRef.m_nObjectNo));
+        MHLOG(MHLogWarning, QString("WARN Reference %1 not found").arg(oRef.m_nObjectNo));
         throw "FindObject failed";
     }
     return NULL; // If we don't generate an error.
@@ -416,7 +449,7 @@ void MHEngine::RunActions()
         // Run it.  If it fails and throws an exception catch it and continue with the next.
         try {
             if ((__mhlogoptions & MHLogActions) && __mhlogStream != 0) { // Debugging
-                fprintf(__mhlogStream, "Action - "); pAction->PrintMe(__mhlogStream, 0); fflush(__mhlogStream);
+                fprintf(__mhlogStream, "[freemheg] Action - "); pAction->PrintMe(__mhlogStream, 0); fflush(__mhlogStream);
             }
             pAction->Perform(this);
         }
@@ -472,6 +505,7 @@ void MHEngine::EventTriggered(MHRoot *pSource, enum EventType ev, const MHUnion
     case EventUserInput:
     case EventFocusMoved: // UK MHEG.  Generated by HyperText class
     case EventSliderValueChanged: // UK MHEG.  Generated by Slider class
+    default:
         {
             // Asynchronous events.  Add to the event queue.
             MHAsynchEvent *pEvent = new MHAsynchEvent;
@@ -480,6 +514,7 @@ void MHEngine::EventTriggered(MHRoot *pSource, enum EventType ev, const MHUnion
             pEvent->eventData = evData;
             m_EventQueue.enqueue(pEvent);
         }
+        break;
     }
 }
 
@@ -649,6 +684,7 @@ void MHEngine::GenerateUserAction(int nCode)
     case 101: // Green
     case 102: // Yellow
     case 103: // Blue
+    case 300: // EPG
         EventTriggered(pScene, EventEngineEvent, nCode);
         break;
     }
@@ -662,7 +698,15 @@ void MHEngine::GenerateUserAction(int nCode)
 
 void MHEngine::EngineEvent(int nCode)
 {
-    EventTriggered(CurrentApp(), EventEngineEvent, nCode);
+    if (CurrentApp())
+        EventTriggered(CurrentApp(), EventEngineEvent, nCode);
+    else if (!m_fBooting)
+        MHLOG(MHLogWarning, QString("WARN EngineEvent %1 but no app").arg(nCode));
+}
+
+void MHEngine::StreamStarted(MHStream *stream, bool bStarted)
+{
+    EventTriggered(stream, bStarted ? EventStreamPlaying : EventStreamStopped);
 }
 
 // Called by an ingredient wanting external content.
@@ -673,22 +717,36 @@ void MHEngine::RequestExternalContent(MHIngredient *pRequester)
     if (! pRequester->m_ContentRef.IsSet()) return;
     // Remove any existing content requests for this ingredient.
     CancelExternalContentRequest(pRequester);
+
     QString csPath = GetPathName(pRequester->m_ContentRef.m_ContentRef);
-    // Is this actually a carousel object?  It could be a stream.  We should deal
-    // with that separately.
-    if (csPath.isEmpty())
+    if (m_Context->CheckCarouselObject(csPath))
     {
-        MHLOG(MHLogWarning, "RequestExternalContent empty path");
-        return;
-    }
-    QByteArray text;
-    if (m_Context->CheckCarouselObject(csPath) && m_Context->GetCarouselData(csPath, text)) {
         // Available now - pass it to the ingredient.
-        pRequester->ContentArrived((const unsigned char *)text.data(), text.size(), this);
+        QByteArray text;
+        if (m_Context->GetCarouselData(csPath, text))
+        {
+            // If the content is not recognized catch the exception and continue
+            try
+            {
+                pRequester->ContentArrived((const unsigned char *)text.data(), text.size(), this);
+            }
+            catch (char const *)
+            {}
+        }
+        else
+        {
+            MHLOG(MHLogWarning, QString("WARN No file content %1 <= %2")
+                .arg(pRequester->m_ObjectReference.Printable()).arg(csPath));
+            if (kProtoHTTP == PathProtocol(csPath))
+                EngineEvent(203); // 203=RemoteNetworkError if 404 reply
+            EngineEvent(3); // ContentRefError
+        }
     }
-    else {
+    else
+    {
         // Need to record this and check later.
-        MHLOG(MHLogLinks, QString("RequestExternalContent %1 pending").arg(csPath));
+        MHLOG(MHLogNotifications, QString("Waiting for %1 <= %2")
+            .arg(pRequester->m_ObjectReference.Printable()).arg(csPath.left(128)) );
         MHExternContent *pContent = new MHExternContent;
         pContent->m_FileName = csPath;
         pContent->m_pRequester = pRequester;
@@ -706,8 +764,10 @@ void MHEngine::CancelExternalContentRequest(MHIngredient *pRequester)
     {
         pContent = *it;
         if (pContent->m_pRequester == pRequester) {
-            delete pContent;
+            MHLOG(MHLogNotifications, QString("Cancelled wait for %1")
+                .arg(pRequester->m_ObjectReference.Printable()) );
             it = m_ExternContentTable.erase(it);
+            delete pContent;
             return;
         }
         else
@@ -719,34 +779,55 @@ void MHEngine::CancelExternalContentRequest(MHIngredient *pRequester)
 void MHEngine::CheckContentRequests()
 {
     QList<MHExternContent*>::iterator it = m_ExternContentTable.begin();
-    MHExternContent *pContent;
     while (it != m_ExternContentTable.end())
     {
-        pContent = *it;
-        QByteArray text;
-        if (m_Context->CheckCarouselObject(pContent->m_FileName) &&
-            m_Context->GetCarouselData(pContent->m_FileName, text))
+        MHExternContent *pContent = *it;
+        if (m_Context->CheckCarouselObject(pContent->m_FileName))
         {
-            // If the content is not recognized catch the exception and continue
-            try {
-                MHLOG(MHLogLinks, QString("CheckContentRequests %1 arrived")
-                    .arg(pContent->m_FileName));
-                pContent->m_pRequester->ContentArrived((const unsigned char *)text.data(),
-                                                       text.size(), this);
+            // Remove from the list.
+            it = m_ExternContentTable.erase(it);
+
+            QByteArray text;
+            if (m_Context->GetCarouselData(pContent->m_FileName, text))
+            {
+                MHLOG(MHLogNotifications, QString("Received %1 len %2")
+                    .arg(pContent->m_pRequester->m_ObjectReference.Printable())
+                    .arg(text.size()) );
+                // If the content is not recognized catch the exception and continue
+                try
+                {
+                    pContent->m_pRequester->ContentArrived(
+                        (const unsigned char *)text.data(), text.size(), this);
+                }
+                catch (char const *)
+                {}
             }
-            catch (char const *) {
+            else
+            {
+                MHLOG(MHLogWarning, QString("WARN No file content %1 <= %2")
+                    .arg(pContent->m_pRequester->m_ObjectReference.Printable())
+                    .arg(pContent->m_FileName));
+                if (kProtoHTTP == PathProtocol(pContent->m_FileName))
+                    EngineEvent(203); // 203=RemoteNetworkError if 404 reply
+                EngineEvent(3); // ContentRefError
             }
-            // Remove from the list.
+
             delete pContent;
-            it = m_ExternContentTable.erase(it);
         }
         else if (pContent->m_time.elapsed() > 60000) // TODO Get this from carousel
         {
-            MHLOG(MHLogWarning, QString("CheckContentRequests %1 timed out")
+            // Remove from the list.
+            it = m_ExternContentTable.erase(it);
+
+            MHLOG(MHLogWarning, QString("WARN File timed out %1 <= %2")
+                .arg(pContent->m_pRequester->m_ObjectReference.Printable())
                 .arg(pContent->m_FileName));
+
+            if (kProtoHTTP == PathProtocol(pContent->m_FileName))
+                EngineEvent(203); // 203=RemoteNetworkError if 404 reply
+            EngineEvent(3); // ContentRefError
+
             delete pContent;
-            it = m_ExternContentTable.erase(it);
-            EventTriggered(CurrentApp(), EventEngineEvent, 3); // ContentRefError
         }
         else
             ++it;
@@ -798,6 +879,8 @@ bool MHEngine::GetEngineSupport(const MHOctetString &feature)
     QString csFeat = QString::fromUtf8((const char *)feature.Bytes(), feature.Size());
     QStringList strings = csFeat.split(QRegExp("[\\(\\,\\)]"));
 
+    MHLOG(MHLogNotifications, "NOTE GetEngineSupport " + csFeat);
+
     if (strings[0] == "ApplicationStacking" || strings[0] == "ASt") return true;
     // We're required to support cloning for Text, Bitmap and Rectangle.
     if (strings[0] == "Cloning" || strings[0] == "Clo") return true;
@@ -848,7 +931,9 @@ bool MHEngine::GetEngineSupport(const MHOctetString &feature)
     }
     // We support bitmaps that are partially off screen (don't we?)
     if (strings[0] == "BitmapDecodeOffset" || strings[0] == "BDO") {
-        if (strings.count() >= 3 && strings[1] == "10" && (strings[2] == "0" || strings[2] == "1"))
+        if (strings.count() >= 3 && strings[1] == "2" && (strings[2] == "0" || strings[2] == "1"))
+            return true;
+        else if (strings.count() >= 2 && (strings[1] == "4" || strings[1] == "6"))
             return true;
         else return false;
     }
@@ -868,6 +953,16 @@ bool MHEngine::GetEngineSupport(const MHOctetString &feature)
         else return false;
     }
 
+    // InteractionChannelExtension.
+    if (strings[0] == "ICProfile" || strings[0] == "ICP") {
+        if (strings.count() != 2) return false;
+        if (strings[1] == "0")
+            return true; // // InteractionChannelExtension.
+        if (strings[1] == "1")
+            return false; // ICStreamingExtension.
+        return false;
+    }
+
     // Otherwise return false.
     return false;
 }
@@ -955,7 +1050,7 @@ FILE *__mhlogStream = NULL;
 void __mhlog(QString logtext)
 {
     QByteArray tmp = logtext.toAscii();
-    fprintf(__mhlogStream, "%s\n", tmp.constData());
+    fprintf(__mhlogStream, "[freemheg] %s\n", tmp.constData());
 }
 
 // Called from the user of the library to set the logging.
diff --git a/mythtv/libs/libmythfreemheg/Engine.h b/mythtv/libs/libmythfreemheg/Engine.h
index 34cf4c7..e0a971e 100644
--- a/mythtv/libs/libmythfreemheg/Engine.h
+++ b/mythtv/libs/libmythfreemheg/Engine.h
@@ -117,6 +117,7 @@ public:
     // Generate a UserAction event i.e. a key press.
     virtual void GenerateUserAction(int nCode);
     virtual void EngineEvent(int nCode);
+    virtual void StreamStarted(MHStream*, bool bStarted);
 
     // Called from an ingredient to request a load of external content.
     void RequestExternalContent(MHIngredient *pRequester);
diff --git a/mythtv/libs/libmythfreemheg/Presentable.h b/mythtv/libs/libmythfreemheg/Presentable.h
index c08e4ed..689b5bd 100644
--- a/mythtv/libs/libmythfreemheg/Presentable.h
+++ b/mythtv/libs/libmythfreemheg/Presentable.h
@@ -43,7 +43,6 @@ public:
     virtual void Stop(MHEngine *engine);
 
     // Additional actions for stream components.
-    virtual void SetStreamRef(MHEngine *, const MHContentRef &) {}
     virtual void BeginPlaying(MHEngine *) {}
     virtual void StopPlaying(MHEngine *) {}
 };
diff --git a/mythtv/libs/libmythfreemheg/Programs.cpp b/mythtv/libs/libmythfreemheg/Programs.cpp
index e059ec2..4386f6a 100644
--- a/mythtv/libs/libmythfreemheg/Programs.cpp
+++ b/mythtv/libs/libmythfreemheg/Programs.cpp
@@ -29,6 +29,7 @@
 #include "Logging.h"
 #include "freemheg.h"
 
+#include <QStringList>
 #include <sys/timeb.h>
 #ifdef __FreeBSD__ 
 #include <sys/time.h> 
@@ -109,6 +110,15 @@ static int GetInt(MHParameter *parm, MHEngine *engine)
     return un.m_nIntVal;
 }
 
+// Return a bool value.  May throw an exception if it isn't the correct type.
+static bool GetBool(MHParameter *parm, MHEngine *engine)
+{
+    MHUnion un;
+    un.GetValueFrom(*parm, engine);
+    un.CheckType(MHUnion::U_Bool);
+    return un.m_fBoolVal;
+}
+
 // Extract a string value.
 static void GetString(MHParameter *parm, MHOctetString &str, MHEngine *engine)
 {
@@ -474,7 +484,14 @@ void MHResidentProgram::CallProgram(bool fIsFork, const MHObjectRef &success, co
         }
         else if (m_Name.Equal("SSM")) { // SetSubtitleMode
             // Enable or disable subtitles in addition to MHEG.
-            MHERROR("SetSubtitleMode ResidentProgram is not implemented");
+            if (args.Size() == 1) {
+                bool status = GetBool(args.GetAt(0), engine);
+                MHLOG(MHLogNotifications, QString("NOTE SetSubtitleMode %1")
+                    .arg(status ? "enabled" : "disabled"));
+                // TODO Notify player
+                SetSuccessFlag(success, true, engine);
+            }
+            else SetSuccessFlag(success, false, engine);
         }
 
         else if (m_Name.Equal("WAI")) { // WhoAmI
@@ -523,14 +540,98 @@ void MHResidentProgram::CallProgram(bool fIsFork, const MHObjectRef &success, co
         }
 
         else if (m_Name.Equal("SBI")) { // SetBroadcastInterrupt
-            // Required for InteractionChannelExtension
+            // Required for NativeApplicationExtension
             // En/dis/able program interruptions e.g. green button
-            MHERROR("SetBroadcastInterrupt ResidentProgram is not implemented");
+            if (args.Size() == 1) {
+                bool status = GetBool(args.GetAt(0), engine);
+                MHLOG(MHLogNotifications, QString("NOTE SetBroadcastInterrupt %1")
+                    .arg(status ? "enabled" : "disabled"));
+                // Nothing todo at present
+                SetSuccessFlag(success, true, engine);
+            }
+            else SetSuccessFlag(success, false, engine);
         }
 
+        // InteractionChannelExtension
         else if (m_Name.Equal("GIS")) { // GetICStatus
-            // Required for NativeApplicationExtension
-            MHERROR("GetICStatus ResidentProgram is not implemented");
+            if (args.Size() == 1)
+            {
+                int ICstatus = engine->GetContext()->GetICStatus();
+                MHLOG(MHLogNotifications, "NOTE InteractionChannel " + QString(
+                    ICstatus == 0 ? "active" : ICstatus == 1 ? "inactive" :
+                    ICstatus == 2 ? "disabled" : "undefined"));
+                engine->FindObject(*(args.GetAt(0)->GetReference()))->SetVariableValue(ICstatus);
+                SetSuccessFlag(success, true, engine);
+            }
+            else SetSuccessFlag(success, false, engine);
+        }
+        else if (m_Name.Equal("RDa")) { // ReturnData
+            if (args.Size() >= 3)
+            {
+                MHOctetString string;
+                GetString(args.GetAt(0), string, engine);
+                QString url = QString::fromUtf8((const char *)string.Bytes(), string.Size());
+
+                // Variable name/value pairs
+                QStringList params;
+                int i = 1;
+                for (; i + 2 < args.Size(); i += 2)
+                {
+                    GetString(args.GetAt(i), string, engine);
+                    QString name = QString::fromUtf8((const char *)string.Bytes(), string.Size());
+                    QString val;
+                    MHUnion un;
+                    un.GetValueFrom(*(args.GetAt(i+1)), engine);
+                    switch (un.m_Type) {
+                    case MHUnion::U_Int:
+                        val = QString::number(un.m_nIntVal);
+                        break;
+                    case MHParameter::P_Bool:
+                        val = un.m_fBoolVal ? "true" : "false";
+                        break;
+                    case MHParameter::P_String:
+                        val = QString::fromUtf8((const char*)un.m_StrVal.Bytes(), un.m_StrVal.Size());
+                        break;
+                    case MHParameter::P_ObjRef:
+                        val = un.m_ObjRefVal.Printable();
+                        break;
+                    case MHParameter::P_ContentRef:
+                        val = un.m_ContentRefVal.Printable();
+                        break;
+                    case MHParameter::P_Null:
+                        val = "<NULL>";
+                        break;
+                    default:
+                        val = QString("<type %1>").arg(un.m_Type);
+                        break;
+                    }
+                    params += name + "=" + val;
+                }
+                // TODO
+                MHLOG(MHLogNotifications, "NOTE ReturnData '" + url + "' { " + params.join(" ") + " }");
+                // HTTP response code, 0= none
+                engine->FindObject(*(args.GetAt(i)->GetReference()))->SetVariableValue(0);
+                // HTTP response data
+                string = "";
+                engine->FindObject(*(args.GetAt(i+1)->GetReference()))->SetVariableValue(string);
+                SetSuccessFlag(success, false, engine);
+            }
+            else SetSuccessFlag(success, false, engine);
+        }
+        else if (m_Name.Equal("SHF")) { // SetHybridFileSystem
+            if (args.Size() == 2)
+            {
+                MHOctetString string;
+                GetString(args.GetAt(0), string, engine);
+                QString str = QString::fromUtf8((const char *)string.Bytes(), string.Size());
+                GetString(args.GetAt(1), string, engine);
+                QString str2 = QString::fromUtf8((const char *)string.Bytes(), string.Size());
+                // TODO
+                MHLOG(MHLogNotifications, QString("NOTE SetHybridFileSystem %1=%2")
+                    .arg(str).arg(str2));
+                SetSuccessFlag(success, false, engine);
+            }
+            else SetSuccessFlag(success, false, engine);
         }
 
         else {
@@ -614,7 +715,7 @@ void MHCall::PrintArgs(FILE *fd, int nTabs) const
     m_Succeeded.PrintMe(fd, nTabs);
     fprintf(fd, " ( ");
     for (int i = 0; i < m_Parameters.Size(); i++) m_Parameters.GetAt(i)->PrintMe(fd, 0);
-    fprintf(fd, " )\n");
+    fprintf(fd, " )");
 }
 
 void MHCall::Perform(MHEngine *engine)
diff --git a/mythtv/libs/libmythfreemheg/Root.cpp b/mythtv/libs/libmythfreemheg/Root.cpp
index 5f5cd3b..9a5eaa7 100644
--- a/mythtv/libs/libmythfreemheg/Root.cpp
+++ b/mythtv/libs/libmythfreemheg/Root.cpp
@@ -44,7 +44,7 @@ void MHRoot::PrintMe(FILE *fd, int nTabs) const
 // An action was attempted on an object of a class which doesn't support this.
 void MHRoot::InvalidAction(const char *actionName)
 {
-    MHLOG(MHLogWarning, QString("Action \"%1\" is not understood by class \"%2\"").arg(actionName).arg(ClassName()));
+    MHLOG(MHLogWarning, QString("WARN Action \"%1\" is not understood by class \"%2\"").arg(actionName).arg(ClassName()));
     throw "Invalid Action";
 }
 
diff --git a/mythtv/libs/libmythfreemheg/Root.h b/mythtv/libs/libmythfreemheg/Root.h
index 616e389..36ad74f 100644
--- a/mythtv/libs/libmythfreemheg/Root.h
+++ b/mythtv/libs/libmythfreemheg/Root.h
@@ -175,6 +175,10 @@ public:
     virtual void ScaleVideo(int /*xScale*/, int /*yScale*/, MHEngine *) { InvalidAction("ScaleVideo"); }
     virtual void SetVideoDecodeOffset(int /*newXOffset*/, int /*newYOffset*/, MHEngine *) { InvalidAction("SetVideoDecodeOffset"); }
     virtual void GetVideoDecodeOffset(MHRoot * /*pXOffset*/, MHRoot */*pYOffset*/, MHEngine *) { InvalidAction("GetVideoDecodeOffset"); }
+    virtual void GetCounterPosition(MHRoot * /*pPos*/, MHEngine *) { InvalidAction("GetCounterPosition"); }
+    virtual void GetCounterMaxPosition(MHRoot * /*pPos*/, MHEngine *) { InvalidAction("GetCounterMaxPosition"); }
+    virtual void SetCounterPosition(int /*pos*/, MHEngine *) { InvalidAction("SetCounterPosition"); }
+    virtual void SetSpeed(int /*speed 0=stop*/, MHEngine *) { InvalidAction("SetSpeed"); }
 
     // Actions on Interactibles.
     virtual void SetInteractionStatus(bool /*newStatus*/, MHEngine *) { InvalidAction("SetInteractionStatus"); }
diff --git a/mythtv/libs/libmythfreemheg/Stream.cpp b/mythtv/libs/libmythfreemheg/Stream.cpp
index 5c0fdf0..66e9dde 100644
--- a/mythtv/libs/libmythfreemheg/Stream.cpp
+++ b/mythtv/libs/libmythfreemheg/Stream.cpp
@@ -58,7 +58,11 @@ void MHStream::Initialise(MHParseNode *p, MHEngine *engine)
                 m_Multiplex.Append(pRtGraph);
                 pRtGraph->Initialise(pItem, engine);
             }
-            // Ignore unknown items
+            else {
+                // Ignore unknown items
+                MHLOG(MHLogWarning, QString("WARN unknown stream type %1")
+                    .arg(pItem->GetTagNo()));
+            }
         }
     }
     MHParseNode *pStorage = p->GetNamedArg(C_STORAGE);
@@ -104,8 +108,8 @@ void MHStream::Activation(MHEngine *engine)
     if (m_fRunning) return;
     MHPresentable::Activation(engine);
     // Start playing all active stream components.
-    for (int i = 0; i < m_Multiplex.Size(); i++)
-        m_Multiplex.GetAt(i)->BeginPlaying(engine);
+    BeginPlaying(engine);
+    // subclasses are responsible for setting m_fRunning and generating IsRunning.
     m_fRunning = true;
     engine->EventTriggered(this, EventIsRunning);
 }
@@ -113,10 +117,8 @@ void MHStream::Activation(MHEngine *engine)
 void MHStream::Deactivation(MHEngine *engine)
 {
     if (! m_fRunning) return;
-    // Stop playing all active Stream components
-    for (int i = 0; i < m_Multiplex.Size(); i++)
-        m_Multiplex.GetAt(i)->StopPlaying(engine);
     MHPresentable::Deactivation(engine);
+    StopPlaying(engine);
 }
 
 // The MHEG corrigendum allows SetData to be targeted to a stream so
@@ -124,13 +126,9 @@ void MHStream::Deactivation(MHEngine *engine)
 void MHStream::ContentPreparation(MHEngine *engine)
 {
     engine->EventTriggered(this, EventContentAvailable); // Perhaps test for the streams being available?
-    for (int i = 0; i < m_Multiplex.Size(); i++)
-        m_Multiplex.GetAt(i)->SetStreamRef(engine, m_ContentRef);
+    if (m_fRunning) BeginPlaying(engine);
 }
 
-// TODO: Generate StreamPlaying and StreamStopped events.  These are supposed
-// to be generated as the first and last frames are displayed.
-
 // Return an object if there is a matching component.
 MHRoot *MHStream::FindByObjectNo(int n)
 {
@@ -142,6 +140,53 @@ MHRoot *MHStream::FindByObjectNo(int n)
     return NULL;
 }
 
+void MHStream::BeginPlaying(MHEngine *engine)
+{
+    QString stream;
+    MHOctetString &str = m_ContentRef.m_ContentRef;
+    if (str.Size() != 0) stream = QString::fromUtf8((const char *)str.Bytes(), str.Size());
+    if ( !engine->GetContext()->BeginStream(stream, this))
+        engine->EventTriggered(this, EventEngineEvent, 204); // StreamRefError
+
+    // Start playing all active stream components.
+    for (int i = 0; i < m_Multiplex.Size(); i++)
+        m_Multiplex.GetAt(i)->BeginPlaying(engine);
+
+    //engine->EventTriggered(this, EventStreamPlaying);
+}
+
+void MHStream::StopPlaying(MHEngine *engine)
+{
+    // Stop playing all active Stream components
+    for (int i = 0; i < m_Multiplex.Size(); i++)
+        m_Multiplex.GetAt(i)->StopPlaying(engine);
+    engine->GetContext()->EndStream();
+    engine->EventTriggered(this, EventStreamStopped);
+}
+
+void MHStream::GetCounterPosition(MHRoot *pResult, MHEngine *engine)
+{
+    // StreamCounterUnits (mS)
+    pResult->SetVariableValue((int)engine->GetContext()->GetStreamPos());
+}
+
+void MHStream::GetCounterMaxPosition(MHRoot *pResult, MHEngine *engine)
+{
+    // StreamCounterUnits (mS)
+    pResult->SetVariableValue((int)engine->GetContext()->GetStreamMaxPos());
+}
+
+void MHStream::SetCounterPosition(int pos, MHEngine *engine)
+{
+    // StreamCounterUnits (mS)
+    engine->GetContext()->SetStreamPos(pos);
+}
+
+void MHStream::SetSpeed(int speed, MHEngine *engine)
+{
+    engine->GetContext()->StreamPlay(speed);
+}
+
 MHAudio::MHAudio()
 {
     m_nComponentTag = 0;
@@ -176,13 +221,7 @@ void MHAudio::Activation(MHEngine *engine)
     m_fRunning = true;
     engine->EventTriggered(this, EventIsRunning);
 
-    if (m_fStreamPlaying && m_streamContentRef.IsSet())
-    {
-        QString stream;
-        MHOctetString &str = m_streamContentRef.m_ContentRef;
-        if (str.Size() != 0) stream = QString::fromUtf8((const char *)str.Bytes(), str.Size());
-        engine->GetContext()->BeginAudio(stream, m_nComponentTag);
-    }
+    if (m_fStreamPlaying) engine->GetContext()->BeginAudio(m_nComponentTag);
 }
 
 // Deactivation for Audio is defined in the corrigendum
@@ -197,22 +236,10 @@ void MHAudio::Deactivation(MHEngine *engine)
     MHPresentable::Deactivation(engine);
 }
 
-void MHAudio::SetStreamRef(MHEngine *engine, const MHContentRef &cr)
-{
-    m_streamContentRef.Copy(cr);
-    if (m_fStreamPlaying) BeginPlaying(engine);
-}
-
 void MHAudio::BeginPlaying(MHEngine *engine)
 {
     m_fStreamPlaying = true;
-    if (m_fRunning && m_streamContentRef.IsSet())
-    {
-        QString stream;
-        MHOctetString &str = m_streamContentRef.m_ContentRef;
-        if (str.Size() != 0) stream = QString::fromUtf8((const char *)str.Bytes(), str.Size());
-        engine->GetContext()->BeginAudio(stream, m_nComponentTag);
-    }
+    if (m_fRunning) engine->GetContext()->BeginAudio(m_nComponentTag);
 }
 
 void MHAudio::StopPlaying(MHEngine *engine)
@@ -324,13 +351,7 @@ void MHVideo::Activation(MHEngine *engine)
 {
     if (m_fRunning) return;
     MHVisible::Activation(engine);
-    if (m_fStreamPlaying && m_streamContentRef.IsSet())
-    {
-        QString stream;
-        MHOctetString &str = m_streamContentRef.m_ContentRef;
-        if (str.Size() != 0) stream = QString::fromUtf8((const char *)str.Bytes(), str.Size());
-        engine->GetContext()->BeginVideo(stream, m_nComponentTag);
-    }
+    if (m_fStreamPlaying) engine->GetContext()->BeginVideo(m_nComponentTag);
 }
 
 void MHVideo::Deactivation(MHEngine *engine)
@@ -340,22 +361,10 @@ void MHVideo::Deactivation(MHEngine *engine)
     if (m_fStreamPlaying) engine->GetContext()->StopVideo();
 }
 
-void MHVideo::SetStreamRef(MHEngine *engine, const MHContentRef &cr)
-{
-    m_streamContentRef.Copy(cr);
-    if (m_fStreamPlaying) BeginPlaying(engine);
-}
-
 void MHVideo::BeginPlaying(MHEngine *engine)
 {
     m_fStreamPlaying = true;
-    if (m_fRunning && m_streamContentRef.IsSet())
-    {
-        QString stream;
-        MHOctetString &str = m_streamContentRef.m_ContentRef;
-        if (str.Size() != 0) stream = QString::fromUtf8((const char *)str.Bytes(), str.Size());
-        engine->GetContext()->BeginVideo(stream, m_nComponentTag);
-    }
+    if (m_fRunning) engine->GetContext()->BeginVideo(m_nComponentTag);
 }
 
 void MHVideo::StopPlaying(MHEngine *engine)
@@ -386,3 +395,14 @@ void MHRTGraphics::PrintMe(FILE *fd, int nTabs) const
     MHVisible::PrintMe(fd, nTabs);
     //
 }
+
+// Fix for MHActionGenericObjectRef
+void MHActionGenericObjectRefFix::Perform(MHEngine *engine)
+{
+    MHObjectRef ref;
+    if (m_RefObject.m_fIsDirect)
+        m_RefObject.GetValue(ref, engine);
+    else
+        ref.Copy(*m_RefObject.GetReference());
+    CallAction(engine, Target(engine), engine->FindObject(ref));
+}
diff --git a/mythtv/libs/libmythfreemheg/Stream.h b/mythtv/libs/libmythfreemheg/Stream.h
index 16f36dd..780b7cf 100644
--- a/mythtv/libs/libmythfreemheg/Stream.h
+++ b/mythtv/libs/libmythfreemheg/Stream.h
@@ -44,6 +44,16 @@ public:
     virtual void ContentPreparation(MHEngine *engine);
 
     virtual MHRoot *FindByObjectNo(int n);
+
+    virtual void BeginPlaying(MHEngine *engine);
+    virtual void StopPlaying(MHEngine *engine);
+
+    // Actions
+    virtual void GetCounterPosition(MHRoot *, MHEngine *);
+    virtual void GetCounterMaxPosition(MHRoot *, MHEngine *);
+    virtual void SetCounterPosition(int /*pos*/, MHEngine *);
+    virtual void SetSpeed(int, MHEngine *engine);
+
 protected:
     MHOwnPtrSequence <MHPresentable> m_Multiplex;
     enum Storage { ST_Mem = 1, ST_Stream = 2 } m_nStorage;
@@ -62,7 +72,6 @@ public:
     virtual void Activation(MHEngine *engine);
     virtual void Deactivation(MHEngine *engine);
 
-    virtual void SetStreamRef(MHEngine *, const MHContentRef &);
     virtual void BeginPlaying(MHEngine *engine);
     virtual void StopPlaying(MHEngine *engine);
 
@@ -71,7 +80,6 @@ protected:
     int m_nOriginalVol;
 
     bool m_fStreamPlaying;
-    MHContentRef m_streamContentRef;
 };
 
 class MHVideo : public MHVisible  
@@ -97,7 +105,6 @@ public:
     virtual void SetVideoDecodeOffset(int newXOffset, int newYOffset, MHEngine *);
     virtual void GetVideoDecodeOffset(MHRoot *pXOffset, MHRoot *pYOffset, MHEngine *);
 
-    virtual void SetStreamRef(MHEngine *, const MHContentRef &);
     virtual void BeginPlaying(MHEngine *engine);
     virtual void StopPlaying(MHEngine *engine);
 
@@ -109,7 +116,6 @@ protected:
     int     m_nDecodeWidth, m_nDecodeHeight;
 
     bool m_fStreamPlaying;
-    MHContentRef m_streamContentRef;
 };
 
 // Real-time graphics - not needed for UK MHEG.
@@ -146,5 +152,57 @@ public:
     virtual void CallAction(MHEngine *engine, MHRoot *pTarget, MHRoot *pArg1, MHRoot *pArg2) { pTarget->GetVideoDecodeOffset(pArg1, pArg2, engine); }
 };
 
+class MHActionGenericObjectRefFix: public MHActionGenericObjectRef
+{
+public:
+    MHActionGenericObjectRefFix(const char *name) : MHActionGenericObjectRef(name) {}
+    virtual void Perform(MHEngine *engine);
+};
+
+class MHGetCounterPosition: public MHActionGenericObjectRefFix
+{
+public:
+    MHGetCounterPosition(): MHActionGenericObjectRefFix(":GetCounterPosition")  {}
+    virtual void CallAction(MHEngine *engine, MHRoot *pTarget, MHRoot *pArg)
+        { pTarget->GetCounterPosition(pArg, engine); }
+};
+
+class MHGetCounterMaxPosition: public MHActionGenericObjectRefFix
+{
+public:
+    MHGetCounterMaxPosition(): MHActionGenericObjectRefFix(":GetCounterMaxPosition")  {}
+    virtual void CallAction(MHEngine *engine, MHRoot *pTarget, MHRoot *pArg)
+        { pTarget->GetCounterMaxPosition(pArg, engine); }
+};
+
+class MHSetCounterPosition: public MHActionInt
+{
+public:
+    MHSetCounterPosition(): MHActionInt(":SetCounterPosition")  {}
+    virtual void CallAction(MHEngine *engine, MHRoot *pTarget, int nArg)
+        { pTarget->SetCounterPosition(nArg, engine); }
+};
+
+
+class MHSetSpeed: public MHElemAction
+{
+    typedef MHElemAction base;
+public:
+    MHSetSpeed(): base(":SetSpeed") {}
+    virtual void Initialise(MHParseNode *p, MHEngine *engine) {
+        //printf("SetSpeed Initialise args: "); p->PrintMe(stdout);
+        base::Initialise(p, engine);
+        MHParseNode *pn = p->GetArgN(1);
+        if (pn->m_nNodeType == MHParseNode::PNSeq) pn = pn->GetArgN(0);
+        m_Argument.Initialise(pn, engine);
+    }
+    virtual void Perform(MHEngine *engine) {
+        Target(engine)->SetSpeed(m_Argument.GetValue(engine), engine);
+    }
+protected:
+    virtual void PrintArgs(FILE *fd, int) const { m_Argument.PrintMe(fd, 0); }
+    MHGenericInteger m_Argument;
+};
+
 
 #endif
diff --git a/mythtv/libs/libmythfreemheg/freemheg.h b/mythtv/libs/libmythfreemheg/freemheg.h
index 48bb58d..66ef462 100644
--- a/mythtv/libs/libmythfreemheg/freemheg.h
+++ b/mythtv/libs/libmythfreemheg/freemheg.h
@@ -22,7 +22,12 @@
 #if !defined(FREEMHEG_H)
 #define FREEMHEG_H
 
+#include <QtGlobal>
+#include <QString>
+#include <QByteArray>
 #include <QRegion>
+#include <QRect>
+#include <QSize>
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -32,6 +37,7 @@ class MHTextDisplay;
 class MHBitmapDisplay;
 class MHContext;
 class MHEG;
+class MHStream;
 
 // Called to create a new instance of the module.
 extern MHEG *MHCreateEngine(MHContext *context);
@@ -51,6 +57,7 @@ public:
     // Generate a UserAction event i.e. a key press.
     virtual void GenerateUserAction(int nCode) = 0;
     virtual void EngineEvent(int) = 0;
+    virtual void StreamStarted(MHStream*, bool bStarted = true) = 0;
 };
 
 // Logging control
@@ -128,18 +135,33 @@ public:
     // the m_stopped condition if we have.
     virtual bool CheckStop(void) = 0;
 
-    // Begin playing audio from the specified stream
-    virtual bool BeginAudio(const QString &stream, int tag) = 0;
+    // Begin playing the specified stream
+    virtual bool BeginStream(const QString &str, MHStream* notify = 0) = 0;
+    // Stop playing stream
+    virtual void EndStream() = 0;
+    // Begin playing audio component
+    virtual bool BeginAudio(int tag) = 0;
     // Stop playing audio
-    virtual void StopAudio(void) = 0;
-    // Begin displaying video from the specified stream
-    virtual bool BeginVideo(const QString &stream, int tag) = 0;
+    virtual void StopAudio() = 0;
+    // Begin displaying video component
+    virtual bool BeginVideo(int tag) = 0;
     // Stop displaying video
-    virtual void StopVideo(void) = 0;
+    virtual void StopVideo() = 0;
+    // Get current stream position in mS, -1 if unknown
+    virtual long GetStreamPos() = 0;
+    // Get current stream size in mS, -1 if unknown
+    virtual long GetStreamMaxPos() = 0;
+    // Set current stream position in mS
+    virtual long SetStreamPos(long) = 0;
+    // Play or pause a stream
+    virtual void StreamPlay(bool play = true) = 0;
 
     // Get the context id strings.
     virtual const char *GetReceiverId(void) = 0;
     virtual const char *GetDSMCCId(void) = 0;
+
+    // InteractionChannel
+    virtual int GetICStatus() = 0; // 0= Active, 1= Inactive, 2= Disabled
 };
 
 // Dynamic Line Art objects record a sequence of drawing actions.
diff --git a/mythtv/libs/libmythtv/libmythtv.pro b/mythtv/libs/libmythtv/libmythtv.pro
index d46e49c..2d61006 100644
--- a/mythtv/libs/libmythtv/libmythtv.pro
+++ b/mythtv/libs/libmythtv/libmythtv.pro
@@ -370,8 +370,8 @@ using_frontend {
         SOURCES += dsmccbiop.cpp            dsmccobjcarousel.cpp
 
         # MHEG interaction channel
-        HEADERS += netstream.h
-        SOURCES += netstream.cpp
+        HEADERS += mhegic.h                 netstream.h
+        SOURCES += mhegic.cpp               netstream.cpp
 
         # MHEG/MHI stuff
         HEADERS += interactivetv.h          mhi.h
diff --git a/mythtv/libs/libmythtv/mhegic.cpp b/mythtv/libs/libmythtv/mhegic.cpp
new file mode 100644
index 0000000..d4099bd
--- /dev/null
+++ b/mythtv/libs/libmythtv/mhegic.cpp
@@ -0,0 +1,183 @@
+/* MHEG Interaction Channel
+ * Copyright 2011 Lawrence Rust <lvr at softsystem dot co dot uk>
+ */
+#include "mhegic.h"
+
+// C/C++ lib
+#include <cstdlib>
+using std::getenv;
+
+// Qt
+#include <QByteArray>
+#include <QMutexLocker>
+#include <QNetworkRequest>
+#include <QStringList>
+#include <QScopedPointer>
+#include <QApplication>
+
+// Myth
+#include "netstream.h"
+#include "mythverbose.h"
+
+#define LOC QString("[mhegic] ")
+
+
+MHInteractionChannel::MHInteractionChannel(QObject* parent) : QObject(parent)
+{
+    setObjectName("MHInteractionChannel");
+    moveToThread(&NAMThread::manager());
+}
+
+// virtual
+MHInteractionChannel::~MHInteractionChannel()
+{
+    QMutexLocker locker(&m_mutex);
+    for ( map_t::iterator it = m_pending.begin(); it != m_pending.end(); ++it)
+        (*it)->deleteLater();
+    for ( map_t::iterator it = m_finished.begin(); it != m_finished.end(); ++it)
+        (*it)->deleteLater();
+}
+
+// Get network status
+// static
+MHInteractionChannel::EStatus MHInteractionChannel::status()
+{
+    if (!NetStream::isAvailable())
+    {
+        VERBOSE(VB_MHEG, LOC + "WARN network is unavailable");
+        return kInactive;
+    }
+
+    // TODO get this from mythdb
+    QStringList opts = QString(getenv("MYTHMHEG")).split(':');
+    if (opts.contains("noice", Qt::CaseInsensitive))
+        return kDisabled;
+    else if (opts.contains("ice", Qt::CaseInsensitive))
+        return kActive;
+    else // Default
+        return kActive;
+}
+
+static inline bool isCached(const QString& csPath)
+{
+    return NetStream::GetLastModified(csPath).isValid();
+}
+
+// Is a file ready to read?
+bool MHInteractionChannel::CheckFile(const QString& csPath)
+{
+    QMutexLocker locker(&m_mutex);
+
+    // Is it complete?
+    if (m_finished.contains(csPath))
+        return true;
+
+    // Is it pending?
+    if (m_pending.contains(csPath))
+        return false; // It's pending so unavailable
+
+    // Is it in the cache?
+    if (isCached(csPath))
+        return true; // It's cached
+
+    // Queue a request
+    VERBOSE(VB_MHEG|VB_EXTRA, LOC + QString("CheckFile queue %1").arg(csPath));
+    QScopedPointer< NetStream > p(new NetStream(csPath));
+    if (!p || !p->IsOpen())
+    {
+        VERBOSE(VB_MHEG, LOC + QString("CheckFile failed %1").arg(csPath) );
+        return false;
+    }
+
+    connect(p.data(), SIGNAL(Finished(QObject*)), this, SLOT(slotFinished(QObject*)) );
+    m_pending.insert(csPath, p.take());
+
+    return false; // It's now pending so unavailable
+}
+
+// Read a file. -1= error, 0= OK, 1= not ready
+MHInteractionChannel::EResult
+MHInteractionChannel::GetFile(const QString &csPath, QByteArray &data)
+{
+    QMutexLocker locker(&m_mutex);
+
+    // Is it pending?
+    if (m_pending.contains(csPath))
+        return kPending;
+
+    // Is it complete?
+    QScopedPointer< NetStream > p(m_finished.take(csPath));
+    if (p)
+    {
+        if (p->GetError() == QNetworkReply::NoError)
+        {
+            data = p->ReadAll();
+            VERBOSE(VB_MHEG|VB_EXTRA, LOC + QString("GetFile finished %1").arg(csPath) );
+            return kSuccess;
+        }
+
+        VERBOSE(VB_MHEG, LOC + QString("GetFile failed %1").arg(csPath) );
+        return kError;
+    }
+
+    // Is it in the cache?
+    if (isCached(csPath))
+    {
+        VERBOSE(VB_MHEG|VB_EXTRA, LOC + QString("GetFile cache read %1").arg(csPath) );
+
+        NetStream req(csPath, NetStream::kAlwaysCache);
+        if (req.WaitTillFinished(3000) && req.GetError() == QNetworkReply::NoError)
+        {
+            data = req.ReadAll();
+            VERBOSE(VB_MHEG|VB_EXTRA, LOC + QString("GetFile cache read %1 bytes %2")
+                .arg(data.size()).arg(csPath) );
+            return kSuccess;
+        }
+
+        VERBOSE(VB_MHEG, LOC + QString("GetFile cache read failed %1").arg(csPath) );
+        //return kError;
+        // Retry
+    }
+
+    // Queue a download
+    VERBOSE(VB_MHEG|VB_EXTRA, LOC + QString("GetFile queue %1").arg(csPath) );
+    p.reset(new NetStream(csPath));
+    if (!p || !p->IsOpen())
+    {
+        VERBOSE(VB_MHEG, LOC + QString("GetFile failed %1").arg(csPath) );
+        return kError;
+    }
+
+    connect(p.data(), SIGNAL(Finished(QObject*)), this, SLOT(slotFinished(QObject*)) );
+    m_pending.insert(csPath, p.take());
+
+    return kPending;
+}
+
+// signal from NetStream
+void MHInteractionChannel::slotFinished(QObject *obj)
+{
+    NetStream* p = dynamic_cast< NetStream* >(obj);
+    if (!p)
+        return;
+
+    QString url = p->Url().toString();
+
+    if (p->GetError() == QNetworkReply::NoError)
+    {
+        VERBOSE(VB_MHEG|VB_EXTRA, LOC + QString("Finished %1").arg(url) );
+    }
+    else
+    {
+        VERBOSE(VB_MHEG, LOC + QString("Finished %1").arg(p->GetErrorString()) );
+    }
+
+    p->disconnect();
+
+    QMutexLocker locker(&m_mutex);
+
+    m_pending.remove(url);
+    m_finished.insert(url, p);
+}
+
+/* End of file */
diff --git a/mythtv/libs/libmythtv/mhegic.h b/mythtv/libs/libmythtv/mhegic.h
new file mode 100644
index 0000000..fcad95f
--- /dev/null
+++ b/mythtv/libs/libmythtv/mhegic.h
@@ -0,0 +1,50 @@
+/* MHEG Interaction Channel
+ * Copyright 2011 Lawrence Rust <lvr at softsystem dot co dot uk>
+ */
+#ifndef MHEGIC_H
+#define MHEGIC_H
+
+#include <QObject>
+#include <QString>
+#include <QMutex>
+#include <QHash>
+
+class QByteArray;
+class NetStream;
+
+class MHInteractionChannel : public QObject
+{
+    Q_OBJECT
+    Q_DISABLE_COPY(MHInteractionChannel)
+
+public:
+    MHInteractionChannel(QObject* parent = 0);
+    virtual ~MHInteractionChannel();
+
+    // Properties
+public:
+    // Get network status
+    enum EStatus { kActive = 0, kInactive, kDisabled };
+    static EStatus status();
+
+    // Operations
+public:
+    // Is a file ready to read?
+    bool CheckFile(const QString &url);
+    // Read a file
+    enum EResult { kError = -1, kSuccess = 0, kPending };
+    EResult GetFile(const QString &url, QByteArray &data);
+
+    // Implementation
+private slots:
+    // NetStream signals
+    void slotFinished(QObject*);
+
+private:
+    mutable QMutex m_mutex;
+    typedef QHash< QString, NetStream* > map_t;
+    map_t m_pending; // Pending requests
+    map_t m_finished; // Completed requests
+};
+
+#endif /* ndef MHEGIC_H */
diff --git a/mythtv/libs/libmythtv/mhi.cpp b/mythtv/libs/libmythtv/mhi.cpp
index f37206c..d0386b8 100644
--- a/mythtv/libs/libmythtv/mhi.cpp
+++ b/mythtv/libs/libmythtv/mhi.cpp
@@ -1,10 +1,12 @@
+#include "mhi.h"
+
 #include <unistd.h>
 
 #include <QRegion>
 #include <QBitArray>
 #include <QVector>
+#include <QUrl>
 
-#include "mhi.h"
 #include "interactivescreen.h"
 #include "mythpainter.h"
 #include "mythimage.h"
@@ -107,7 +109,7 @@ bool MHIContext::LoadFont(QString name)
     if (!errorD)
         return true;
 
-    VERBOSE(VB_IMPORTANT, QString("Unable to find font: %1").arg(name));
+    VERBOSE(VB_IMPORTANT, QString("[mhi] Unable to find font: %1").arg(name));
     return false;
 }
 
@@ -160,8 +162,10 @@ void MHIContext::Restart(uint chanid, uint cardid, bool isLive)
 {
     int tuneinfo = m_tuneinfo.isEmpty() ? 0 : m_tuneinfo.takeFirst();
 
-    VERBOSE(VB_MHEG, QString("[mhi] Restart ch=%1 card=%2 live=%3 tuneinfo=0x%4")
-        .arg((int)chanid).arg((int)cardid).arg(isLive).arg(tuneinfo,0,16));
+    VERBOSE(VB_GENERAL,
+         QString("[mhi] Restart(%5) ch=%1 card=%2 live=%3 tuneinfo=0x%4")
+        .arg((int)chanid).arg((int)cardid).arg(isLive).arg(tuneinfo,0,16)
+        .arg((quintptr)this,0,16) );
 
     m_currentCard = cardid;
     m_currentStream = (chanid) ? (int)chanid : -1;
@@ -225,11 +229,11 @@ void MHIContext::Restart(uint chanid, uint cardid, bool isLive)
 // Thread function to run the MHEG engine.
 void *MHIContext::StartMHEGEngine(void *param)
 {
-    //VERBOSE(VB_GENERAL, "Starting MHEG Engine");
+    VERBOSE(VB_MHEG, QString("[mhi] Engine(%1) starting").arg((quintptr)param,0,16) );
     MHIContext *context = (MHIContext*) param;
     context->RunMHEGEngine();
     context->m_stopped = true;
-    VERBOSE(VB_MHEG, "[mhi] Engine stopped");
+    VERBOSE(VB_MHEG, QString("[mhi] Engine(%1) stopped").arg((quintptr)param,0,16) );
     return NULL;
 }
 
@@ -255,10 +259,7 @@ void MHIContext::RunMHEGEngine(void)
             // Run the engine and find out how long to pause.
             toWait = m_engine->RunAll();
             if (toWait < 0)
-            {
-                VERBOSE(VB_GENERAL, "[mhi] Engine requested exit");
                 return;
-            }
         } while (key != 0);
 
         if (toWait > 1000 || toWait <= 0)
@@ -355,7 +356,7 @@ void MHIContext::NetworkBootRequested(void)
             m_engine->EngineEvent(9); // NetworkBootInfo EngineEvent
             break;
         default:
-            VERBOSE(VB_GENERAL, QString("[mhi] Unknown NetworkBoot type %1")
+            VERBOSE(VB_IMPORTANT, QString("[mhi] Unknown NetworkBoot type %1")
                     .arg(m_nbiData[1]));
             break;
         }
@@ -365,6 +366,13 @@ void MHIContext::NetworkBootRequested(void)
 // Called by the engine to check for the presence of an object in the carousel.
 bool MHIContext::CheckCarouselObject(QString objectPath)
 {
+    if (objectPath.startsWith("http:") || objectPath.startsWith("https:"))
+    {
+        // TODO verify access to server in carousel file auth.servers
+        // TODO use TLS cert from carousel auth.tls.<x>
+        return m_ic.CheckFile(objectPath);
+    }
+
     QStringList path = objectPath.split(QChar('/'), QString::SkipEmptyParts);
     QByteArray result; // Unused
     int res = m_dsmcc->GetDSMCCObject(path, result);
@@ -374,6 +382,8 @@ bool MHIContext::CheckCarouselObject(QString objectPath)
 // Called by the engine to request data from the carousel.
 bool MHIContext::GetCarouselData(QString objectPath, QByteArray &result)
 {
+    bool const isIC = objectPath.startsWith("http:") || objectPath.startsWith("https:");
+
     // Get the path components.  The string will normally begin with "//"
     // since this is an absolute path but that will be removed by split.
     QStringList path = objectPath.split(QChar('/'), QString::SkipEmptyParts);
@@ -381,27 +391,151 @@ bool MHIContext::GetCarouselData(QString objectPath, QByteArray &result)
     // same thread this is safe.  Otherwise we need to make a deep copy of
     // the result.
 
+    bool bReported = false;
     QTime t; t.start();
     while (!m_stop)
     {
-        int res = m_dsmcc->GetDSMCCObject(path, result);
-        if (res == 0)
-            return true; // Found it
-        else if (res < 0)
-            return false; // Not there.
-        else if (t.elapsed() > 60000) // TODO get this from carousel info
+        if (isIC)
+        {
+            // TODO verify access to server in carousel file auth.servers
+            // TODO use TLS cert from carousel file auth.tls.<x>
+            switch (m_ic.GetFile(objectPath, result))
+            {
+            case MHInteractionChannel::kSuccess:
+                if (bReported)
+                    VERBOSE(VB_MHEG, QString("[mhi] Received %1").arg(objectPath));
+                return true;
+            case MHInteractionChannel::kError:
+                if (bReported)
+                    VERBOSE(VB_MHEG, QString("[mhi] Not found %1").arg(objectPath));
+                return false;
+            case MHInteractionChannel::kPending:
+                break;
+            }
+        }
+        else
+        {
+            int res = m_dsmcc->GetDSMCCObject(path, result);
+            if (res == 0)
+            {
+                if (bReported)
+                    VERBOSE(VB_MHEG, QString("[mhi] Received %1").arg(objectPath));
+                return true; // Found it
+            }
+            else if (res < 0)
+            {
+                if (bReported)
+                    VERBOSE(VB_MHEG, QString("[mhi] Not found %1").arg(objectPath));
+                return false; // Not there.
+            }
+        }
+
+        if (t.elapsed() > 60000) // TODO get this from carousel info
             return false; // Not there.
         // Otherwise we block.
-        // Process DSMCC packets then block for a second or until we receive
+        if (!bReported)
+        {
+            bReported = true;
+            VERBOSE(VB_MHEG, QString("[mhi] Waiting for %1").arg(objectPath));
+        }
+        // Process DSMCC packets then block for a while or until we receive
         // some more packets.  We should eventually find out if this item is
         // present.
         ProcessDSMCCQueue();
         QMutexLocker locker(&m_engineLock);
-        m_engine_wait.wait(&m_engineLock, 1000);
+        m_engine_wait.wait(&m_engineLock, 300);
     }
     return false; // Stop has been set.  Say the object isn't present.
 }
 
+// Mapping from key name & UserInput register to UserInput EventData
+class MHKeyLookup
+{
+    typedef QPair< QString, int /*UserInput register*/ > key_t;
+
+public:
+    MHKeyLookup();
+
+    int Find(const QString &name, int reg) const
+        { return m_map.value(key_t(name,reg), 0); }
+
+private:
+    void key(const QString &name, int code, int r1,
+        int r2=0, int r3=0, int r4=0, int r5=0, int r6=0, int r7=0, int r8=0, int r9=0);
+
+    QHash<key_t,int /*EventData*/ > m_map;
+};
+
+void MHKeyLookup::key(const QString &name, int code, int r1,
+    int r2, int r3, int r4, int r5, int r6, int r7, int r8, int r9)
+{
+    m_map.insert(key_t(name,r1), code);
+    if (r2 > 0)
+        m_map.insert(key_t(name,r2), code);
+    if (r3 > 0)
+        m_map.insert(key_t(name,r3), code);
+    if (r4 > 0)
+        m_map.insert(key_t(name,r4), code);
+    if (r5 > 0)
+        m_map.insert(key_t(name,r5), code);
+    if (r6 > 0)
+        m_map.insert(key_t(name,r6), code);
+    if (r7 > 0)
+        m_map.insert(key_t(name,r7), code);
+    if (r8 > 0)
+        m_map.insert(key_t(name,r8), code);
+    if (r9 > 0)
+        m_map.insert(key_t(name,r9), code);
+}
+
+MHKeyLookup::MHKeyLookup()
+{
+    // This supports the UK and NZ key profile registers.
+    // The UK uses 3, 4 and 5 and NZ 13, 14 and 15.  These are
+    // similar but the NZ profile also provides an EPG key.
+    // ETSI ES 202 184 V2.2.1 (2011-03) adds group 6 for ICE.
+    // The BBC use group 7 for ICE
+    key("UP",           1, 4,5,6,7,14,15);
+    key("DOWN",         2, 4,5,6,7,14,15);
+    key("LEFT",         3, 4,5,6,7,14,15);
+    key("RIGHT",        4, 4,5,6,7,14,15);
+    key("0",            5, 4,6,7,14);
+    key("1",            6, 4,6,7,14);
+    key("2",            7, 4,6,7,14);
+    key("3",            8, 4,6,7,14);
+    key("4",            9, 4,6,7,14);
+    key("5",           10, 4,6,7,14);
+    key("6",           11, 4,6,7,14);
+    key("7",           12, 4,6,7,14);
+    key("8",           13, 4,6,7,14);
+    key("9",           14, 4,6,7,14);
+    key("SELECT",      15, 4,5,6,7,14,15);
+    key("TEXTEXIT",    16, 3,4,5,6,7,13,14,15); // 16= Cancel
+    // 17= help
+    // 18..99 reserved by DAVIC
+    key("MENURED",    100, 3,4,5,6,7,13,14,15);
+    key("MENUGREEN",  101, 3,4,5,6,7,13,14,15);
+    key("MENUYELLOW", 102, 3,4,5,6,7,13,14,15);
+    key("MENUBLUE",   103, 3,4,5,6,7,13,14,15);
+    key("MENUTEXT",   104, 3,4,5,6,7);
+    key("MENUTEXT",   105, 13,14,15); // NB from original Myth code
+    // 105..119 reserved for future spec
+    key("STOP",       120, 6,7);
+    key("PLAY",       121, 6,7);
+    key("PAUSE",      122, 6,7);
+    key("JUMPFFWD",   123, 6,7); // 123= Skip Forward
+    key("JUMPRWND",   124, 6,7); // 124= Skip Back
+#if 0 // These conflict with left & right
+    key("SEEKFFWD",   125, 6,7); // 125= Fast Forward
+    key("SEEKRWND",   126, 6,7); // 126= Rewind
+#endif
+    key("PLAYBACK",   127, 6,7);
+    // 128..256 reserved for future spec
+    // 257..299 vendor specific
+    key("MENUEPG",    300, 13,14,15);
+    // 301.. Vendor specific
+}
+
 // Called from tv_play when a key is pressed.
 // If it is one in the current profile we queue it for the engine
 // and return true otherwise we return false.
@@ -410,78 +544,18 @@ bool MHIContext::OfferKey(QString key)
     if (m_stopped)
         return false;
 
-    int action = 0;
-    QMutexLocker locker(&m_keyLock);
-
-    // This supports the UK and NZ key profile registers.
-    // The UK uses 3, 4 and 5 and NZ 13, 14 and 15.  These are
-    // similar but the NZ profile also provides an EPG key.
-
-    if (key == "UP")
-    {
-        if (m_keyProfile == 4 || m_keyProfile == 5 ||
-            m_keyProfile == 14 || m_keyProfile == 15)
-            action = 1;
-    }
-    else if (key == "DOWN")
-    {
-        if (m_keyProfile == 4 || m_keyProfile == 5 ||
-            m_keyProfile == 14 || m_keyProfile == 15)
-            action = 2;
-    }
-    else if (key == "LEFT")
-    {
-        if (m_keyProfile == 4 || m_keyProfile == 5 ||
-            m_keyProfile == 14 || m_keyProfile == 15)
-            action = 3;
-    }
-    else if (key == "RIGHT")
-    {
-        if (m_keyProfile == 4 || m_keyProfile == 5 ||
-            m_keyProfile == 14 || m_keyProfile == 15)
-            action = 4;
-    }
-    else if (key == "0" || key == "1" || key == "2" ||
-             key == "3" || key == "4" || key == "5" ||
-             key == "6" || key == "7" || key == "8" ||
-             key == "9")
-    {
-        if (m_keyProfile == 4 || m_keyProfile == 14)
-            action = key.toInt() + 5;
-    }
-    else if (key == "SELECT")
-    {
-        if (m_keyProfile == 4 || m_keyProfile == 5 ||
-            m_keyProfile == 14 || m_keyProfile == 15)
-            action = 15;
-    }
-    else if (key == "TEXTEXIT")
-        action = 16;
-    else if (key == "MENURED")
-        action = 100;
-    else if (key == "MENUGREEN")
-        action = 101;
-    else if (key == "MENUYELLOW")
-        action = 102;
-    else if (key == "MENUBLUE")
-        action = 103;
-    else if (key == "MENUTEXT")
-        action = m_keyProfile > 12 ? 105 : 104;
-    else if (key == "MENUEPG")
-        action = m_keyProfile > 12 ? 300 : 0;
-
-    if (action != 0)
-    {
-        m_keyQueue.enqueue(action);
-        VERBOSE(VB_IMPORTANT, "Adding MHEG key "<<key<<":"<<action
-                <<":"<<m_keyQueue.size());
-        locker.unlock();
-        QMutexLocker locker2(&m_engineLock);
-        m_engine_wait.wakeAll();
-        return true;
-    }
+    static const MHKeyLookup s_keymap;
+    int action = s_keymap.Find(key, m_keyProfile);
+    if (action == 0)
+        return false;
 
-    return false;
+    VERBOSE(VB_IMPORTANT, "[mhi] Adding MHEG key "<<key<<":"<<action
+            <<":"<<m_keyQueue.size());
+    { QMutexLocker locker(&m_keyLock);
+    m_keyQueue.enqueue(action);}
+    QMutexLocker locker2(&m_engineLock);
+    m_engine_wait.wakeAll();
+    return true;
 }
 
 void MHIContext::Reinit(const QRect &display)
@@ -496,11 +570,17 @@ void MHIContext::Reinit(const QRect &display)
 
 void MHIContext::SetInputRegister(int num)
 {
+    VERBOSE(VB_MHEG, QString("[mhi] SetInputRegister %1").arg(num));
     QMutexLocker locker(&m_keyLock);
     m_keyQueue.clear();
     m_keyProfile = num;
 }
 
+int MHIContext::GetICStatus()
+{
+   // 0= Active, 1= Inactive, 2= Disabled
+    return m_ic.status();
+}
 
 // Called by the video player to redraw the image.
 void MHIContext::UpdateOSD(InteractiveScreen *osdWindow,
@@ -711,7 +791,7 @@ int MHIContext::GetChannelIndex(const QString &str)
             nResult = query.value(0).toInt();
     }
     else if (str == "rec://svc/cur")
-        nResult = m_currentStream;
+        nResult = m_currentStream > 0 ? m_currentStream : m_currentChannel;
     else if (str == "rec://svc/def")
         nResult = m_currentChannel;
     else if (str.startsWith("rec://"))
@@ -727,7 +807,6 @@ int MHIContext::GetChannelIndex(const QString &str)
 bool MHIContext::GetServiceInfo(int channelId, int &netId, int &origNetId,
                                 int &transportId, int &serviceId)
 {
-    VERBOSE(VB_MHEG, QString("[mhi] GetServiceInfo %1").arg(channelId));
     MSqlQuery query(MSqlQuery::InitCon());
     query.prepare("SELECT networkid, transportid, serviceid "
                   "FROM channel, dtv_multiplex "
@@ -740,18 +819,26 @@ bool MHIContext::GetServiceInfo(int channelId, int &netId, int &origNetId,
         origNetId = netId; // We don't have this in the database.
         transportId = query.value(1).toInt();
         serviceId = query.value(2).toInt();
+        VERBOSE(VB_MHEG, QString("[mhi] GetServiceInfo %1 => NID=%2 TID=%3 SID=%4")
+            .arg(channelId).arg(netId).arg(transportId).arg(serviceId));
         return true;
     }
-    else return false;
+
+    VERBOSE(VB_IMPORTANT, QString("[mhi] WARN GetServiceInfo %1 failed").arg(channelId));
+    return false;
 }
 
 bool MHIContext::TuneTo(int channel, int tuneinfo)
 {
-    VERBOSE(VB_MHEG, QString("[mhi] TuneTo %1 0x%2")
-        .arg(channel).arg(tuneinfo,0,16));
     if (!m_isLive)
+    {
+        VERBOSE(VB_IMPORTANT, QString("[mhi] Can't TuneTo %1 0x%2 while not live")
+            .arg(channel).arg(tuneinfo,0,16));
         return false; // Can't tune if this is a recording.
+    }
 
+    VERBOSE(VB_GENERAL, QString("[mhi] TuneTo %1 0x%2")
+        .arg(channel).arg(tuneinfo,0,16));
     m_tuneinfo.append(tuneinfo);
 
     // Post an event requesting a channel change.
@@ -764,66 +851,137 @@ bool MHIContext::TuneTo(int channel, int tuneinfo)
     return true;
 }
 
-// Begin playing audio from the specified stream
-bool MHIContext::BeginAudio(const QString &stream, int tag)
+// Begin playing the specified stream
+bool MHIContext::BeginStream(const QString &stream, MHStream *notify)
 {
-    VERBOSE(VB_MHEG, QString("[mhi] BeginAudio %1 %2").arg(stream).arg(tag));
+    VERBOSE(VB_MHEG, QString("[mhi] BeginStream %1 0x%2")
+        .arg(stream).arg((quintptr)notify,0,16));
+
+    m_audioTag = -1;
+    m_videoTag = -1;
+    m_notify = notify;
+
+    if (stream.startsWith("http://") || stream.startsWith("https://"))
+    {
+        m_currentStream = -1;
+
+        // The url is sometimes only http:// during stream startup
+        if (QUrl(stream).authority().isEmpty())
+            return false;
+
+        return m_parent->GetNVP()->SetStream(stream);
+    }
+
     int chan = GetChannelIndex(stream);
     if (chan < 0)
         return false;
+    if (VERBOSE_LEVEL_CHECK(VB_MHEG))
+    {
+        int netId, origNetId, transportId, serviceId;
+        GetServiceInfo(chan, netId, origNetId, transportId, serviceId);
+    }
 
     if (chan != m_currentStream)
     {
-        // We have to tune to the channel where the audio is to be found.
+        // We have to tune to the channel where the stream is to be found.
         // Because the audio and video are both components of an MHEG stream
         // they will both be on the same channel.
         m_currentStream = chan;
-        m_audioTag = tag;
         return TuneTo(chan, kTuneKeepChnl|kTuneQuietly|kTuneKeepApp);
     }
 
+    return true;
+}
+
+void MHIContext::EndStream()
+{
+    VERBOSE(VB_MHEG, QString("[mhi] EndStream 0x%1")
+        .arg((quintptr)m_notify,0,16) );
+
+    m_notify = 0;
+    (void)m_parent->GetNVP()->SetStream(QString());
+}
+
+// Callback from MythPlayer when a stream starts or stops
+bool MHIContext::StreamStarted(bool bStarted)
+{
+    if (!m_engine || !m_notify)
+        return false;
+
+    VERBOSE(VB_MHEG, QString("[mhi] Stream 0x%1 %2")
+        .arg((quintptr)m_notify,0,16).arg(bStarted ? "started" : "stopped"));
+
+    m_engine->StreamStarted(m_notify, bStarted);
+    if (!bStarted)
+        m_notify = 0;
+    return m_currentStream == -1; // Return true if it's an http stream
+}
+
+// Begin playing audio
+bool MHIContext::BeginAudio(int tag)
+{
+    VERBOSE(VB_MHEG, QString("[mhi] BeginAudio %1").arg(tag));
+
     if (tag < 0)
         return true; // Leave it at the default.
-    else if (m_parent->GetNVP())
+
+    m_audioTag = tag;
+    if (m_parent->GetNVP())
         return m_parent->GetNVP()->SetAudioByComponentTag(tag);
-    else
-        return false;
+    return false;
 }
 
 // Stop playing audio
-void MHIContext::StopAudio(void)
+void MHIContext::StopAudio()
 {
     // Do nothing at the moment.
 }
 
 // Begin displaying video from the specified stream
-bool MHIContext::BeginVideo(const QString &stream, int tag)
+bool MHIContext::BeginVideo(int tag)
 {
-    VERBOSE(VB_MHEG, QString("[mhi] BeginVideo %1 %2").arg(stream).arg(tag));
-    int chan = GetChannelIndex(stream);
-    if (chan < 0)
-        return false;
-    if (chan != m_currentStream)
-    {
-        // We have to tune to the channel where the video is to be found.
-        m_currentStream = chan;
-        m_videoTag = tag;
-        return TuneTo(chan, kTuneKeepChnl|kTuneQuietly|kTuneKeepApp);
-    }
+    VERBOSE(VB_MHEG, QString("[mhi] BeginVideo %1").arg(tag));
+
     if (tag < 0)
         return true; // Leave it at the default.
-    else if (m_parent->GetNVP())
-        return m_parent->GetNVP()->SetVideoByComponentTag(tag);
 
+    m_videoTag = tag;
+    if (m_parent->GetNVP())
+        return m_parent->GetNVP()->SetVideoByComponentTag(tag);
     return false;
 }
 
 // Stop displaying video
-void MHIContext::StopVideo(void)
+void MHIContext::StopVideo()
 {
     // Do nothing at the moment.
 }
 
+// Get current stream position, -1 if unknown
+long MHIContext::GetStreamPos()
+{
+    return m_parent->GetNVP() ? m_parent->GetNVP()->GetStreamPos() : -1;
+}
+
+// Get current stream size, -1 if unknown
+long MHIContext::GetStreamMaxPos()
+{
+    return m_parent->GetNVP() ? m_parent->GetNVP()->GetStreamMaxPos() : -1;
+}
+
+// Set current stream position
+long MHIContext::SetStreamPos(long pos)
+{
+    return m_parent->GetNVP() ? m_parent->GetNVP()->SetStreamPos(pos) : -1;
+}
+
+// Play or pause a stream
+void MHIContext::StreamPlay(bool play)
+{
+    if (m_parent->GetNVP())
+        m_parent->GetNVP()->StreamPlay(play);
+}
+
 // Create a new object to draw dynamic line art.
 MHDLADisplay *MHIContext::CreateDynamicLineArt(
     bool isBoxed, MHRgba lineColour, MHRgba fillColour)
@@ -874,16 +1032,15 @@ void MHIContext::DrawRect(int xPos, int yPos, int width, int height,
 // and usually that will be the same as the origin of the bounding
 // box (clipRect).
 void MHIContext::DrawImage(int x, int y, const QRect &clipRect,
-                           const QImage &qImage)
+                           const QImage &qImage, bool bScaled /* = false */)
 {
     if (qImage.isNull())
         return;
 
     QRect imageRect(x, y, qImage.width(), qImage.height());
-    QRect displayRect = QRect(clipRect.x(), clipRect.y(),
-                              clipRect.width(), clipRect.height()) & imageRect;
+    QRect displayRect = clipRect & imageRect;
 
-    if (displayRect == imageRect) // No clipping required
+    if (bScaled || displayRect == imageRect) // No clipping required
     {
         QImage q_scaled =
             qImage.scaled(
@@ -897,8 +1054,7 @@ void MHIContext::DrawImage(int x, int y, const QRect &clipRect,
     else if (!displayRect.isEmpty())
     { // We must clip the image.
         QImage clipped = qImage.convertToFormat(QImage::Format_ARGB32)
-            .copy(displayRect.x() - x, displayRect.y() - y,
-                  displayRect.width(), displayRect.height());
+            .copy(displayRect.translated(-x, -y));
         QImage q_scaled =
             clipped.scaled(
                 SCALED_X(displayRect.width()),
@@ -1478,11 +1634,12 @@ void MHIBitmap::Draw(int x, int y, QRect rect, bool tiled)
                 tiledImage.setPixel(i, j, m_image.pixel(i % m_image.width(), j % m_image.height()));
             }
         }
-        m_parent->DrawImage(rect.x(), rect.y(), rect, tiledImage);
+        m_parent->DrawImage(rect.x(), rect.y(), rect, tiledImage, true);
     }
     else
     {
-        m_parent->DrawImage(x, y, rect, m_image);
+        // NB THe BBC expects bitmaps to be scaled, not clipped
+        m_parent->DrawImage(x, y, rect, m_image, true);
     }
 }
 
diff --git a/mythtv/libs/libmythtv/mhi.h b/mythtv/libs/libmythtv/mhi.h
index 6fd0971..5e82a24 100644
--- a/mythtv/libs/libmythtv/mhi.h
+++ b/mythtv/libs/libmythtv/mhi.h
@@ -24,6 +24,7 @@ using namespace std;
 #include "../libmythfreemheg/freemheg.h"
 #include "interactivetv.h"
 #include "dsmcc.h"
+#include "mhegic.h"
 #include "mythcontext.h"
 #include "mythdbcon.h"
 #include "mythdeque.h"
@@ -100,7 +101,7 @@ class MHIContext : public MHContext
     virtual void DrawBackground(const QRegion &reg);
     virtual void DrawVideo(const QRect &videoRect, const QRect &displayRect);
 
-    void DrawImage(int x, int y, const QRect &rect, const QImage &image);
+    void DrawImage(int x, int y, const QRect &rect, const QImage &image, bool bScaled = false);
 
     virtual int GetChannelIndex(const QString &str);
     /// Get netId etc from the channel index.
@@ -108,14 +109,27 @@ class MHIContext : public MHContext
                                 int &transportId, int &serviceId);
     virtual bool TuneTo(int channel, int tuneinfo);
 
-    /// Begin playing audio from the specified stream
-    virtual bool BeginAudio(const QString &stream, int tag);
+    /// Begin playing the specified stream
+    virtual bool BeginStream(const QString &str, MHStream* notify);
+    virtual void EndStream();
+    // Called when the stream starts or stops
+    bool StreamStarted(bool bStarted = true);
+    /// Begin playing audio
+    virtual bool BeginAudio(int tag);
     /// Stop playing audio
-    virtual void StopAudio(void);
-    /// Begin displaying video from the specified stream
-    virtual bool BeginVideo(const QString &stream, int tag);
+    virtual void StopAudio();
+    /// Begin displaying video
+    virtual bool BeginVideo(int tag);
     /// Stop displaying video
-    virtual void StopVideo(void);
+    virtual void StopVideo();
+    // Get current stream position, -1 if unknown
+    virtual long GetStreamPos();
+    // Get current stream size, -1 if unknown
+    virtual long GetStreamMaxPos();
+    // Set current stream position
+    virtual long SetStreamPos(long);
+    // Play or pause a stream
+    virtual void StreamPlay(bool);
 
     // Get the context id strings.  The format of these strings is specified
     // by the UK MHEG profile.
@@ -124,6 +138,9 @@ class MHIContext : public MHContext
     virtual const char *GetDSMCCId(void)
         { return "DSMMYT001"; } // DSMCC version.
 
+    // InteractionChannel
+    virtual int GetICStatus(); // 0= Active, 1= Inactive, 2= Disabled
+
     // Operations used by the display classes
     // Add an item to the display vector
     void AddToDisplay(const QImage &image, int x, int y);
@@ -152,6 +169,9 @@ class MHIContext : public MHContext
     QMutex           m_dsmccLock;
     MythDeque<DSMCCPacket*> m_dsmccQueue;
 
+    MHInteractionChannel m_ic;  // Interaction channel
+    MHStream        *m_notify;
+
     QMutex           m_keyLock;
     MythDeque<int>   m_keyQueue;
     int              m_keyProfile;
diff --git a/mythtv/libs/libmythtv/netstream.cpp b/mythtv/libs/libmythtv/netstream.cpp
index 13cd357..24d4a9c 100644
--- a/mythtv/libs/libmythtv/netstream.cpp
+++ b/mythtv/libs/libmythtv/netstream.cpp
@@ -6,6 +6,7 @@
 // C/C++ lib
 #include <cstdlib>
 using std::getenv;
+#include <cstdio>
 
 // Qt
 #include <QNetworkAccessManager>
@@ -14,6 +15,8 @@ using std::getenv;
 #include <QNetworkProxy>
 #include <QNetworkDiskCache>
 #include <QSslConfiguration>
+#include <QSslError>
+#include <QSslSocket>
 #include <QUrl>
 #include <QThread>
 #include <QMutexLocker>
@@ -21,6 +24,8 @@ using std::getenv;
 #include <QCoreApplication>
 #include <QAtomicInt>
 #include <QMetaType> // qRegisterMetaType
+#include <QDesktopServices>
+#include <QScopedPointer>
 
 // Myth
 #include "mythverbose.h"
@@ -32,7 +37,7 @@ using std::getenv;
  * Constants
  */
 #define LOC "[netstream] "
-#define LOC_ERR LOC "ERROR: "
+#define LOC_ERR LOC "ERROR "
 
 
 /*
@@ -46,11 +51,13 @@ static QMutex s_mtx; // Guard local static data e.g. NAMThread singleton
  * Private types
  */
 // Custom event posted to NAMThread
-class NetStreamEvent : public QEvent
+class NetStreamRequest : public QEvent
 {
 public:
-    NetStreamEvent(int id, const QNetworkRequest &req) :
-        QEvent(QEvent::User),
+    static const QEvent::Type kType = QEvent::User;
+
+    NetStreamRequest(int id, const QNetworkRequest &req) :
+        QEvent(kType),
         m_id(id),
         m_req(req),
         m_bCancelled(false)
@@ -61,24 +68,44 @@ public:
     volatile bool m_bCancelled;
 };
 
+class NetStreamAbort : public QEvent
+{
+public:
+    static const QEvent::Type kType = static_cast< QEvent::Type >(QEvent::User + 1);
+
+    NetStreamAbort(int id, QNetworkReply *reply) :
+        QEvent(kType),
+        m_id(id),
+        m_reply(reply)
+    { }
+
+    const int m_id;
+    QNetworkReply * const m_reply;
+};
+
 
 /**
  * Network streaming request
  */
-NetStream::NetStream(const QUrl &url, QNetworkRequest::CacheLoadControl cache) :
+NetStream::NetStream(const QUrl &url, EMode mode /*= kPreferCache*/) :
     m_id(s_nRequest.fetchAndAddRelaxed(1)),
     m_state(kClosed),
-    m_event(0),
+    m_pending(0),
     m_reply(0),
-    m_nRedirections(0)
+    m_nRedirections(0),
+    m_size(-1),
+    m_pos(0)
 {
-    setObjectName("NetStream");
-    moveToThread(NAMThread::manager()->thread());
+    setObjectName("NetStream " + url.toString());
 
-    m_request.setAttribute(QNetworkRequest::CacheLoadControlAttribute, cache);
+    m_request.setAttribute(QNetworkRequest::CacheLoadControlAttribute,
+        mode == kAlwaysCache ? QNetworkRequest::AlwaysCache :
+        mode == kPreferCache ? QNetworkRequest::PreferCache :
+        mode == kNeverCache ? QNetworkRequest::AlwaysNetwork :
+            QNetworkRequest::PreferNetwork );
 
-    // Receive requestStarted signals from NAMThread when it processes a NetStreamEvent
-    connect(NAMThread::manager(), SIGNAL(requestStarted(int, QNetworkReply*)),
+    // Receive requestStarted signals from NAMThread when it processes a NetStreamRequest
+    connect(&NAMThread::manager(), SIGNAL(requestStarted(int, QNetworkReply*)),
         this, SLOT(slotRequestStarted(int, QNetworkReply*)), Qt::DirectConnection );
 
     QMutexLocker locker(&m_mutex);
@@ -96,11 +123,29 @@ NetStream::~NetStream()
 
     if (m_reply)
     {
+        m_reply->disconnect(this);
         m_reply->deleteLater();
-        m_reply = 0;
     }
 }
 
+static inline QString Source(const QNetworkRequest &request)
+{
+    switch (request.attribute(QNetworkRequest::CacheLoadControlAttribute).toInt())
+    {
+    case QNetworkRequest::AlwaysCache: return "cache";
+    case QNetworkRequest::PreferCache: return "cache-preferred";
+    case QNetworkRequest::PreferNetwork: return "net-preferred";
+    case QNetworkRequest::AlwaysNetwork: return "net";
+    }
+    return "unknown";
+}
+
+static inline QString Source(const QNetworkReply* reply)
+{
+    return reply->attribute(QNetworkRequest::SourceIsFromCacheAttribute).toBool() ?
+        "cache" : "host";
+}
+
 // Send request to the network manager
 // Caller must hold m_mutex
 bool NetStream::Request(const QUrl& url)
@@ -113,16 +158,20 @@ bool NetStream::Request(const QUrl& url)
         return false;
     }
 
-    if (m_event)
+    if (m_pending)
     {
-        VERBOSE(VB_IMPORTANT, LOC_ERR +
-            QString("(%1) Can't Request while pending").arg(m_id) );
-        return false;
+        // Cancel the pending request
+        m_pending->m_bCancelled = true;
+        m_pending = 0;
     }
 
     if (m_reply)
     {
-        m_reply->deleteLater();
+        // Abort the current request
+        // NB the abort method appears to only work if called from NAMThread
+        m_reply->disconnect(this);
+        NAMThread::PostEvent(new NetStreamAbort(m_id, m_reply));
+        // NAMthread will delete the reply
         m_reply = 0;
     }
 
@@ -132,6 +181,10 @@ bool NetStream::Request(const QUrl& url)
     if (!m_request.hasRawHeader(ua))
         m_request.setRawHeader(ua, "UK-MHEG/2 MYT001/001 MHGGNU/001");
 
+    if (m_pos > 0 || m_size >= 0)
+        m_request.setRawHeader("Range", QString("bytes=%1-").arg(m_pos).toAscii());
+
+#ifndef QT_NO_OPENSSL
 #if 1 // The BBC use a self certified cert so don't verify it
     if (m_request.url().scheme() == "https")
     {
@@ -141,11 +194,12 @@ bool NetStream::Request(const QUrl& url)
         m_request.setSslConfiguration(ssl);
     }
 #endif
+#endif
 
-    VERBOSE(VB_FILE, LOC + QString("(%1) Request %2")
-        .arg(m_id).arg(m_request.url().toString()) );
-    m_event = new NetStreamEvent(m_id, m_request);
-    QCoreApplication::postEvent(NAMThread::manager(), m_event);
+    VERBOSE(VB_FILE, LOC + QString("(%1) Requesting %2 from %3")
+        .arg(m_id).arg(m_request.url().toString()).arg(Source(m_request)) );
+    m_pending = new NetStreamRequest(m_id, m_request);
+    NAMThread::PostEvent(m_pending);
     return true;
 }
 
@@ -157,11 +211,11 @@ void NetStream::slotRequestStarted(int id, QNetworkReply *reply)
     if (m_id != id)
         return;
 
-    m_event = 0; // Event is no longer valid
+    m_pending = 0; // Event is no longer valid
 
     if (!m_reply)
     {
-        VERBOSE(VB_FILE|VB_EXTRA, LOC + QString("(%1) Started").arg(m_id) );
+        VERBOSE(VB_FILE|VB_EXTRA, LOC + QString("(%1) Started %2-").arg(m_id).arg(m_pos) );
 
         m_reply = reply;
         m_state = kStarted;
@@ -173,8 +227,10 @@ void NetStream::slotRequestStarted(int id, QNetworkReply *reply)
 
         // QNetworkReply signals
         connect(reply, SIGNAL(finished()), this, SLOT(slotFinished()), Qt::DirectConnection );
+#ifndef QT_NO_OPENSSL
         connect(reply, SIGNAL(sslErrors(const QList<QSslError> &)), this,
             SLOT(slotSslErrors(const QList<QSslError> &)), Qt::DirectConnection );
+#endif
         // QIODevice signals
         connect(reply, SIGNAL(readyRead()), this, SLOT(slotReadyRead()), Qt::DirectConnection );
     }
@@ -183,6 +239,54 @@ void NetStream::slotRequestStarted(int id, QNetworkReply *reply)
             QString("(%1) Started but m_reply not NULL").arg(m_id));
 }
 
+static qlonglong inline ContentLength(const QNetworkReply *reply)
+{
+    bool ok;
+    qlonglong len = reply->header(QNetworkRequest::ContentLengthHeader)
+        .toLongLong(&ok);
+    return ok ? len : -1;
+}
+
+static qlonglong inline ContentRange(const QNetworkReply *reply,
+    qlonglong &first, qlonglong &last)
+{
+    first = last = -1;
+
+    QByteArray range = reply->rawHeader("Content-Range");
+    if (range.isEmpty())
+        return -1;
+
+    // See RFC 2616 14.16: 'bytes begin-end/size'
+    qlonglong len;
+    if (3 != std::sscanf(range.constData(), " bytes %lld - %lld / %lld", &first, &last, &len))
+    {
+        VERBOSE(VB_IMPORTANT, LOC_ERR + QString("Invalid Content-Range:'%1'")
+            .arg(range.constData()) );
+        return -1;
+    }
+
+    return len;
+}
+
+static bool inline RequestRange(const QNetworkRequest &request,
+    qlonglong &first, qlonglong &last)
+{
+    first = last = -1;
+
+    QByteArray range = request.rawHeader("Range");
+    if (range.isEmpty())
+        return false;
+
+    if (1 > std::sscanf(range.constData(), " bytes %lld - %lld", &first, &last))
+    {
+        VERBOSE(VB_IMPORTANT, LOC_ERR + QString("Invalid Range:'%1'")
+            .arg(range.constData()) );
+        return false;
+    }
+
+    return true;
+}
+
 // signal from QNetworkReply
 void NetStream::slotReadyRead()
 {
@@ -190,7 +294,28 @@ void NetStream::slotReadyRead()
 
     if (m_reply)
     {
-        m_state = kReady;
+        VERBOSE(VB_FILE|VB_EXTRA, LOC + QString("(%1) Ready %2 bytes")
+            .arg(m_id).arg(m_reply->bytesAvailable()) );
+
+        if (m_size < 0)
+        {
+            qlonglong first, last, len = ContentRange(m_reply, first, last);
+            if (len >= 0)
+            {
+                m_size = len;
+                VERBOSE(VB_FILE, LOC + QString("(%1) range %2-%3/%4")
+                    .arg(m_id).arg(first).arg(last).arg(len) );
+            }
+            else
+            {
+                m_size = ContentLength(m_reply);
+                VERBOSE(VB_FILE, LOC + QString("(%1) content length %2")
+                    .arg(m_id).arg(m_size) );
+            }
+        }
+
+        if (m_state < kReady)
+            m_state = kReady;
 
         locker.unlock();
         emit ReadyRead(this);
@@ -222,13 +347,13 @@ void NetStream::slotFinished()
             }
             else if (m_nRedirections++ > 0)
             {
-                VERBOSE(VB_FILE, LOC + QString("(%1) Too many redirections")
+                VERBOSE(VB_IMPORTANT, LOC_ERR + QString("(%1) Too many redirections")
                     .arg(m_id));
                 m_state = kFinished;
             }
             else if ((url = m_request.url().resolved(url)) == m_request.url())
             {
-                VERBOSE(VB_FILE, LOC + QString("(%1) Redirection loop to %2")
+                VERBOSE(VB_IMPORTANT, LOC_ERR + QString("(%1) Redirection loop to %2")
                     .arg(m_id).arg(url.toString()) );
                 m_state = kFinished;
             }
@@ -240,15 +365,15 @@ void NetStream::slotFinished()
         }
         else
         {
-            VERBOSE(VB_FILE, LOC + QString("(%1) Error: %2")
+            VERBOSE(VB_IMPORTANT, LOC_ERR + QString("(%1): %2")
                 .arg(m_id).arg(m_reply->errorString()) );
             m_state = kFinished;
         }
 
         if (m_state == kFinished)
         {
-            VERBOSE(VB_FILE, LOC + QString("(%1) Finished %2 bytes")
-                .arg(m_id).arg(ContentLength()) );
+            VERBOSE(VB_FILE, LOC + QString("(%1) Finished %2/%3 bytes from %4")
+                .arg(m_id).arg(m_pos).arg(m_size).arg(Source(m_reply)) );
 
             locker.unlock();
             emit Finished(this);
@@ -262,6 +387,7 @@ void NetStream::slotFinished()
             .arg(m_id));
 }
 
+#ifndef QT_NO_OPENSSL
 // signal from QNetworkReply
 void NetStream::slotSslErrors(const QList<QSslError> &errors)
 {
@@ -296,6 +422,7 @@ void NetStream::slotSslErrors(const QList<QSslError> &errors)
         VERBOSE(VB_IMPORTANT, LOC_ERR +
             QString("(%1) SSL error but m_reply = NULL").arg(m_id) );
 }
+#endif
 
 
 /**
@@ -320,34 +447,33 @@ void NetStream::Abort()
 {
     QMutexLocker locker(&m_mutex);
 
-    if (m_event)
+    if (m_pending)
     {
         VERBOSE(VB_FILE, LOC + QString("(%1) Cancelled").arg(m_id) );
-        m_event->m_bCancelled = true;
-        m_event = 0;
+        m_pending->m_bCancelled = true;
+        m_pending = 0;
     }
 
     if (m_reply && m_reply->isRunning())
     {
         VERBOSE(VB_FILE, LOC + QString("(%1) Abort").arg(m_id) );
-        locker.unlock();
-        m_reply->abort();
-        locker.relock();
+        NAMThread::PostEvent(new NetStreamAbort(m_id, m_reply));
+        // NAMthread will delete the reply
+        m_reply = 0;
     }
 
     m_state = kFinished;
 }
 
-int NetStream::safe_read(void *data, unsigned sz, unsigned millisecs)
+int NetStream::safe_read(void *data, unsigned sz, unsigned millisecs /* = 0 */)
 {
     QTime t; t.start();
     QMutexLocker locker(&m_mutex);
 
-    if (!m_reply)
-        return -1;
+    if (m_size >= 0 && m_pos >= m_size)
+        return 0; // EOF
 
-    qint64 avail;
-    while ((avail = m_reply->bytesAvailable()) < sz && m_state < kFinished)
+    while (m_state < kFinished && (!m_reply || m_reply->bytesAvailable() < sz))
     {
         unsigned elapsed = t.elapsed();
         if (elapsed >= millisecs)
@@ -355,63 +481,55 @@ int NetStream::safe_read(void *data, unsigned sz, unsigned millisecs)
         m_ready.wait(&m_mutex, millisecs - elapsed);
     }
 
-    avail = m_reply->read(reinterpret_cast< char* >(data), sz);
+    if (!m_reply)
+        return -1;
+
+    qint64 avail = m_reply->read(reinterpret_cast< char* >(data), sz);
     if (avail <= 0)
         return m_state >= kFinished ? 0 : -1; // 0= EOF
 
-    VERBOSE(VB_FILE|VB_EXTRA, LOC + QString("(%1) safe_read => %2 bytes")
-        .arg(m_id).arg(avail) );
-
+    VERBOSE(VB_FILE|VB_EXTRA, LOC + QString("(%1) safe_read @ %4 => %2/%3, %5 mS")
+        .arg(m_id).arg(avail).arg(sz).arg(m_pos).arg(t.elapsed()) );
+    m_pos += avail;
     return (int)avail;
 }
 
 qlonglong NetStream::Seek(qlonglong pos)
 {
-    VERBOSE(VB_FILE, LOC + QString("(%1) Seek %2").arg(m_id).arg(pos) );
-
     QMutexLocker locker(&m_mutex);
 
-    if (!m_reply)
-        return -1;
+    if (pos == m_pos)
+        return pos;
 
-    if (!m_reply->seek(pos))
+    if (pos < 0 || (m_size >= 0 && pos > m_size))
     {
-        VERBOSE(VB_IMPORTANT, LOC_ERR + QString("(%1) Seek %2 failed")
-            .arg(m_id).arg(pos) );
+        VERBOSE(VB_IMPORTANT, LOC_ERR +
+            QString("(%1) Seek(%2) out of range [0..%3]")
+            .arg(m_id).arg(pos).arg(m_size) );
         return -1;
     }
 
-    return pos;
+    VERBOSE(VB_GENERAL, LOC + QString("(%1) Seek(%2) curr %3 end %4")
+        .arg(m_id).arg(pos).arg(m_pos).arg(m_size) );
+    m_pos = pos;
+    return Request(m_request.url()) ? m_pos : -1;
 }
 
 qlonglong NetStream::GetReadPosition() const
 {
     QMutexLocker locker(&m_mutex);
 
-    if (!m_reply)
-        return -1;
-
-    return m_reply->pos();
-}
-
-// Caller must hold m_mutex
-qlonglong NetStream::ContentLength() const
-{
-    if (!m_reply)
-        return -1;
-
-    bool ok;
-    qlonglong len = m_reply->header(QNetworkRequest::ContentLengthHeader)
-        .toLongLong(&ok);
-    return ok ? len : -1;
+    return m_pos;
 }
 
 qlonglong NetStream::GetSize() const
 {
     QMutexLocker locker(&m_mutex);
-    return ContentLength();
+
+    return m_size;
 }
 
+
 /**
  * Synchronous interface
  */
@@ -470,7 +588,13 @@ qlonglong NetStream::BytesAvailable() const
 QByteArray NetStream::ReadAll()
 {
     QMutexLocker locker(&m_mutex);
-    return m_reply ? m_reply->readAll() : QByteArray();
+
+    if (!m_reply)
+        return 0;
+
+    QByteArray data =  m_reply->readAll();
+    m_pos += data.size();
+    return data;
 }
 
 /**
@@ -500,63 +624,62 @@ bool NetStream::isFinished() const
 // static
 bool NetStream::isAvailable()
 {
-    return NAMThread::manager()->isAvailable();
+    return NAMThread::isAvailable();
 }
 
 // Time when URI was last written to cache or invalid if not cached.
 // static
 QDateTime NetStream::GetLastModified(const QString &url)
 {
-    return NAMThread::manager()->GetLastModified(url);
+    return NAMThread::GetLastModified(url);
 }
 
 
 /**
  * NetworkAccessManager event loop thread
  */
-NAMThread::NAMThread() : m_nam(0)
-{
-    setObjectName("NAMThread");
-    moveToThread(this); // Needed to create QNetworkAccessManager
-
-#if 1 // This ought to be done by the Qt lib but isn't in 4.7
-    //Q_DECLARE_METATYPE(QList<QSslError>)
-    qRegisterMetaType< QList<QSslError> >();
-#endif
-}
-
 //static
-NAMThread * NAMThread::manager()
+NAMThread & NAMThread::manager()
 {
     QMutexLocker locker(&s_mtx);
 
     // Singleton
     static NAMThread thread;
     thread.start();
-    return &thread;
+    return thread;
+}
+
+NAMThread::NAMThread() : m_bQuit(false), m_nam(0)
+{
+    setObjectName("NAMThread");
+
+#ifndef QT_NO_OPENSSL
+    // This ought to be done by the Qt lib but isn't in 4.7
+    //Q_DECLARE_METATYPE(QList<QSslError>)
+    qRegisterMetaType< QList<QSslError> >();
+#endif
 }
 
 // virtual
 NAMThread::~NAMThread()
 {
+    QMutexLocker locker(&m_mutex);
     delete m_nam;
 }
 
 // virtual
 void NAMThread::run()
 {
-    VERBOSE(VB_FILE, LOC "NAMThread starting");
+    VERBOSE(VB_MHEG, LOC "NAMThread starting");
 
-    m_nam = new QNetworkAccessManager(this);
+    m_nam = new QNetworkAccessManager();
     m_nam->setObjectName("NetStream NAM");
 
-    // Setup disk cache directory shared with MythDownloadManager
-    QNetworkDiskCache *cache = new QNetworkDiskCache(this);
-    cache->setCacheDirectory(GetConfDir() + "/Cache-" +
-                                   gCoreContext->GetAppName() + "-" +
-                                   gCoreContext->GetHostName());
-    cache->setMaximumCacheSize(500LL*1024LL*1024LL);
-    m_nam->setCache(cache);
+    // Setup cache
+    QScopedPointer<QNetworkDiskCache> cache(new QNetworkDiskCache());
+    cache->setCacheDirectory(
+        QDesktopServices::storageLocation(QDesktopServices::CacheLocation) );
+    m_nam->setCache(cache.take());
 
     // Setup a network proxy e.g. for TOR: socks://localhost:9050
     // TODO get this from mythdb
@@ -580,65 +703,118 @@ void NAMThread::run()
         }
         else
         {
-            VERBOSE(VB_IMPORTANT, LOC + QString("Unknown proxy type %1")
+            VERBOSE(VB_IMPORTANT, LOC_ERR + QString("Unknown proxy type %1")
                 .arg(url.scheme()) );
         }
     }
 
-    connect(QCoreApplication::instance(), SIGNAL(aboutToQuit()),
-        this, SLOT(quit()), Qt::DirectConnection );
+    // Quit when main app quits
+    connect(QCoreApplication::instance(), SIGNAL(aboutToQuit()), this, SLOT(quit()) );
 
     m_running.release();
-    exec();
+
+    while(!m_bQuit)
+    {
+        // Process NAM events
+        QCoreApplication::processEvents();
+
+        QMutexLocker locker(&m_mutex);
+        m_work.wait(&m_mutex, 100);
+        while (!m_workQ.isEmpty())
+        {
+            QScopedPointer< QEvent > ev(m_workQ.dequeue());
+            locker.unlock();
+            NewRequest(ev.data());
+        }
+    }
+
     m_running.acquire();
 
     delete m_nam;
     m_nam = 0;
 
-    VERBOSE(VB_FILE, LOC "NAMThread stopped");
+    VERBOSE(VB_MHEG, LOC "NAMThread stopped");
 }
 
-// Handle events from NetStream
-// virtual
-bool NAMThread::event(QEvent *event)
+// slot
+void NAMThread::quit()
+{
+    m_bQuit = true;
+    QThread::quit();
+}
+
+// static
+void NAMThread::PostEvent(QEvent *event)
+{
+    NAMThread &m = manager();
+    QMutexLocker locker(&m.m_mutex);
+    m.m_workQ.enqueue(event);
+}
+
+bool NAMThread::NewRequest(QEvent *event)
 {
     switch (event->type())
     {
-    case QEvent::User: return NewRequest(event);
+    case NetStreamRequest::kType:
+        return StartRequest(dynamic_cast< NetStreamRequest* >(event));
+    case NetStreamAbort::kType:
+        return AbortRequest(dynamic_cast< NetStreamAbort* >(event));
+    default:
+        break;
     }
     return false;
 }
 
-bool NAMThread::NewRequest(QEvent *event)
+bool NAMThread::StartRequest(NetStreamRequest *p)
 {
-    NetStreamEvent *p = dynamic_cast< NetStreamEvent* >(event);
     if (!p)
+    {
+        VERBOSE(VB_IMPORTANT, LOC_ERR "Invalid NetStreamRequest");
         return false;
+    }
 
     if (!p->m_bCancelled)
     {
-        VERBOSE(VB_FILE|VB_EXTRA, LOC "get " + p->m_req.url().toString() );
-        QMutexLocker locker(&m_mutex);
+        VERBOSE(VB_FILE|VB_EXTRA, LOC + QString("(%1) StartRequest").arg(p->m_id) );
         QNetworkReply *reply = m_nam->get(p->m_req);
-        locker.unlock();
         emit requestStarted(p->m_id, reply);
     }
+    else
+        VERBOSE(VB_FILE, LOC + QString("(%1) NetStreamRequest cancelled").arg(p->m_id) );
+    return true;
+}
+
+bool NAMThread::AbortRequest(NetStreamAbort *p)
+{
+    if (!p)
+    {
+        VERBOSE(VB_IMPORTANT, LOC_ERR "Invalid NetStreamAbort");
+        return false;
+    }
+
+    VERBOSE(VB_FILE, LOC + QString("(%1) AbortRequest").arg(p->m_id) );
+    p->m_reply->abort();
+    p->m_reply->disconnect();
+    delete p->m_reply;
     return true;
 }
 
+// static
 bool NAMThread::isAvailable()
 {
-    if (!m_running.tryAcquire(1, 3000))
+    NAMThread &m = manager();
+
+    if (!m.m_running.tryAcquire(1, 3000))
         return false;
 
-    m_running.release();
+    m.m_running.release();
 
-    QMutexLocker locker(&m_mutex);
+    QMutexLocker locker(&m.m_mutex);
 
-    if (!m_nam)
+    if (!m.m_nam)
         return false;
 
-    switch (m_nam->networkAccessible())
+    switch (m.m_nam->networkAccessible())
     {
     case QNetworkAccessManager::Accessible: return true;
     case QNetworkAccessManager::NotAccessible: return false;
@@ -651,12 +827,14 @@ bool NAMThread::isAvailable()
 // static
 QDateTime NAMThread::GetLastModified(const QString &url)
 {
-    QMutexLocker locker(&m_mutex);
+    NAMThread &m = manager();
+
+    QMutexLocker locker(&m.m_mutex);
 
-    if (!m_nam)
+    if (!m.m_nam)
         return QDateTime(); // Invalid
 
-    QAbstractNetworkCache *cache = m_nam->cache();
+    QAbstractNetworkCache *cache = m.m_nam->cache();
     if (!cache)
         return QDateTime(); // Invalid
 
diff --git a/mythtv/libs/libmythtv/netstream.h b/mythtv/libs/libmythtv/netstream.h
index 01608fa..b505f22 100644
--- a/mythtv/libs/libmythtv/netstream.h
+++ b/mythtv/libs/libmythtv/netstream.h
@@ -4,19 +4,24 @@
 #ifndef NETSTREAM_H
 #define NETSTREAM_H
 
+#include <QList>
+#include <QString>
+#include <QByteArray>
 #include <QObject>
 #include <QMutex>
 #include <QSemaphore>
 #include <QThread>
-#include <QByteArray>
 #include <QNetworkRequest>
 #include <QNetworkReply>
+#include <QSslError>
 #include <QWaitCondition>
+#include <QQueue>
 #include <QDateTime>
 
 class QUrl;
 class QNetworkAccessManager;
-class NetStreamEvent;
+class NetStreamRequest;
+class NetStreamAbort;
 
 
 /**
@@ -28,7 +33,8 @@ class NetStream : public QObject
     Q_DISABLE_COPY(NetStream)
 
 public:
-    NetStream(const QUrl &, QNetworkRequest::CacheLoadControl mode = QNetworkRequest::PreferCache);
+    enum EMode { kNeverCache, kPreferCache, kAlwaysCache };
+    NetStream(const QUrl &, EMode mode = kPreferCache);
     virtual ~NetStream();
 
 public:
@@ -36,7 +42,7 @@ public:
     static bool IsSupported(const QUrl &);
     bool IsOpen() const;
     void Abort();
-    int safe_read(void *data, unsigned size, unsigned millisecs);
+    int safe_read(void *data, unsigned size, unsigned millisecs = 0);
     qlonglong Seek(qlonglong);
     qlonglong GetReadPosition() const;
     qlonglong GetSize() const;
@@ -73,22 +79,25 @@ private slots:
     void slotRequestStarted(int, QNetworkReply *);
     // QNetworkReply signals
     void slotFinished();
+#ifndef QT_NO_OPENSSL
     void slotSslErrors(const QList<QSslError> & errors);
+#endif
     // QIODevice signals
     void slotReadyRead();
 
 private:
     bool Request(const QUrl &);
-    qlonglong ContentLength() const;
 
     const int m_id; // Unique request ID
 
     mutable QMutex m_mutex; // Protects r/w access to the following data
     QNetworkRequest m_request;
     enum { kClosed, kPending, kStarted, kReady, kFinished } m_state;
-    NetStreamEvent* m_event;
+    NetStreamRequest* m_pending;
     QNetworkReply* m_reply;
     int m_nRedirections;
+    qlonglong m_size;
+    qlonglong m_pos;
     QWaitCondition m_ready;
     QWaitCondition m_finished;
 };
@@ -106,27 +115,34 @@ class NAMThread : public QThread
     NAMThread();
 
 public:
-    static NAMThread * manager(); // Singleton
+    static NAMThread & manager(); // Singleton
     virtual ~NAMThread();
 
-    bool isAvailable();
-    QDateTime GetLastModified(const QString &url);
+    static void PostEvent(QEvent *);
+
+    static bool isAvailable(); // is network usable
+    static QDateTime GetLastModified(const QString &url);
 
 signals:
      void requestStarted(int, QNetworkReply *);
 
     // Implementation
-public:
-    virtual bool event(QEvent *); // QObject override
-
 protected:
     virtual void run(); // QThread override
     bool NewRequest(QEvent *);
+    bool StartRequest(NetStreamRequest *);
+    bool AbortRequest(NetStreamAbort *);
+
+private slots:
+    void quit();
 
 private:
+    volatile bool m_bQuit;
     QSemaphore m_running;
     mutable QMutex m_mutex; // Protects r/w access to the following data
     QNetworkAccessManager *m_nam;
+    QQueue< QEvent * > m_workQ;
+    QWaitCondition m_work;
 };
 
 #endif /* ndef NETSTREAM_H */
-- 
1.7.9.5

