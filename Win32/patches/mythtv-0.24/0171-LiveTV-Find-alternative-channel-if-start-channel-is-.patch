From b5a1673ce0078a0ab69a11a0c049969984fe1bf2 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Sat, 2 Mar 2013 11:39:54 +0000
Subject: [PATCH 171/285] LiveTV: Find alternative channel if start channel is
 not tuneable

When starting live TV the default starting channel may not be tuneable if
there are several recordings in progress.  In this case it is often
possible to find a channel that is on the same multiplex as a program
that is being recorded.

This patch searches for the next channel that is tuneable from the
same source ID as the default starting channel.

This fix also overcomes a problem after a re-tune where the default
starting channel is no longer available.

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythtv/libs/libmythtv/tv_play.cpp |   56 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 55 insertions(+), 1 deletion(-)

diff --git a/mythtv/libs/libmythtv/tv_play.cpp b/mythtv/libs/libmythtv/tv_play.cpp
index dfcde5c..d831a39 100644
--- a/mythtv/libs/libmythtv/tv_play.cpp
+++ b/mythtv/libs/libmythtv/tv_play.cpp
@@ -1889,6 +1889,60 @@ static QString tv_i18n(const QString &msg)
     return (msg_arr == msg_i18n_arr) ? msg_i18n : msg;
 }
 
+static uint NextTunableChannel(uint chanid)
+{
+    VERBOSE(VB_CHANNEL, LOC + QString("NextTunableChannel(%1)").arg(chanid));
+
+    uint sourceid = ChannelUtil::GetSourceIDForChannel(chanid);
+
+    vector<uint> connected = RemoteRequestFreeRecorderList();
+    vector<uint> interesting = CardUtil::GetCardIDs(sourceid);
+
+    DBChanList chanlist = ChannelUtil::GetChannels(sourceid, true/*vis*/);
+    ChannelUtil::SortChannels(chanlist, "channum", true/*elim_dups*/);
+
+    vector<uint> cardids;
+    for (uint i = 0; i < connected.size(); i++)
+    {
+        for (uint j = 0; j < interesting.size(); j++)
+        {
+            if (connected[i] == interesting[j])
+            {
+                cardids.push_back(interesting[j]);
+                break;
+            }
+        }
+    }
+
+    for (uint i = 0; i < cardids.size(); i++)
+    {
+        vector<uint> x;
+        vector<InputInfo> inputs = RemoteRequestFreeInputList(cardids[i], x);
+
+        for (uint j = 0; j < inputs.size(); j++)
+        {
+            VERBOSE(VB_CHANNEL, LOC + QString("NextTunableChannel %1, %2")
+                .arg(CardUtil::GetVideoDevice(cardids[i]))
+                .arg(CardUtil::GetDisplayName(inputs[j].inputid)));
+
+            if (inputs[j].sourceid != sourceid)
+                continue;
+
+            uint id = ChannelUtil::GetNextChannel(chanlist, chanid,
+                        inputs[j].mplexid, CHANNEL_DIRECTION_UP);
+            if (id)
+            {
+                VERBOSE(VB_CHANNEL, LOC + QString("NextTunableChannel(%1) => %2")
+                    .arg(chanid).arg(id));
+                return id;
+            }
+        }
+    }
+
+    VERBOSE(VB_CHANNEL, LOC + QString("NextTunableChannel(%1) => none").arg(chanid));
+    return 0;
+}
+
 /** \fn TV::HandleStateChange(PlayerContext*,PlayerContext*)
  *  \brief Changes the state to the state on the front of the
  *         state change queue.
@@ -1955,7 +2009,7 @@ void TV::HandleStateChange(PlayerContext *mctx, PlayerContext *ctx)
         uint chanid = gCoreContext->GetNumSetting("DefaultChanid", 0);
 
         if (chanid && !IsTunable(ctx, chanid))
-            chanid = 0;
+            chanid = NextTunableChannel(chanid);
 
         QString channum = "";
 
-- 
1.7.9.5

