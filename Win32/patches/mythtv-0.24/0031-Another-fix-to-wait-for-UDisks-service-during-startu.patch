From 87fd418255b3737dad6747768a5b381751e13660 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Tue, 19 Apr 2011 10:12:45 +0200
Subject: [PATCH 031/285] Another fix to wait for UDisks service during
 startup

This version destroys and re-creates the QDBusInterface connection to
UDisks until timed out or isValid.

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythtv/libs/libmyth/mediamonitor-unix.cpp |   98 ++++++++++++++++-------------
 1 file changed, 53 insertions(+), 45 deletions(-)

diff --git a/mythtv/libs/libmyth/mediamonitor-unix.cpp b/mythtv/libs/libmyth/mediamonitor-unix.cpp
index 6191862..da1d84b 100644
--- a/mythtv/libs/libmyth/mediamonitor-unix.cpp
+++ b/mythtv/libs/libmyth/mediamonitor-unix.cpp
@@ -182,60 +182,68 @@ static QVariant DeviceProperty(const QDBusObjectPath& o, const char kszProperty[
 bool MediaMonitorUnix::CheckMountable(void)
 {
 #if CONFIG_QTDBUS
-    // Listen on DBus for UDisk add/remove device messages
-    QDBusConnection::systemBus().connect(
-        UDISKS_SVC, UDISKS_PATH, UDISKS_IFACE, UDISKS_DEVADD, UDISKS_DEVSIG,
-        this, SLOT(deviceAdded(QDBusObjectPath)) );
-    QDBusConnection::systemBus().connect(
-        UDISKS_SVC, UDISKS_PATH, UDISKS_IFACE, UDISKS_DEVRMV, UDISKS_DEVSIG,
-        this, SLOT(deviceRemoved(QDBusObjectPath)) );
-
-    // Connect to UDisks
-    QDBusInterface iface(UDISKS_SVC, UDISKS_PATH, UDISKS_IFACE,
-        QDBusConnection::systemBus() );
-    for (int i = 0; !iface.isValid(); ++i, usleep(500000))
+    for (int i = 0; i < 10; ++i, usleep(500000))
     {
-        VERBOSE(VB_IMPORTANT, LOC + ":CheckMountable: DBus interface error: " +
-            iface.lastError().message() );
-        if (i >= 10)
-            return false;
-    }
+        // Connect to UDisks.  This can sometimes fail if mythfrontend
+        // is started during system init
+        QDBusInterface iface(UDISKS_SVC, UDISKS_PATH, UDISKS_IFACE,
+            QDBusConnection::systemBus() );
+        if (!iface.isValid())
+        {
+            VERBOSE(VB_IMPORTANT, LOC + ":CheckMountable: DBus interface error: " +
+                iface.lastError().message() );
+            continue;
+        }
 
-    // Enumerate devices
-    typedef QList<QDBusObjectPath> QDBusObjectPathList;
-    QDBusReply<QDBusObjectPathList> reply = iface.call("EnumerateDevices");
-    if (!reply.isValid())
-    {
-        VERBOSE(VB_IMPORTANT, LOC + ":CheckMountable DBus EnumerateDevices error: " +
-            reply.error().message() );
-        return false;
-    }
+        // Enumerate devices
+        typedef QList<QDBusObjectPath> QDBusObjectPathList;
+        QDBusReply<QDBusObjectPathList> reply = iface.call("EnumerateDevices");
+        if (!reply.isValid())
+        {
+            VERBOSE(VB_IMPORTANT, LOC + ":CheckMountable DBus EnumerateDevices error: " +
+                reply.error().message() );
+            continue;
+        }
 
-    // Parse the returned device array
-    const QDBusObjectPathList& list(reply.value());
-    for (QDBusObjectPathList::const_iterator it = list.begin();
-        it != list.end(); ++it)
-    {
-        if (!DeviceProperty(*it, "DeviceIsSystemInternal").toBool() &&
-            !DeviceProperty(*it, "DeviceIsPartitionTable").toBool() )
+        // Listen on DBus for UDisk add/remove device messages
+        (void)QDBusConnection::systemBus().connect(
+            UDISKS_SVC, UDISKS_PATH, UDISKS_IFACE, UDISKS_DEVADD, UDISKS_DEVSIG,
+            this, SLOT(deviceAdded(QDBusObjectPath)) );
+        (void)QDBusConnection::systemBus().connect(
+            UDISKS_SVC, UDISKS_PATH, UDISKS_IFACE, UDISKS_DEVRMV, UDISKS_DEVSIG,
+            this, SLOT(deviceRemoved(QDBusObjectPath)) );
+
+        // Parse the returned device array
+        const QDBusObjectPathList& list(reply.value());
+        for (QDBusObjectPathList::const_iterator it = list.begin();
+            it != list.end(); ++it)
         {
-            QString dev = DeviceProperty(*it, "DeviceFile").toString();
+            if (!DeviceProperty(*it, "DeviceIsSystemInternal").toBool() &&
+                !DeviceProperty(*it, "DeviceIsPartitionTable").toBool() )
+            {
+                QString dev = DeviceProperty(*it, "DeviceFile").toString();
 
-            // ignore floppies, too slow
-            if (dev.startsWith("/dev/fd"))
-                continue;
+                // ignore floppies, too slow
+                if (dev.startsWith("/dev/fd"))
+                    continue;
 
-            MythMediaDevice* pDevice;
-            if (DeviceProperty(*it, "DeviceIsRemovable").toBool())
-                pDevice = MythCDROM::get(this, dev.toAscii(), false, m_AllowEject);
-            else
-                pDevice = MythHDD::Get(this, dev.toAscii(), false, false);
+                MythMediaDevice* pDevice;
+                if (DeviceProperty(*it, "DeviceIsRemovable").toBool())
+                    pDevice = MythCDROM::get(this, dev.toAscii(), false, m_AllowEject);
+                else
+                    pDevice = MythHDD::Get(this, dev.toAscii(), false, false);
 
-            if (pDevice && !AddDevice(pDevice))
-                pDevice->deleteLater();
+                if (pDevice && !AddDevice(pDevice))
+                    pDevice->deleteLater();
+            }
         }
+
+        // Success
+        return true;
     }
-    return true;
+
+    // Timed out
+    return false;
 
 #elif defined linux
     // NB needs script in /etc/udev/rules.d
-- 
1.7.9.5

