From 400cb6c6a1c7315c72be4c233fa1691f6cdeb5c8 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Tue, 21 May 2013 20:27:09 +0100
Subject: [PATCH 193/285] ffmpeg: Reduce livetv startup delay

av_find_stream_info parses the input stream and calls has_codec_parameters()
for each discovered stream.  However, some MP3 audio streams (tag 0)
have incomplete information, missing sample rate and channels.  This
causes av_find_stream_info to run until the default timeout of 5 seconds.

This change reduces the time spent in av_find_stream_info to around 1 second.

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythtv/external/FFmpeg/libavformat/utils.c |   28 +++++++++++++++++-----------
 1 file changed, 17 insertions(+), 11 deletions(-)

diff --git a/mythtv/external/FFmpeg/libavformat/utils.c b/mythtv/external/FFmpeg/libavformat/utils.c
index ec8c4d1..aaa6ef7 100644
--- a/mythtv/external/FFmpeg/libavformat/utils.c
+++ b/mythtv/external/FFmpeg/libavformat/utils.c
@@ -2297,16 +2297,22 @@ int av_find_stream_info(AVFormatContext *ic)
         /* check if one codec still needs to be handled */
         for(i=0;i<ic->nb_streams;i++) {
             st = ic->streams[i];
-            if (!has_codec_parameters(st->codec))
-                break;
+            if (!has_codec_parameters(st->codec)) {
+                if (st->codec->codec_type != CODEC_TYPE_AUDIO || !hasaudio)
+                    break;
+            }
             /* variable fps and no guess at the real fps */
             if(   tb_unreliable(st->codec) && !(st->r_frame_rate.num && st->avg_frame_rate.num)
                && duration_count[i]<20 && st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
                 break;
             if(st->parser && st->parser->parser->split && !st->codec->extradata)
                 break;
-            if(st->first_dts == AV_NOPTS_VALUE && st->codec->codec_id != CODEC_ID_DSMCC_B)
-                break;
+            if(st->first_dts == AV_NOPTS_VALUE && st->codec->codec_id != CODEC_ID_DSMCC_B) {
+                if (st->codec->codec_type == CODEC_TYPE_AUDIO && !hasaudio)
+                    break;
+                if (st->codec->codec_type == CODEC_TYPE_VIDEO && !hasvideo)
+                    break;
+            }
             if (st->codec->codec_type == CODEC_TYPE_VIDEO)
                 hasvideo = 1;
             else if (st->codec->codec_type == CODEC_TYPE_AUDIO)
@@ -2328,7 +2334,7 @@ int av_find_stream_info(AVFormatContext *ic)
         /* we did not get all the codec info, but we read too much data */
         if (read_size >= ic->probesize) {
             ret = count;
-            av_log(ic, AV_LOG_DEBUG, "Probe buffer size limit %d reached\n", ic->probesize);
+            av_log(ic, AV_LOG_WARNING, "Probe buffer size limit %d reached\n", ic->probesize);
             break;
         }
 
@@ -2342,13 +2348,8 @@ int av_find_stream_info(AVFormatContext *ic)
             ret = -1; /* we could not have all the codec parameters before EOF */
             for(i=0;i<ic->nb_streams;i++) {
                 st = ic->streams[i];
-                if (!has_codec_parameters(st->codec)){
-                    char buf[256];
-                    avcodec_string(buf, sizeof(buf), st->codec, 0);
-                    av_log(ic, AV_LOG_WARNING, "Could not find codec parameters (%s)\n", buf);
-                } else {
+                if (has_codec_parameters(st->codec))
                     ret = 0;
-                }
             }
             break;
         }
@@ -2420,6 +2421,11 @@ int av_find_stream_info(AVFormatContext *ic)
     // close codecs which were opened in try_decode_frame()
     for(i=0;i<ic->nb_streams;i++) {
         st = ic->streams[i];
+        if (!has_codec_parameters(st->codec)){
+            char buf[256];
+            avcodec_string(buf, sizeof(buf), st->codec, 0);
+            av_log(ic, AV_LOG_WARNING, "Could not find codec parameters (%s)\n", buf);
+        }
         if(st->codec->codec)
             avcodec_close(st->codec);
     }
-- 
1.7.9.5

