From 1fdf50100466e79ca1216beef65e63ae9bc38ef3 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Mon, 25 Jul 2011 19:34:10 +0200
Subject: [PATCH 062/285] freemheg: Correct font x-resolution

The x-resolution used for size calculations of blocks of text is incorrect.
This most noticeably causes tables to be incorrectl;y formatted.

This patch also corrects a bug in the text block size calculation.

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythtv/libs/libmythfreemheg/Text.cpp |    8 ++--
 mythtv/libs/libmythtv/mhi.cpp        |   67 +++++++++++++++++++++++-----------
 2 files changed, 51 insertions(+), 24 deletions(-)

diff --git a/mythtv/libs/libmythfreemheg/Text.cpp b/mythtv/libs/libmythfreemheg/Text.cpp
index fbce463..3bd0890 100644
--- a/mythtv/libs/libmythfreemheg/Text.cpp
+++ b/mythtv/libs/libmythfreemheg/Text.cpp
@@ -318,8 +318,10 @@ MHTextLine::~MHTextLine()
     for (int i = 0; i < m_Items.Size(); i++) delete(m_Items.GetAt(i));
 }
 
-// Tabs are set every 56 points (45 pixels).
-#define TABSTOP 45
+// Tabs are set every 56 pixels
+// = (FONT_WIDTHRES * 56)/ 72 points - see libmythtv/mhi.cpp
+// = (54 * 56)/72 = 42
+#define TABSTOP 42 // pts
 static inline int Tabs(int nXpos, int nTabCount)
 {
     int nNextTab = nXpos;
@@ -494,7 +496,7 @@ void MHText::Redraw()
                 rect = m_pDisplay->GetBounds(pItem->m_Unicode, pItem->m_nUnicode);
             }
 
-            pItem->m_Width = rect.width();
+            pItem->m_Width = rect.width(); // Points
             pLine->m_nLineWidth += rect.width();
             if (rect.height() > pLine->m_nLineHeight) pLine->m_nLineHeight = rect.height();
             if (rect.bottom() > pLine->m_nDescent) pLine->m_nDescent = rect.bottom();
diff --git a/mythtv/libs/libmythtv/mhi.cpp b/mythtv/libs/libmythtv/mhi.cpp
index c6e55cd..55d7158 100644
--- a/mythtv/libs/libmythtv/mhi.cpp
+++ b/mythtv/libs/libmythtv/mhi.cpp
@@ -19,9 +19,10 @@
 static bool       ft_loaded = false;
 static FT_Library ft_library;
 
-#define FONT_WIDTHRES   48
-#define FONT_HEIGHTRES  72
-#define FONT_TO_USE "FreeSans.ttf"
+#define FONT_WIDTHRES   54
+#define FONT_HEIGHTRES  72 // 1 pixel per point
+#define FONT_TO_USE "FreeSans.ttf" // Tiresias Screenfont.ttf is mandated
+
 
 #define SCALED_X(arg1) (int)(((float)arg1 * m_xScale) + 0.5f)
 #define SCALED_Y(arg1) (int)(((float)arg1 * m_yScale) + 0.5f)
@@ -109,7 +110,7 @@ bool MHIContext::LoadFont(QString name)
     if (!errorD)
         return true;
 
-    VERBOSE(VB_IMPORTANT, QString("[mhi] Unable to find font: %1").arg(name));
+    VERBOSE(VB_IMPORTANT, QString("[mhi] ERROR Unable to find font: %1").arg(name));
     return false;
 }
 
@@ -1105,6 +1106,18 @@ void MHIText::SetFont(int size, bool isBold, bool isItalic)
     // Bold and Italic are currently ignored.
 }
 
+// FT sizes are in 26.6 fixed point form
+const int kShift = 6;
+static inline FT_F26Dot6 Point2FT(int pt)
+{
+    return pt << kShift;
+}
+
+static inline int FT2Point(FT_F26Dot6 fp)
+{
+    return (fp + (1<<(kShift-1))) >> kShift;
+}
+
 // Return the bounding rectangle for a piece of text drawn in the
 // current font. If maxSize is non-negative it sets strLen to the
 // number of characters that will fit in the space and returns the
@@ -1118,24 +1131,31 @@ QRect MHIText::GetBounds(const QString &str, int &strLen, int maxSize)
         return QRect(0,0,0,0);
 
     FT_Face face = m_parent->GetFontFace();
-    FT_Error error = FT_Set_Char_Size(face, 0, m_fontsize*64,
+    FT_Error error = FT_Set_Char_Size(face, 0, Point2FT(m_fontsize),
                                       FONT_WIDTHRES, FONT_HEIGHTRES);
     if (error)
         return QRect(0,0,0,0);
 
-    FT_GlyphSlot slot = face->glyph; /* a small shortcut */
-
     int maxAscent = 0, maxDescent = 0, width = 0;
     FT_Bool useKerning = FT_HAS_KERNING(face);
     FT_UInt previous = 0;
 
     for (int n = 0; n < strLen; n++)
     {
-        QChar ch = str[n];
+        QChar ch = str.at(n);
         FT_UInt glyphIndex = FT_Get_Char_Index(face, ch.unicode());
+
+        if (glyphIndex == 0)
+        {
+            VERBOSE(VB_MHEG, QString("[mhi] Unknown glyph 0x%1")
+                .arg(ch.unicode(),0,16));
+            previous = 0;
+            continue;
+        }
+
         int kerning = 0;
 
-        if (useKerning && previous != 0 && glyphIndex != 0)
+        if (useKerning && previous != 0)
         {
             FT_Vector delta;
             FT_Get_Kerning(face, previous, glyphIndex,
@@ -1148,9 +1168,12 @@ QRect MHIText::GetBounds(const QString &str, int &strLen, int maxSize)
         if (error)
             continue; // ignore errors.
 
+        FT_GlyphSlot slot = face->glyph; /* a small shortcut */
+        FT_Pos advance = slot->metrics.horiAdvance + kerning;
+
         if (maxSize >= 0)
         {
-            if ((width + slot->advance.x + kerning + (1<<6)-1) >> 6 > maxSize)
+            if (FT2Point(width + advance) > maxSize)
             {
                 // There isn't enough space for this character.
                 strLen = n;
@@ -1166,15 +1189,11 @@ QRect MHIText::GetBounds(const QString &str, int &strLen, int maxSize)
         if (descent > maxDescent)
             maxDescent = descent;
 
-        width += slot->advance.x + kerning;
+        width += advance;
         previous = glyphIndex;
     }
 
-    maxAscent = (maxAscent + (1<<6)-1) >> 6;
-    maxDescent = (maxDescent + (1<<6)-1) >> 6;
-
-    return QRect(0, -maxAscent,
-                 (width+(1<<6)-1) >> 6, maxAscent + maxDescent);
+    return QRect(0, -FT2Point(maxAscent), FT2Point(width), FT2Point(maxAscent + maxDescent));
 }
 
 // Reset the image and fill it with transparent ink.
@@ -1201,13 +1220,12 @@ void MHIText::AddText(int x, int y, const QString &str, MHRgba colour)
 {
     if (!m_parent->IsFaceLoaded()) return;
     FT_Face face = m_parent->GetFontFace();
-    FT_GlyphSlot slot = face->glyph;
-    FT_Error error = FT_Set_Char_Size(face, 0, m_fontsize*64,
+    FT_Error error = FT_Set_Char_Size(face, 0, Point2FT(m_fontsize),
                                       FONT_WIDTHRES, FONT_HEIGHTRES);
 
     // X positions are computed to 64ths and rounded.
     // Y positions are in pixels
-    int posX = x << 6;
+    int posX = Point2FT(x);
     int pixelY = y;
     FT_Bool useKerning = FT_HAS_KERNING(face);
     FT_UInt previous = 0;
@@ -1218,7 +1236,13 @@ void MHIText::AddText(int x, int y, const QString &str, MHRgba colour)
         // Load the glyph.
         QChar ch = str[n];
         FT_UInt glyphIndex = FT_Get_Char_Index(face, ch.unicode());
-        if (useKerning && previous != 0 && glyphIndex != 0)
+        if (glyphIndex == 0)
+        {
+            previous = 0;
+            continue;
+        }
+
+        if (useKerning && previous != 0)
         {
             FT_Vector delta;
             FT_Get_Kerning(face, previous, glyphIndex,
@@ -1230,6 +1254,7 @@ void MHIText::AddText(int x, int y, const QString &str, MHRgba colour)
         if (error)
             continue; // ignore errors
 
+        FT_GlyphSlot slot = face->glyph;
         if (slot->format != FT_GLYPH_FORMAT_BITMAP)
             continue; // Problem
 
@@ -1238,7 +1263,7 @@ void MHIText::AddText(int x, int y, const QString &str, MHRgba colour)
 
         unsigned char *source = slot->bitmap.buffer;
         // Get the origin for the bitmap
-        int baseX = ((posX + (1 << 5)) >> 6) + slot->bitmap_left;
+        int baseX = FT2Point(posX) + slot->bitmap_left;
         int baseY = pixelY - slot->bitmap_top;
         // Copy the bitmap into the image.
         for (int i = 0; i < slot->bitmap.rows; i++)
-- 
1.7.9.5

