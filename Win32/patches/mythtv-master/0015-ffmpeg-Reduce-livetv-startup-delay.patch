From beb0c283aab6590c37aace93f4aa42501e0b4b8c Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Tue, 21 May 2013 20:27:09 +0100
Subject: [PATCH 015/202] ffmpeg: Reduce livetv startup delay

av_find_stream_info parses the input stream and calls has_codec_parameters()
for each discovered stream.  However, some MP3 audio streams (tag 0)
have incomplete information, missing sample rate and channels.  This
causes av_find_stream_info to run until the default timeout of 5 seconds.

This change reduces the time spent in av_find_stream_info to around 1 second.

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythtv/external/FFmpeg/libavformat/utils.c |   16 +++++++++++-----
 1 file changed, 11 insertions(+), 5 deletions(-)

diff --git a/mythtv/external/FFmpeg/libavformat/utils.c b/mythtv/external/FFmpeg/libavformat/utils.c
index ce050f5..afc678b 100644
--- a/mythtv/external/FFmpeg/libavformat/utils.c
+++ b/mythtv/external/FFmpeg/libavformat/utils.c
@@ -2867,8 +2867,10 @@ int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
             int fps_analyze_framecount = 20;
 
             st = ic->streams[i];
-            if (!has_codec_parameters(st, NULL))
-                break;
+            if (!has_codec_parameters(st, NULL)) {
+                if (st->codec->codec_type != AVMEDIA_TYPE_AUDIO || !hasaudio)
+                    break;
+            }
             /* if the timebase is coarse (like the usual millisecond precision
                of mkv), we need to analyze more frames to reliably arrive at
                the correct fps */
@@ -2885,8 +2887,12 @@ int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
                 break;
             if(st->parser && st->parser->parser->split && !st->codec->extradata)
                 break;
-            if(st->first_dts == AV_NOPTS_VALUE && st->codec->codec_id != AV_CODEC_ID_DSMCC_B)
-                break;
+            if(st->first_dts == AV_NOPTS_VALUE && st->codec->codec_id != AV_CODEC_ID_DSMCC_B) {
+                if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO && !hasaudio)
+                    break;
+                if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && !hasvideo)
+                    break;
+            }
             if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
                 hasvideo = 1;
             else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO)
@@ -2916,7 +2922,7 @@ int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
         /* we did not get all the codec info, but we read too much data */
         if (read_size >= ic->probesize) {
             ret = count;
-            av_log(ic, AV_LOG_DEBUG, "Probe buffer size limit of %d bytes reached\n", ic->probesize);
+            av_log(ic, AV_LOG_WARNING, "Probe buffer size limit of %d bytes reached\n", ic->probesize);
             for (i = 0; i < ic->nb_streams; i++)
                 if (!ic->streams[i]->r_frame_rate.num &&
                     ic->streams[i]->info->duration_count <= 1)
-- 
1.7.9.5

