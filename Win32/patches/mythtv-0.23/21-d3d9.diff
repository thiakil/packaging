diff --git a/mythtv/libs/libmythtv/videoout_d3d.cpp b/mythtv/libs/libmythtv/videoout_d3d.cpp
index d55f183..10fe175 100644
--- mythtv/libs/libmythtv/videoout_d3d.cpp
+++ mythtv/libs/libmythtv/videoout_d3d.cpp
@@ -82,8 +82,8 @@ D3D9Context::D3D9Context(void)
   : m_priv(new D3D9PrivateContext()),
     m_d3d(NULL), m_d3dDevice(NULL),
     m_adaptor_fmt(D3DFMT_UNKNOWN),
-    m_videosurface_fmt((D3DFORMAT)MAKEFOURCC('Y','V','1','2')),
-    m_alphasurface_fmt(D3DFMT_A8R8G8B8), m_alphatexture_fmt(D3DFMT_A8R8G8B8),
+    m_videosurface_fmt(D3DFMT_UNKNOWN),
+    m_alphasurface_fmt(D3DFMT_UNKNOWN), m_alphatexture_fmt(D3DFMT_A8R8G8B8),
     m_lock(QMutex::Recursive)
 {
 }
@@ -123,6 +123,7 @@ bool D3D9Context::FormatSupported(D3DFORMAT surface, D3DFORMAT adaptor)
                                           adaptor, 0, D3DRTYPE_SURFACE, surface);
     if (SUCCEEDED(hr))
     {
+        // NB CheckDeviceFormatConversion is not fuly implemented in Wine as of 1.3.6
         hr = m_d3d->CheckDeviceFormatConversion(D3DADAPTER_DEFAULT,
                                                 D3DDEVTYPE_HAL, surface, adaptor);
         if (SUCCEEDED(hr))
@@ -133,7 +134,6 @@ bool D3D9Context::FormatSupported(D3DFORMAT surface, D3DFORMAT adaptor)
 
 static const QString toString(D3DFORMAT fmt)
 {
-    QString res = "Unknown";
     switch (fmt)
     {
         case D3DFMT_A8:
@@ -143,9 +143,8 @@ static const QString toString(D3DFORMAT fmt)
         case D3DFMT_X8R8G8B8:
             return "X8R8G8B8";
         default:
-            return res;
+            return QString().setNum((ulong)fmt,16);
     }
-    return res;
 }
 
 bool D3D9Context::Create(QSize size, HWND window)
@@ -155,7 +154,6 @@ bool D3D9Context::Create(QSize size, HWND window)
     typedef LPDIRECT3D9 (WINAPI *LPFND3DC)(UINT SDKVersion);
     static  HINSTANCE hD3DLib            = NULL;
     static  LPFND3DC  OurDirect3DCreate9 = NULL;
-    D3DCAPS9 d3dCaps;
 
     if (!hD3DLib)
     {
@@ -183,12 +181,12 @@ bool D3D9Context::Create(QSize size, HWND window)
         return false;
     }
 
+    D3DCAPS9 d3dCaps;
     ZeroMemory(&d3dCaps, sizeof(d3dCaps));
     if (D3D_OK != m_d3d->GetDeviceCaps(
             D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, &d3dCaps))
     {
         VERBOSE(VB_IMPORTANT, D3DERR + "Could not read adapter capabilities.");
-        return false;
     }
 
     D3DDISPLAYMODE d3ddm;
@@ -198,27 +196,63 @@ bool D3D9Context::Create(QSize size, HWND window)
         return false;
     }
 
-    // TODO - check adaptor format is reasonable...
     m_adaptor_fmt = d3ddm.Format;
-    bool default_ok = FormatSupported(m_videosurface_fmt, m_adaptor_fmt);
-    if (!default_ok)
-        m_videosurface_fmt = m_adaptor_fmt;
-
     VERBOSE(VB_PLAYBACK, D3DLOC +
-        QString("Default Adaptor Format %1 - Hardware YV12 to RGB %2 ")
-            .arg(toString(m_adaptor_fmt))
-            .arg(default_ok ? "supported" : "unsupported"));
+        QString("Default Adaptor Format %1.").arg(toString(m_adaptor_fmt)));
 
     if (FormatSupported(D3DFMT_A8, m_adaptor_fmt))
         m_alphasurface_fmt = D3DFMT_A8;
     VERBOSE(VB_PLAYBACK, D3DLOC + QString("Using %1 alpha surface format.")
                                           .arg(toString(m_alphasurface_fmt)));
-
-    // TODO - try alternative adaptor formats if necessary
+    // Find the best h/w supported video surface format
+    static const D3DFORMAT vfmt[] = {
+        (D3DFORMAT)MAKEFOURCC('Y','V','1','2'),
+        D3DFMT_UYVY,
+        D3DFMT_YUY2,
+        (D3DFORMAT)MAKEFOURCC('I','Y','U','V'),
+        (D3DFORMAT)MAKEFOURCC('I','4','2','0'),
+        (D3DFORMAT)MAKEFOURCC('Y','V','1','6'),
+        D3DFMT_A8R8G8B8,
+        D3DFMT_X8R8G8B8,
+        D3DFMT_A8B8G8R8,
+        D3DFMT_X8B8G8R8
+    };
+    for (unsigned i = 0; i < sizeof vfmt / sizeof vfmt[0]; ++i) {
+        if (SUCCEEDED(m_d3d->CheckDeviceType(D3DADAPTER_DEFAULT,
+                D3DDEVTYPE_HAL, m_adaptor_fmt, vfmt[i], TRUE))) {
+            m_videosurface_fmt = vfmt[i];
+            break;
+        }
+    }
+    if (D3DFMT_UNKNOWN != m_videosurface_fmt)
+        VERBOSE(VB_GENERAL, D3DLOC +
+            QString("Best Video Surface Format %1.").arg(toString(m_videosurface_fmt)));
+     else
+        VERBOSE(VB_IMPORTANT, D3DERR + "Failed to agree video surface format");
+
+    // Find the best backing surface format
+    static const D3DFORMAT bfmt[] = {
+        D3DFMT_A8R8G8B8,
+        D3DFMT_X8R8G8B8,
+        D3DFMT_A8B8G8R8,
+        D3DFMT_X8B8G8R8,
+        D3DFMT_R8G8B8
+    };
+    for (unsigned i = 0; i < sizeof bfmt / sizeof bfmt[0]; ++i) {
+        if (FormatSupported(bfmt[i], m_adaptor_fmt)) {
+            m_alphasurface_fmt = bfmt[i];
+            break;
+        }
+    }
+    if (D3DFMT_UNKNOWN != m_alphasurface_fmt)
+        VERBOSE(VB_GENERAL, D3DLOC +
+            QString("Best surface format: %1.").arg(toString(m_alphasurface_fmt)));
+    else
+        VERBOSE(VB_IMPORTANT, D3DERR + "Failed to agree surface format");
 
     D3DPRESENT_PARAMETERS d3dpp;
     ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
-    d3dpp.BackBufferFormat       = m_adaptor_fmt;
+    d3dpp.BackBufferFormat       = m_alphasurface_fmt;
     d3dpp.hDeviceWindow          = window;
     d3dpp.Windowed               = TRUE;
     d3dpp.BackBufferWidth        = size.width();
@@ -227,16 +261,24 @@ bool D3D9Context::Create(QSize size, HWND window)
     d3dpp.MultiSampleType        = D3DMULTISAMPLE_NONE;
     d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;
     d3dpp.Flags                  = D3DPRESENTFLAG_VIDEO;
-    d3dpp.PresentationInterval   = D3DPRESENT_INTERVAL_ONE;
+//    d3dpp.PresentationInterval   = D3DPRESENT_INTERVAL_ONE;
 
     if (D3D_OK != m_d3d->CreateDevice(D3DADAPTER_DEFAULT,
-                                      D3DDEVTYPE_HAL, d3dpp.hDeviceWindow,
+                                      D3DDEVTYPE_HAL, NULL,
                                       D3DCREATE_SOFTWARE_VERTEXPROCESSING,
                                       &d3dpp, &m_d3dDevice))
     {
         VERBOSE(VB_IMPORTANT, D3DERR + "Could not create the D3D device.");
         return false;
     }
+    VERBOSE(VB_GENERAL, D3DLOC + QString("Device backbuffer format: %1.")
+                                      .arg(toString(d3dpp.BackBufferFormat)));
+ 
+    if (D3DFMT_UNKNOWN == m_videosurface_fmt)
+        m_videosurface_fmt = d3dpp.BackBufferFormat;
+
+    if (D3DFMT_UNKNOWN == m_alphasurface_fmt)
+        m_alphasurface_fmt = d3dpp.BackBufferFormat;
 
     VERBOSE(VB_PLAYBACK, D3DLOC +
                QString("Hardware YV12 to RGB conversion %1.")
