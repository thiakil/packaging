From b02d056bb6c9c437e8d876acacce9b0c4685e350 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Mon, 25 Jul 2011 19:34:10 +0200
Subject: [PATCH 035/124] freemheg: Correct font x-resolution

The x-resolution used for size calculations of blocks of text is incorrect.
This most noticeably causes tables to be incorrectl;y formatted.

This patch also corrects a bug in the text block size calculation.

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythtv/libs/libmythfreemheg/Text.cpp |    6 ++-
 mythtv/libs/libmythtv/mhi.cpp        |   67 +++++++++++++++++++++++-----------
 2 files changed, 50 insertions(+), 23 deletions(-)

diff --git a/mythtv/libs/libmythfreemheg/Text.cpp b/mythtv/libs/libmythfreemheg/Text.cpp
index 603f4e9..0975ac9 100644
--- a/mythtv/libs/libmythfreemheg/Text.cpp
+++ b/mythtv/libs/libmythfreemheg/Text.cpp
@@ -520,8 +520,10 @@ MHTextLine::~MHTextLine()
     }
 }
 
-// Tabs are set every 56 points (45 pixels).
-#define TABSTOP 45
+// Tabs are set every 56 pixels
+// = (FONT_WIDTHRES * 56)/ 72 points - see libmythtv/mhi.cpp
+// = (54 * 56)/72 = 42
+#define TABSTOP 42 // pts
 static inline int Tabs(int nXpos, int nTabCount)
 {
     int nNextTab = nXpos;
diff --git a/mythtv/libs/libmythtv/mhi.cpp b/mythtv/libs/libmythtv/mhi.cpp
index dd5769b..7d4da2b 100644
--- a/mythtv/libs/libmythtv/mhi.cpp
+++ b/mythtv/libs/libmythtv/mhi.cpp
@@ -19,9 +19,10 @@
 static bool       ft_loaded = false;
 static FT_Library ft_library;
 
-#define FONT_WIDTHRES   48
-#define FONT_HEIGHTRES  72
-#define FONT_TO_USE "FreeSans.ttf"
+#define FONT_WIDTHRES   54
+#define FONT_HEIGHTRES  72 // 1 pixel per point
+#define FONT_TO_USE "FreeSans.ttf" // Tiresias Screenfont.ttf is mandated
+
 
 #define SCALED_X(arg1) (int)(((float)arg1 * m_xScale) + 0.5f)
 #define SCALED_Y(arg1) (int)(((float)arg1 * m_yScale) + 0.5f)
@@ -109,7 +110,7 @@ bool MHIContext::LoadFont(QString name)
     if (!errorD)
         return true;
 
-    LOG(VB_GENERAL, LOG_ERR, QString("Unable to find font: %1").arg(name));
+    LOG(VB_GENERAL, LOG_ERR, QString("[mhi] Unable to find font: %1").arg(name));
     return false;
 }
 
@@ -1096,6 +1097,18 @@ void MHIText::SetFont(int size, bool isBold, bool isItalic)
     // Bold and Italic are currently ignored.
 }
 
+// FT sizes are in 26.6 fixed point form
+const int kShift = 6;
+static inline FT_F26Dot6 Point2FT(int pt)
+{
+    return pt << kShift;
+}
+
+static inline int FT2Point(FT_F26Dot6 fp)
+{
+    return (fp + (1<<(kShift-1))) >> kShift;
+}
+
 // Return the bounding rectangle for a piece of text drawn in the
 // current font. If maxSize is non-negative it sets strLen to the
 // number of characters that will fit in the space and returns the
@@ -1109,24 +1122,31 @@ QRect MHIText::GetBounds(const QString &str, int &strLen, int maxSize)
         return QRect(0,0,0,0);
 
     FT_Face face = m_parent->GetFontFace();
-    FT_Error error = FT_Set_Char_Size(face, 0, m_fontsize*64,
+    FT_Error error = FT_Set_Char_Size(face, 0, Point2FT(m_fontsize),
                                       FONT_WIDTHRES, FONT_HEIGHTRES);
     if (error)
         return QRect(0,0,0,0);
 
-    FT_GlyphSlot slot = face->glyph; /* a small shortcut */
-
     int maxAscent = 0, maxDescent = 0, width = 0;
     FT_Bool useKerning = FT_HAS_KERNING(face);
     FT_UInt previous = 0;
 
     for (int n = 0; n < strLen; n++)
     {
-        QChar ch = str[n];
+        QChar ch = str.at(n);
         FT_UInt glyphIndex = FT_Get_Char_Index(face, ch.unicode());
+
+        if (glyphIndex == 0)
+        {
+            LOG(VB_MHEG, LOG_INFO, QString("[mhi] Unknown glyph 0x%1")
+                .arg(ch.unicode(),0,16));
+            previous = 0;
+            continue;
+        }
+
         int kerning = 0;
 
-        if (useKerning && previous != 0 && glyphIndex != 0)
+        if (useKerning && previous != 0)
         {
             FT_Vector delta;
             FT_Get_Kerning(face, previous, glyphIndex,
@@ -1139,9 +1159,12 @@ QRect MHIText::GetBounds(const QString &str, int &strLen, int maxSize)
         if (error)
             continue; // ignore errors.
 
+        FT_GlyphSlot slot = face->glyph; /* a small shortcut */
+        FT_Pos advance = slot->metrics.horiAdvance + kerning;
+
         if (maxSize >= 0)
         {
-            if ((width + slot->advance.x + kerning + (1<<6)-1) >> 6 > maxSize)
+            if (FT2Point(width + advance) > maxSize)
             {
                 // There isn't enough space for this character.
                 strLen = n;
@@ -1157,15 +1180,11 @@ QRect MHIText::GetBounds(const QString &str, int &strLen, int maxSize)
         if (descent > maxDescent)
             maxDescent = descent;
 
-        width += slot->advance.x + kerning;
+        width += advance;
         previous = glyphIndex;
     }
 
-    maxAscent = (maxAscent + (1<<6)-1) >> 6;
-    maxDescent = (maxDescent + (1<<6)-1) >> 6;
-
-    return QRect(0, -maxAscent,
-                 (width+(1<<6)-1) >> 6, maxAscent + maxDescent);
+    return QRect(0, -FT2Point(maxAscent), FT2Point(width), FT2Point(maxAscent + maxDescent));
 }
 
 // Reset the image and fill it with transparent ink.
@@ -1192,13 +1211,12 @@ void MHIText::AddText(int x, int y, const QString &str, MHRgba colour)
 {
     if (!m_parent->IsFaceLoaded()) return;
     FT_Face face = m_parent->GetFontFace();
-    FT_GlyphSlot slot = face->glyph;
-    FT_Error error = FT_Set_Char_Size(face, 0, m_fontsize*64,
+    FT_Error error = FT_Set_Char_Size(face, 0, Point2FT(m_fontsize),
                                       FONT_WIDTHRES, FONT_HEIGHTRES);
 
     // X positions are computed to 64ths and rounded.
     // Y positions are in pixels
-    int posX = x << 6;
+    int posX = Point2FT(x);
     int pixelY = y;
     FT_Bool useKerning = FT_HAS_KERNING(face);
     FT_UInt previous = 0;
@@ -1209,7 +1227,13 @@ void MHIText::AddText(int x, int y, const QString &str, MHRgba colour)
         // Load the glyph.
         QChar ch = str[n];
         FT_UInt glyphIndex = FT_Get_Char_Index(face, ch.unicode());
-        if (useKerning && previous != 0 && glyphIndex != 0)
+        if (glyphIndex == 0)
+        {
+            previous = 0;
+            continue;
+        }
+
+        if (useKerning && previous != 0)
         {
             FT_Vector delta;
             FT_Get_Kerning(face, previous, glyphIndex,
@@ -1221,6 +1245,7 @@ void MHIText::AddText(int x, int y, const QString &str, MHRgba colour)
         if (error)
             continue; // ignore errors
 
+        FT_GlyphSlot slot = face->glyph;
         if (slot->format != FT_GLYPH_FORMAT_BITMAP)
             continue; // Problem
 
@@ -1229,7 +1254,7 @@ void MHIText::AddText(int x, int y, const QString &str, MHRgba colour)
 
         unsigned char *source = slot->bitmap.buffer;
         // Get the origin for the bitmap
-        int baseX = ((posX + (1 << 5)) >> 6) + slot->bitmap_left;
+        int baseX = FT2Point(posX) + slot->bitmap_left;
         int baseY = pixelY - slot->bitmap_top;
         // Copy the bitmap into the image.
         for (int i = 0; i < slot->bitmap.rows; i++)
-- 
1.7.9.5

