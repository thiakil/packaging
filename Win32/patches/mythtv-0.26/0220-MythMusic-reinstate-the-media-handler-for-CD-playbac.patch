From 8c6e484403db1c59634838a8a95c17d1f112088a Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Sat, 24 Aug 2013 16:14:10 +0100
Subject: [PATCH 220/227] MythMusic: reinstate the media handler for CD
 playback

The media handler will detect when a CD is inserted and depending on the
'Automatically Play CDs' setting will either show the music playback screen
and start playing the CD or the tracks will be remembered allowing the user
to manually add them to the playlist either from the Quick Playlists->From CD
menu option or I'll add a node to the playlisteditor screen so they can be
added from there as well.

Note: bumps the ABI so a re-compile is necessary.
(cherry picked from commit e838c274ad70658725a69c4a427b1f0b87413236)

Conflicts:

	mythplugins/mythmusic/mythmusic/main.cpp
	mythtv/libs/libmythbase/mythversion.h
	mythtv/libs/libmythmetadata/musicmetadata.h
---
 mythplugins/mythmusic/mythmusic/main.cpp     |  153 ++++++++++++++++++++------
 mythplugins/mythmusic/mythmusic/metadata.h   |    1 +
 mythplugins/mythmusic/mythmusic/playlist.cpp |   45 +++++++-
 mythplugins/mythmusic/mythmusic/playlist.h   |    3 +-
 mythtv/libs/libmythbase/mythversion.h        |    2 +-
 5 files changed, 162 insertions(+), 42 deletions(-)

diff --git a/mythplugins/mythmusic/mythmusic/main.cpp b/mythplugins/mythmusic/mythmusic/main.cpp
index 2dfd2eb..633f4b5 100644
--- a/mythplugins/mythmusic/mythmusic/main.cpp
+++ b/mythplugins/mythmusic/mythmusic/main.cpp
@@ -26,6 +26,7 @@
 // MythMusic headers
 #include "decoder.h"
 #include "metadata.h"
+#include "cddecoder.h"
 #include "playlisteditorview.h"
 #include "playlistview.h"
 #include "streamview.h"
@@ -432,70 +433,156 @@ static void showMiniPlayer(void)
         gPlayer->showMiniPlayer();
 }
 
-#ifdef FIXME  // the only call is likewise commented out and needs fixing
 static void handleMedia(MythMediaDevice *cd)
 {
-    // if the music player is already playing ignore the event
-    if (gPlayer->isPlaying())
-    {
-        LOG(VB_GENERAL, LOG_NOTICE, "Got a media changed event but ignoring since "
-                                      "the music player is already playing");
+    if (!cd)
         return;
-    }
-    else
-         LOG(VB_GENERAL, LOG_NOTICE, "Got a media changed event");
 
     // Note that we should deal with other disks that may contain music.
     // e.g. MEDIATYPE_MMUSIC or MEDIATYPE_MIXED
+    LOG(VB_MEDIA, LOG_NOTICE, QString("Ignoring changed media event of type: %1")
+        .arg(MythMediaDevice::MediaTypeString(cd->getMediaType())));
+}
+
+static void handleCDMedia(MythMediaDevice *cd)
+{
+#ifdef HAVE_CDIO
 
     if (!cd)
         return;
 
+    LOG(VB_MEDIA, LOG_NOTICE, "Got a media changed event");
+
+    QString newDevice;
+
+    // save the device if valid
     if (cd->isUsable())
     {
-        QString newDevice;
-
 #ifdef Q_OS_MAC
         newDevice = cd->getMountPath();
 #else
         newDevice = cd->getDevicePath();
 #endif
 
-        if (gCDdevice.length() && gCDdevice != newDevice)
+        gCDdevice = newDevice;
+        LOG(VB_MEDIA, LOG_INFO, "MythMusic: Storing CD device " + gCDdevice);
+    }
+    else
+    {
+        LOG(VB_MEDIA, LOG_INFO, "Device is not usable clearing cd data");
+
+        // device is not usable so remove any existing CD tracks
+        if (gMusicData->all_music)
         {
-            // In the case of multiple audio CDs, clear the old stored device
-            // so the user has to choose (via MediaMonitor::defaultCDdevice())
+            gMusicData->all_music->clearCDData();
+            gMusicData->all_playlists->getActive()->removeAllCDTracks();
+        }
+
+        gPlayer->activePlaylistChanged(-1, true);
+        gPlayer->sendCDChangedEvent();
+
+        return;
+    }
+
+    if (!gMusicData->initialized)
+        loadMusic();
+
+    // remove any existing CD tracks
+    if (gMusicData->all_music)
+    {
+        gMusicData->all_music->clearCDData();
+        gMusicData->all_playlists->getActive()->removeAllCDTracks();
+    }
 
-            gCDdevice = QString::null;
-            LOG(VB_MEDIA, LOG_INFO, "MythMusic: Forgetting existing CD");
+    // find any new cd tracks
+    CdDecoder *decoder = new CdDecoder("cda", NULL, NULL, NULL);
+    decoder->setDevice(newDevice);
+
+    int tracks = decoder->getNumTracks();
+    bool setTitle = false;
+
+    for (int trackNo = 1; trackNo <= tracks; trackNo++)
+    {
+        Metadata *track = decoder->getMetadata(trackNo);
+        if (track)
+        {
+            gMusicData->all_music->addCDTrack(*track);
+
+            if (!setTitle)
+            {
+
+                QString parenttitle = " ";
+                if (track->FormatArtist().length() > 0)
+                {
+                    parenttitle += track->FormatArtist();
+                    parenttitle += " ~ ";
+                }
+
+                if (track->Album().length() > 0)
+                    parenttitle += track->Album();
+                else
+                {
+                    parenttitle = " " + QObject::tr("Unknown");
+                    LOG(VB_GENERAL, LOG_INFO, "Couldn't find your "
+                    " CD. It may not be in the freedb database.\n"
+                    "    More likely, however, is that you need to delete\n"
+                    "    ~/.cddb and ~/.cdserverrc and restart MythMusic.");
+                }
+
+                gMusicData->all_music->setCDTitle(parenttitle);
+                setTitle = true;
+            }
+
+            delete track;
         }
-        else
+    }
+
+    gPlayer->sendCDChangedEvent();
+
+    delete decoder;
+
+    // if the AutoPlayCD setting is set we remove all the existing tracks
+    // from the playlist and replace them with the new CD tracks found
+    if (gCoreContext->GetNumSetting("AutoPlayCD", 0))
+    {
+        gMusicData->all_playlists->getActive()->removeAllTracks();
+
+        QList<int> songList;
+
+        for (int x = 1; x <= gMusicData->all_music->getCDTrackCount(); x++)
         {
-            gCDdevice = newDevice;
-            LOG(VB_MEDIA, LOG_INFO,
-                "MythMusic: Storing CD device " + gCDdevice);
+            Metadata *mdata = gMusicData->all_music->getCDMetadata(x);
+            if (mdata)
+                songList.append((mdata)->ID());
+        }
+
+        if (songList.count())
+        {
+            gMusicData->all_playlists->getActive()->fillSonglistFromList(
+                    songList, true, PL_REPLACE, 0);
+            gPlayer->setCurrentTrackPos(0);
         }
     }
     else
     {
-        gCDdevice = QString::null;
+        // don't show the music screen if AutoPlayCD is off
         return;
     }
 
-    if (gCoreContext->GetNumSetting("AutoPlayCD", 0))
+    // if there is no music screen showing show the Playlist view
+    if (!gPlayer->hasClient())
     {
-        // Empty the playlist to ensure CD is played first
-        if (gMusicData->all_music)
-            gMusicData->all_music->clearCDData();
-        if (gMusicData->all_playlists)
-            gMusicData->all_playlists->clearCDList();
+        // make sure we start playing from the first track
+        gCoreContext->SaveSetting("MusicBookmark", 0);
+        gCoreContext->SaveSetting("MusicBookmarkPosition", 0);
 
         runMusicPlayback();
     }
-    else
-        mythplugin_run();
-}
+#else
+    LOG(VB_GENERAL, LOG_NOTICE, "MythMusic got a media changed event"
+                                "but cdio support is not compiled in");
 #endif
+}
 
 static void setupKeys(void)
 {
@@ -569,18 +656,14 @@ static void setupKeys(void)
     REG_KEY("Music", "SWITCHTORADIO",                 QT_TRANSLATE_NOOP("MythControls",
         "Switch to the radio stream view"), "");
 
-#ifdef FIXME
-// FIXME need to find a way to stop the media monitor jumping to the main menu before
-// calling the handler
     REG_MEDIA_HANDLER(QT_TRANSLATE_NOOP("MythControls",
-        "MythMusic Media Handler 1/2"), "", "", handleMedia,
+        "MythMusic Media Handler 1/2"), "", "", handleCDMedia,
         MEDIATYPE_AUDIO | MEDIATYPE_MIXED, QString::null);
     REG_MEDIA_HANDLER(QT_TRANSLATE_NOOP("MythControls",
         "MythMusic Media Handler 2/2"), "", "", handleMedia,
         MEDIATYPE_MMUSIC, "mp3,mp2,ogg,oga,flac,wma,wav,ac3,"
                           "oma,omg,atp,ra,dts,aac,m4a,aa3,tta,"
                           "mka,aiff,swa,wv");
-#endif
 }
 
 int mythplugin_init(const char *libversion)
diff --git a/mythplugins/mythmusic/mythmusic/metadata.h b/mythplugins/mythmusic/mythmusic/metadata.h
index 6bf3eed..155ceb5 100644
--- a/mythplugins/mythmusic/mythmusic/metadata.h
+++ b/mythplugins/mythmusic/mythmusic/metadata.h
@@ -196,6 +196,7 @@ class Metadata
     void setRepo(RepoType repo) { m_id = (m_id & METADATA_ID_MASK) | (repo << METADATA_REPO_SHIFT); }
 
     bool isCDTrack(void) const { return ID_TO_REPO(m_id) == RT_CD; }
+    bool isDBTrack(void) const { return ID_TO_REPO(m_id) == RT_Database; }
 
     QString Filename(bool find = true) const;
     void setFilename(const QString &lfilename) { m_filename = lfilename; }
diff --git a/mythplugins/mythmusic/mythmusic/playlist.cpp b/mythplugins/mythmusic/mythmusic/playlist.cpp
index 32ad0c2..1ef0e11 100644
--- a/mythplugins/mythmusic/mythmusic/playlist.cpp
+++ b/mythplugins/mythmusic/mythmusic/playlist.cpp
@@ -50,7 +50,8 @@ void Playlist::copyTracks(Playlist *to_ptr, bool update_display)
     SongList::const_iterator it = m_songs.begin();
     for (; it != m_songs.end(); ++it)
     {
-        to_ptr->addTrack(*it, update_display);
+        if ((*it)->isDBTrack())
+            to_ptr->addTrack(*it, update_display);
     }
 
     enableSaves();
@@ -97,6 +98,27 @@ void Playlist::removeAllTracks(void)
     changed();
 }
 
+void Playlist::removeAllCDTracks(void)
+{
+    // find the cd tracks
+    SongList cdTracks;
+    for (int x = 0; x < m_songs.count(); x++)
+    {
+        if (m_songs.at(x)->isCDTrack())
+            cdTracks.append(m_songs.at(x));
+    }
+
+    // remove the tracks from our lists
+    for (int x = 0; x < cdTracks.count(); x++)
+    {
+        m_songs.removeAll(cdTracks.at(x));
+        m_songMap.remove(cdTracks.at(x)->ID());
+        m_shuffledSongs.removeAll(cdTracks.at(x));;
+    }
+
+    changed();
+}
+
 void Playlist::removeTrack(int the_track)
 {
     QMap<int, Metadata*>::iterator it = m_songMap.find(the_track);
@@ -835,7 +857,7 @@ void Playlist::fillSonglistFromList(const QList<int> &songList,
     changed();
 }
 
-QString Playlist::toRawSonglist(bool shuffled)
+QString Playlist::toRawSonglist(bool shuffled, bool tracksOnly)
 {
     QString rawList;
 
@@ -844,7 +866,13 @@ QString Playlist::toRawSonglist(bool shuffled)
         SongList::const_iterator it = m_shuffledSongs.begin();
         for (; it != m_shuffledSongs.end(); ++it)
         {
-            rawList += QString(",%1").arg((*it)->ID());
+            if (tracksOnly)
+            {
+                if (ID_TO_REPO((*it)->ID()) == RT_Database)
+                    rawList += QString(",%1").arg((*it)->ID());
+            }
+            else
+                rawList += QString(",%1").arg((*it)->ID());
         }
     }
     else
@@ -852,7 +880,13 @@ QString Playlist::toRawSonglist(bool shuffled)
         SongList::const_iterator it = m_songs.begin();
         for (; it != m_songs.end(); ++it)
         {
-            rawList += QString(",%1").arg((*it)->ID());
+            if (tracksOnly)
+            {
+                if (ID_TO_REPO((*it)->ID()) == RT_Database)
+                    rawList += QString(",%1").arg((*it)->ID());
+            }
+            else
+                rawList += QString(",%1").arg((*it)->ID());
         }
     }
 
@@ -978,7 +1012,8 @@ void Playlist::savePlaylist(QString a_name, QString a_host)
         return;
     }
 
-    QString rawSonglist = toRawSonglist(true);
+    // get the shuffled list of tracks excluding any cd tracks and radio streams
+    QString rawSonglist = toRawSonglist(true, true);
 
     MSqlQuery query(MSqlQuery::InitCon());
     uint songcount = 0, playtime = 0;
diff --git a/mythplugins/mythmusic/mythmusic/playlist.h b/mythplugins/mythmusic/mythmusic/playlist.h
index 25b84cc..b4964c8 100644
--- a/mythplugins/mythmusic/mythmusic/playlist.h
+++ b/mythplugins/mythmusic/mythmusic/playlist.h
@@ -66,7 +66,7 @@ class Playlist : public QObject
                               bool removeDuplicates,
                               InsertPLOption insertOption,
                               int currentTrackID);
-    QString toRawSonglist(bool shuffled = false);
+    QString toRawSonglist(bool shuffled = false, bool tracksOnly = false);
 
     const SongList &getSongs(void) { return m_shuffledSongs; }
     Metadata* getSongAt(int pos);
@@ -83,6 +83,7 @@ class Playlist : public QObject
 
     void removeTrack(int the_track_id);
     void removeAllTracks(void);
+    void removeAllCDTracks(void);
 
     void copyTracks(Playlist *to_ptr, bool update_display);
 
diff --git a/mythtv/libs/libmythbase/mythversion.h b/mythtv/libs/libmythbase/mythversion.h
index 4de6128..c446969 100644
--- a/mythtv/libs/libmythbase/mythversion.h
+++ b/mythtv/libs/libmythbase/mythversion.h
@@ -12,7 +12,7 @@
 /// Update this whenever the plug-in API changes.
 /// Including changes in the libmythbase, libmyth, libmythtv, libmythav* and
 /// libmythui class methods used by plug-ins.
-#define MYTH_BINARY_VERSION "0.26.20130225-1"
+#define MYTH_BINARY_VERSION "0.26.20130824-1"
 
 /** \brief Increment this whenever the MythTV network protocol changes.
  *
-- 
1.7.9.5

