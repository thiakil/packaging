From 0c04a046b1e8b47b2ac67f090043666ba64ba5d8 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Tue, 2 Aug 2011 17:02:09 +0200
Subject: [PATCH 063/227] Mythvideo: restore DVD ripping

Resurrect the mtd code from 0.24 pre-release removed by commit
9c9c2ed108455e162b702d88885abefaee5b6840

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythtv/libs/libmythtv/mythiowrapper.h              |    2 +-
 mythtv/programs/mythfrontend/dvdinfo.cpp           |   89 ++
 mythtv/programs/mythfrontend/dvdinfo.h             |  116 ++
 mythtv/programs/mythfrontend/dvdripbox.cpp         |  885 +++++++++++
 mythtv/programs/mythfrontend/dvdripbox.h           |  126 ++
 mythtv/programs/mythfrontend/main.cpp              |   47 +
 mythtv/programs/mythfrontend/mythfrontend.pro      |    6 +
 mythtv/programs/mythfrontend/titledialog.cpp       |  421 ++++++
 mythtv/programs/mythfrontend/titledialog.h         |   68 +
 .../programs/mythfrontend/videoglobalsettings.cpp  |  169 +++
 mythtv/programs/mythfrontend/videoglobalsettings.h |    6 +
 mythtv/programs/mythmtd/.gitignore                 |    1 +
 mythtv/programs/mythmtd/dvdprobe.cpp               |  813 +++++++++++
 mythtv/programs/mythmtd/dvdprobe.h                 |  190 +++
 mythtv/programs/mythmtd/fileobs.cpp                |  195 +++
 mythtv/programs/mythmtd/fileobs.h                  |   44 +
 mythtv/programs/mythmtd/jobthread.cpp              | 1539 ++++++++++++++++++++
 mythtv/programs/mythmtd/jobthread.h                |  241 +++
 mythtv/programs/mythmtd/logging.cpp                |  120 ++
 mythtv/programs/mythmtd/logging.h                  |   53 +
 mythtv/programs/mythmtd/main.cpp                   |  182 +++
 mythtv/programs/mythmtd/mtd.cpp                    | 1030 +++++++++++++
 mythtv/programs/mythmtd/mtd.h                      |  128 ++
 mythtv/programs/mythmtd/mythmtd.pro                |   24 +
 mythtv/programs/mythmtd/threadevents.cpp           |   38 +
 mythtv/programs/mythmtd/threadevents.h             |   41 +
 mythtv/programs/programs.pro                       |    1 +
 mythtv/themes/DVR/main_settings.xml                |    2 +-
 mythtv/themes/DVR/video_settings.xml               |    8 +
 mythtv/themes/DVR/videomenu.xml                    |    8 +-
 mythtv/themes/classic/main_settings.xml            |    2 +-
 mythtv/themes/classic/video_settings.xml           |    8 +
 mythtv/themes/classic/videomenu.xml                |    8 +-
 mythtv/themes/default-wide/dvd-ui.xml              |  246 ++++
 mythtv/themes/default/dvd-ui.xml                   |  246 ++++
 mythtv/themes/default/images/mv_next_off.png       |  Bin 0 -> 1515 bytes
 mythtv/themes/default/images/mv_next_on.png        |  Bin 0 -> 1261 bytes
 mythtv/themes/default/images/mv_next_pushed.png    |  Bin 0 -> 1286 bytes
 mythtv/themes/default/images/mv_prev_off.png       |  Bin 0 -> 1569 bytes
 mythtv/themes/default/images/mv_prev_on.png        |  Bin 0 -> 1370 bytes
 mythtv/themes/default/images/mv_prev_pushed.png    |  Bin 0 -> 1403 bytes
 mythtv/themes/defaultmenu/media_settings.xml       |    2 +-
 mythtv/themes/defaultmenu/optical_menu.xml         |    6 +
 mythtv/themes/defaultmenu/video_settings.xml       |    8 +
 mythtv/themes/mediacentermenu/media_settings.xml   |    2 +-
 mythtv/themes/mediacentermenu/optical_menu.xml     |    6 +
 mythtv/themes/mediacentermenu/video_settings.xml   |    8 +
 mythtv/themes/themestrings.h                       |   39 +-
 48 files changed, 7165 insertions(+), 9 deletions(-)
 create mode 100644 mythtv/programs/mythfrontend/dvdinfo.cpp
 create mode 100644 mythtv/programs/mythfrontend/dvdinfo.h
 create mode 100644 mythtv/programs/mythfrontend/dvdripbox.cpp
 create mode 100644 mythtv/programs/mythfrontend/dvdripbox.h
 create mode 100644 mythtv/programs/mythfrontend/titledialog.cpp
 create mode 100644 mythtv/programs/mythfrontend/titledialog.h
 create mode 100644 mythtv/programs/mythmtd/.gitignore
 create mode 100644 mythtv/programs/mythmtd/dvdprobe.cpp
 create mode 100644 mythtv/programs/mythmtd/dvdprobe.h
 create mode 100644 mythtv/programs/mythmtd/fileobs.cpp
 create mode 100644 mythtv/programs/mythmtd/fileobs.h
 create mode 100644 mythtv/programs/mythmtd/jobthread.cpp
 create mode 100644 mythtv/programs/mythmtd/jobthread.h
 create mode 100644 mythtv/programs/mythmtd/logging.cpp
 create mode 100644 mythtv/programs/mythmtd/logging.h
 create mode 100644 mythtv/programs/mythmtd/main.cpp
 create mode 100644 mythtv/programs/mythmtd/mtd.cpp
 create mode 100644 mythtv/programs/mythmtd/mtd.h
 create mode 100644 mythtv/programs/mythmtd/mythmtd.pro
 create mode 100644 mythtv/programs/mythmtd/threadevents.cpp
 create mode 100644 mythtv/programs/mythmtd/threadevents.h
 create mode 100644 mythtv/themes/default-wide/dvd-ui.xml
 create mode 100644 mythtv/themes/default/dvd-ui.xml
 create mode 100644 mythtv/themes/default/images/mv_next_off.png
 create mode 100644 mythtv/themes/default/images/mv_next_on.png
 create mode 100644 mythtv/themes/default/images/mv_next_pushed.png
 create mode 100644 mythtv/themes/default/images/mv_prev_off.png
 create mode 100644 mythtv/themes/default/images/mv_prev_on.png
 create mode 100644 mythtv/themes/default/images/mv_prev_pushed.png

diff --git a/mythtv/libs/libmythtv/mythiowrapper.h b/mythtv/libs/libmythtv/mythiowrapper.h
index d4d0648..666b0c2 100644
--- a/mythtv/libs/libmythtv/mythiowrapper.h
+++ b/mythtv/libs/libmythtv/mythiowrapper.h
@@ -29,7 +29,7 @@ MTV_PUBLIC ssize_t mythfile_read(int fileID, void *buf, size_t count);
 MTV_PUBLIC ssize_t mythfile_write(int fileID, void *buf, size_t count);
 MTV_PUBLIC int     mythfile_stat(const char *path, struct stat *buf);
 MTV_PUBLIC int     mythfile_stat_fd(int fileID, struct stat *buf);
-int     mythfile_exists(const char *path, const char *file);
+MTV_PUBLIC int     mythfile_exists(const char *path, const char *file);
 
 int     mythdir_check(int fileID);
 MTV_PUBLIC int     mythdir_opendir(const char *dirname);
diff --git a/mythtv/programs/mythfrontend/dvdinfo.cpp b/mythtv/programs/mythfrontend/dvdinfo.cpp
new file mode 100644
index 0000000..db17e7f
--- /dev/null
+++ b/mythtv/programs/mythfrontend/dvdinfo.cpp
@@ -0,0 +1,89 @@
+#include <mythcontext.h>
+
+#include "dvdinfo.h"
+
+DVDAudioInfo::DVDAudioInfo(int track_number, const QString &audio_description) :
+    description(audio_description), track(track_number), channels(0)
+{
+}
+
+/*
+---------------------------------------------------------------------
+*/
+
+DVDTitleInfo::DVDTitleInfo() : numb_chapters(0), numb_angles(0),
+    track_number(0), hours(0), minutes(0), seconds(0), is_selected(false),
+    selected_quality(-1), selected_audio(1), selected_subtitle(-1)
+{
+    use_ac3 = gCoreContext->GetNumSetting("MTDac3flag");
+}
+
+void DVDTitleInfo::setTime(uint h, uint m, uint s)
+{
+    hours = h;
+    minutes = m;
+    seconds = s;
+}
+
+uint DVDTitleInfo::getPlayLength()
+{
+    return seconds + (60 * minutes) + (60 * 60 * hours);
+}
+
+QString DVDTitleInfo::getTimeString()
+{
+    QString a_string;
+    a_string.sprintf("%d:%02d:%02d", hours, minutes, seconds);
+    return a_string;
+}
+
+void DVDTitleInfo::addAudio(DVDAudioInfo *new_audio_track)
+{
+    audio_tracks.append(new_audio_track);
+}
+
+void DVDTitleInfo::addSubTitle(DVDSubTitleInfo *new_subtitle)
+{
+    subtitles.append(new_subtitle);
+}
+
+DVDTitleInfo::~DVDTitleInfo()
+{
+    while( !audio_tracks.isEmpty() )
+        delete audio_tracks.takeFirst();
+    audio_tracks.clear();
+    while( !subtitles.isEmpty() )
+        delete subtitles.takeFirst();
+    subtitles.clear();
+}
+
+/*
+---------------------------------------------------------------------
+*/
+
+
+DVDVolInfo::DVDVolInfo(const QString &new_name) : volume_name(new_name)
+{
+}
+
+DVDTitleInfo* DVDVolInfo::getTitle(uint which_one)
+{
+    QListIterator<DVDTitleInfo *> iter(titles);
+    while (iter.hasNext())
+    {
+        DVDTitleInfo *title = iter.next();
+        if(title->getTrack() == which_one)
+        {
+            return title;
+        }
+    }
+    return NULL;
+}
+
+
+DVDVolInfo::~DVDVolInfo()
+{
+    while( !titles.isEmpty() )
+        delete titles.takeFirst();
+    titles.clear();
+}
diff --git a/mythtv/programs/mythfrontend/dvdinfo.h b/mythtv/programs/mythfrontend/dvdinfo.h
new file mode 100644
index 0000000..c15a02a
--- /dev/null
+++ b/mythtv/programs/mythfrontend/dvdinfo.h
@@ -0,0 +1,116 @@
+#ifndef DVDINFO_H_
+#define DVDINFO_H_
+
+#include <QString>
+#include <QList>
+
+class DVDSubTitleInfo
+{
+  public:
+    DVDSubTitleInfo(int subtitle_id, const QString &subtitle_name) :
+        id(subtitle_id), name(subtitle_name) {}
+
+    int     getID() { return id; }
+    QString getName() { return name; }
+
+  private:
+    int     id;
+    QString name;
+};
+
+class DVDAudioInfo
+{
+  public:
+     DVDAudioInfo(int track_number, const QString &audio_description);
+
+    QString getAudioString() { return description; }
+    void    setChannels(int a_number) { channels = a_number; }
+    int     getChannels() { return channels; }
+    int     getTrack() { return track; }
+
+  private:
+    QString description;
+    int     track;
+    int     channels;
+};
+
+class DVDTitleInfo
+{
+  public:
+     DVDTitleInfo();
+    ~DVDTitleInfo();
+
+    void    setChapters(uint a_uint){numb_chapters = a_uint;}
+    void    setAngles(uint a_uint){numb_angles = a_uint;}
+    void    setTrack(uint a_uint){track_number = a_uint;}
+    void    setTime(uint h, uint m, uint s);
+    void    setSelected(bool yes_or_no){is_selected = yes_or_no;}
+    void    setQuality(int a_level){selected_quality = a_level;}
+    void    setAudio(int which_track){selected_audio = which_track;}
+    void    setSubTitle(int which_subtitle){selected_subtitle = which_subtitle;}
+    void    setName(QString a_name){name = a_name;}
+    void    setInputID(uint a_uint){dvdinput_id = a_uint;}
+    void    setAC3(bool y_or_n){use_ac3 = y_or_n;}
+
+    uint    getChapters(){return numb_chapters;}
+    uint    getAngles(){return numb_angles;}
+    uint    getTrack(){return track_number;}
+    uint    getPlayLength();
+    QString getTimeString();
+    bool    getSelected(){return is_selected;}
+    int     getQuality(){return selected_quality;}
+    QString getName(){return name;}
+    int     getAudio(){return selected_audio;}
+    int     getSubTitle(){return selected_subtitle;}
+    uint    getInputID(){return dvdinput_id;}
+    bool    getAC3(){return use_ac3;}
+
+    void addAudio(DVDAudioInfo *new_audio_track);
+    void addSubTitle(DVDSubTitleInfo *new_subtitle);
+    QList<DVDAudioInfo *> *getAudioTracks(){return &audio_tracks;}
+    QList<DVDSubTitleInfo *> *getSubTitles(){return &subtitles;}
+    DVDAudioInfo *getAudioTrack(int which_one)
+    {
+        return audio_tracks.at(which_one);
+    }
+
+  private:
+    uint    numb_chapters;
+    uint    numb_angles;
+    uint    track_number;
+
+    uint    hours;
+    uint    minutes;
+    uint    seconds;
+
+    QList<DVDAudioInfo *>    audio_tracks;
+    QList<DVDSubTitleInfo *> subtitles;
+
+    bool    is_selected;
+    int     selected_quality;
+    int     selected_audio;
+    int     selected_subtitle;
+    bool    use_ac3;
+    QString name;
+
+    uint    dvdinput_id;
+};
+
+class DVDVolInfo
+{
+  public:
+    DVDVolInfo(const QString &new_name);
+    ~DVDVolInfo();
+
+    void  addTitle(DVDTitleInfo *new_title){titles.append(new_title);}
+    DVDTitleInfo *getTitle(uint which_one);
+
+    QString                 getName(){return volume_name;}
+    QList<DVDTitleInfo *> *getTitles(){return &titles;}
+
+  private:
+    QList<DVDTitleInfo *> titles;
+    QString volume_name;
+};
+
+#endif  // dvdinfo_h_
diff --git a/mythtv/programs/mythfrontend/dvdripbox.cpp b/mythtv/programs/mythfrontend/dvdripbox.cpp
new file mode 100644
index 0000000..1000c33
--- /dev/null
+++ b/mythtv/programs/mythfrontend/dvdripbox.cpp
@@ -0,0 +1,885 @@
+#include <QApplication>
+#include <QProcess>
+#include <QRegExp>
+#include <QTimer>
+
+#include <mythcontext.h>
+#include <mythmediamonitor.h>
+#include <mythdirs.h>
+
+#include <mythscreenstack.h>
+#include <mythuibutton.h>
+#include <mythuitext.h>
+#include <mythuiprogressbar.h>
+#include <mythlogging.h>
+
+#include "titledialog.h"
+#include "libmythmetadata/videoutils.h"
+#include "dvdripbox.h"
+
+MTDJob::MTDJob() : job_number(-1), overall_progress(0.0), subjob_progress(0.0),
+    cancelled(false)
+{
+}
+
+MTDJob::MTDJob(QString lname) : job_number(-1), job_name(lname),
+    overall_progress(0.0), subjob_progress(0.0), cancelled(false)
+{
+}
+
+void MTDJob::SetName(const QString &a_name)
+{
+    if(a_name != job_name && cancelled)
+    {
+        cancelled = false;
+        emit toggledCancelled();
+    }
+    job_name = a_name;
+}
+
+void MTDJob::setActivity(const QString &an_act)
+{
+    if(!cancelled)
+    {
+        current_activity = an_act;
+    }
+}
+
+void MTDJob::setSubjob(double a_number)
+{
+    if(!cancelled)
+    {
+        subjob_progress = a_number;
+    }
+}
+
+/*
+---------------------------------------------------------------------
+*/
+
+namespace
+{
+    class LaunchMTD : public QObject
+    {
+        Q_OBJECT
+
+      public:
+        static LaunchMTD *Create()
+        {
+            return new LaunchMTD;
+        }
+
+      private:
+        LaunchMTD()
+        {
+            QStringList args;
+            args << "-d";
+
+            QProcess::startDetached(QString("%1/bin/mythmtd")
+                    .arg(GetInstallPrefix()), args);
+            QTimer::singleShot(2000, this, SLOT(OnLaunchWaitDone()));
+        }
+
+        ~LaunchMTD() {}
+
+      signals:
+        void SigLaunchAttemptComplete();
+
+      private slots:
+        void OnLaunchWaitDone()
+        {
+            emit SigLaunchAttemptComplete();
+            deleteLater();
+        }
+    };
+}
+
+DVDRipBox::DVDRipBox(MythScreenStack *lparent, QString lname, QString device) :
+    MythScreenType(lparent, lname),
+    m_mtdPort(gCoreContext->GetNumSetting("MTDPort", 2442)),
+    m_clientSocket(this),
+    m_triedMTDLaunch(false), m_connected(false), m_firstRun(true),
+    m_haveDisc(false),
+    m_firstDiscFound(false), m_blockMediaRequests(false), m_jobCount(0),
+    m_currentJob(-1), m_ignoreCancels(false), m_inited(false),
+    m_device(device), m_dvdInfo(0),
+    m_warningText(0), m_overallText(0), m_jobText(0),
+    m_numjobsText(0), m_overallProgress(0), m_jobProgress(0),
+    m_ripscreenButton(0), m_cancelButton(0), m_nextjobButton(0),
+    m_prevjobButton(0)
+{
+    //  A DVDRipBox is a single dialog that does a bunch of things
+    //  depending on the MythThemedDialog "context"
+    //
+    //  These contexts are:
+    //
+    //          0 - started up, don't know if we can (or can't talk to the mtd)
+    //          1 - can't connect, error messages
+    //          2 - can connect, but nothing going on
+    //          3 - browse through transcoding jobs currently running
+    //          4 - browse through a DVD and (possibly) launch a transcoding job
+    //              (^^ this is "temporarily" launching a new dialog)
+    //
+    connect(&m_statusTimer, SIGNAL(timeout()), SLOT(pollStatus()));
+
+    connect(&m_clientSocket, SIGNAL(error(QAbstractSocket::SocketError)),
+            SLOT(OnConnectionError(QAbstractSocket::SocketError)));
+    connect(&m_clientSocket, SIGNAL(connected()), SLOT(connectionMade()));
+    connect(&m_clientSocket, SIGNAL(readyRead()), SLOT(readFromServer()));
+    connect(&m_clientSocket, SIGNAL(disconnected()),
+            SLOT(OnMTDConnectionDisconnected()));
+}
+
+DVDRipBox::~DVDRipBox()
+{
+    while (!m_jobs.isEmpty())
+        delete m_jobs.takeFirst();
+
+    m_jobs.clear();
+}
+
+bool DVDRipBox::Create()
+{
+    if (!LoadWindowFromXML("dvd-ui.xml", "dvd_rip", this))
+        return false;
+
+    bool err = false;
+    UIUtilE::Assign(this, m_warningText, "warning", &err);
+    UIUtilE::Assign(this, m_overallText, "overall_text", &err);
+    UIUtilE::Assign(this, m_jobText, "job_text", &err);
+    UIUtilE::Assign(this, m_numjobsText, "numbjobs", &err);
+
+    UIUtilE::Assign(this, m_overallProgress, "overall_progress", &err);
+    UIUtilE::Assign(this, m_jobProgress, "job_progress", &err);
+
+    UIUtilE::Assign(this, m_ripscreenButton, "ripscreen", &err);
+    UIUtilE::Assign(this, m_cancelButton, "cancel", &err);
+
+    UIUtilE::Assign(this, m_nextjobButton, "next", &err);
+    UIUtilE::Assign(this, m_prevjobButton, "prev", &err);
+
+    if (err)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Cannot load screen 'dvd_rip'");
+        return false;
+    }
+
+    connect(m_ripscreenButton, SIGNAL(Clicked()), SLOT(goRipScreen()));
+    connect(m_cancelButton, SIGNAL(Clicked()), SLOT(cancelJob()));
+    connect(m_nextjobButton, SIGNAL(Clicked()), SLOT(nextJob()));
+    connect(m_prevjobButton, SIGNAL(Clicked()), SLOT(prevJob()));
+
+    m_ripscreenButton->SetText(tr("New Rip"));
+    m_cancelButton->SetText(tr("Cancel Job"));
+    m_overallProgress->SetTotal(1000);
+    m_jobProgress->SetTotal(1000);
+
+    m_cancelButton->SetVisible(false);
+    m_ripscreenButton->SetVisible(false);
+    m_nextjobButton->SetVisible(false);
+    m_prevjobButton->SetVisible(false);
+    m_overallProgress->SetVisible(false);
+    m_jobProgress->SetVisible(false);
+    m_overallText->SetVisible(false);
+    m_jobText->SetVisible(false);
+
+    BuildFocusList();
+
+    Init();
+
+    return true;
+}
+
+void DVDRipBox::Init()
+{
+    if (m_inited)
+        return;
+    m_inited = true;
+
+    ConnectToMTD();
+
+    //  Create (but do not open) the DVD probing object
+    //  and then ask a thread to check it for us. Make a
+    //  timer to query whether the thread is done or not
+
+    connect(&m_discCheckingTimer, SIGNAL(timeout()), SLOT(checkDisc()));
+    m_discCheckingTimer.start(600);
+}
+
+void DVDRipBox::checkDisc()
+{
+    if (!m_connected)
+        return;
+
+    if(m_blockMediaRequests)
+        return;
+
+    if(m_haveDisc)
+    {
+        m_ripscreenButton->SetVisible(true);
+
+        if(!m_firstDiscFound)
+        {
+            m_firstDiscFound = true;
+
+            m_discCheckingTimer.setInterval(4000);
+        }
+
+    }
+    else
+        m_ripscreenButton->SetVisible(false);
+
+    sendToServer("media");
+}
+
+void DVDRipBox::OnMTDConnectionDisconnected()
+{
+    m_connected = false;
+
+    stopStatusPolling();
+    m_context = RIPSTATE_UNKNOWN;
+    m_haveDisc = false;
+
+    adjustJobs(0);
+    showCurrentJob();
+
+    m_ripscreenButton->SetCanTakeFocus(false);
+    m_cancelButton->SetCanTakeFocus(false);
+
+    QString warning = tr("Your connection to the Myth "
+                         "Transcoding Daemon has gone "
+                         "away. This is not a good thing.");
+    m_warningText->SetText(warning);
+}
+
+void DVDRipBox::ConnectToMTD(void)
+{
+    if (!m_connected)
+        m_clientSocket.connectToHost("localhost", m_mtdPort);
+}
+
+void DVDRipBox::OnConnectionError(QAbstractSocket::SocketError error_id)
+{
+    m_context = RIPSTATE_NOCONNECT;
+
+    switch (error_id)
+    {
+        case QAbstractSocket::ConnectionRefusedError:
+        {
+            LOG(VB_GENERAL, LOG_ERR, "DVDRipBox::ConnectionRefusedError");
+            if (!m_triedMTDLaunch)
+            {
+                m_triedMTDLaunch = true;
+                LaunchMTD *tmp = LaunchMTD::Create();
+                connect(tmp, SIGNAL(SigLaunchAttemptComplete()),
+                        SLOT(OnMTDLaunchAttemptComplete()));
+
+                m_warningText->SetText(tr("Attempting to launch mtd..."));
+            }
+            else
+            {
+                m_warningText->SetText(tr("Cannot connect to your Myth "
+                                "Transcoding Daemon."));
+            }
+
+            break;
+        }
+        case QAbstractSocket::HostNotFoundError:
+        {
+            LOG(VB_GENERAL, LOG_ERR, "DVDRipBox::HostNotFoundError");
+            m_warningText->SetText(tr("Attempting to connect to your mtd said "
+                            "host not found. Unable to recover."));
+            break;
+        }
+        default:
+        {
+            LOG(VB_GENERAL, LOG_ERR, "DVDRipBox::OnConnectionError");
+            m_warningText->SetText(tr("Unknown connection error."));
+            break;
+        }
+    }
+}
+
+void DVDRipBox::connectionMade()
+{
+    m_context = RIPSTATE_NOJOBS;
+    m_connected = true;
+    sendToServer("hello");
+    sendToServer("use dvd " + m_device);
+}
+
+void DVDRipBox::readFromServer()
+{
+    while (m_clientSocket.canReadLine())
+    {
+        QString line_from_server =
+                QString::fromUtf8(m_clientSocket.readLine());
+        line_from_server = line_from_server.replace( QRegExp("\n"), "" );
+        line_from_server = line_from_server.replace( QRegExp("\r"), "" );
+        line_from_server.simplified();
+
+        QStringList tokens = line_from_server.split(" ", QString::SkipEmptyParts);
+        if(tokens.count() > 0)
+        {
+            parseTokens(tokens);
+        }
+    }
+}
+
+void DVDRipBox::sendToServer(const QString &some_text)
+{
+    if (m_connected)
+    {
+        QTextStream os(&m_clientSocket);
+        os << some_text << "\n";
+    }
+    else
+    {
+        LOG(VB_GENERAL, LOG_ERR,
+                QString("dvdripbox.o: was asked to send the following text "
+                        "while not m_connected: \"%1\"").arg(some_text));
+    }
+}
+
+void DVDRipBox::parseTokens(QStringList tokens)
+{
+    if(tokens[0] == "greetings")
+    {
+        startStatusPolling();
+    }
+    if(tokens[0] == "status")
+    {
+        handleStatus(tokens);
+    }
+    if(tokens[0] == "media")
+    {
+        handleMedia(tokens);
+    }
+}
+
+void DVDRipBox::startStatusPolling()
+{
+    m_statusTimer.start(1000);
+}
+
+void DVDRipBox::stopStatusPolling()
+{
+    m_statusTimer.stop();
+}
+
+void DVDRipBox::pollStatus()
+{
+    //
+    //  Ask the server to send us more data
+    //
+
+    sendToServer("status");
+
+}
+
+void DVDRipBox::nextJob()
+{
+    if(m_currentJob + 1 < (int) m_jobCount)
+    {
+        m_currentJob++;
+    }
+    showCurrentJob();
+}
+
+void DVDRipBox::prevJob()
+{
+    if(m_currentJob > 0)
+    {
+        m_currentJob--;
+    }
+    showCurrentJob();
+}
+
+void DVDRipBox::goToJob(int which_job)
+{
+    which_job--;
+    if(which_job > -1 &&
+       which_job < (int) m_jobCount)
+    {
+        m_currentJob = which_job;
+        showCurrentJob();
+    }
+}
+
+void DVDRipBox::showCurrentJob()
+{
+    if(m_currentJob < 0)
+    {
+        m_numjobsText->SetText("");
+        return;
+    }
+
+    bool buildfocus = false;
+
+    if(m_currentJob > 0 && !m_prevjobButton->IsVisible())
+    {
+        m_prevjobButton->SetVisible(true);
+        buildfocus = true;
+    }
+    else if ((m_jobCount == 1 || m_currentJob == 0)
+                              && m_prevjobButton->IsVisible())
+    {
+        m_prevjobButton->SetVisible(false);
+        buildfocus = true;
+    }
+
+    if (m_jobCount > 1 && m_currentJob+1 < (int)m_jobCount
+                       && !m_nextjobButton->IsVisible())
+    {
+        m_nextjobButton->SetVisible(true);
+        buildfocus = true;
+    }
+    else if ((m_jobCount == 1 || m_currentJob+1 == (int)m_jobCount)
+                              && m_nextjobButton->IsVisible())
+    {
+        m_nextjobButton->SetVisible(false);
+        buildfocus = true;
+    }
+
+    if (buildfocus)
+        BuildFocusList();
+
+    MTDJob *a_job = m_jobs.at((uint)m_currentJob);
+
+    if(a_job)
+    {
+        m_overallText->SetVisible(true);
+        m_jobText->SetVisible(true);
+        m_overallProgress->SetVisible(true);
+        m_jobProgress->SetVisible(true);
+
+        m_overallText->SetText(a_job->getName());
+        m_jobText->SetText(a_job->getActivity());
+
+        int an_int = (int) (a_job->getOverall() * 1000);
+        m_overallProgress->SetUsed(an_int);
+
+        an_int = (int) (a_job->getSubjob() * 1000);
+        m_jobProgress->SetUsed(an_int);
+
+        m_numjobsText->SetText(tr("Job %1 of %2").arg(m_currentJob + 1)
+                .arg(m_jobCount));
+    }
+}
+
+void DVDRipBox::handleStatus(QStringList tokens)
+{
+    //
+    //  Initial sanity checking
+    //
+
+    if(tokens.count() < 3)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "dvdripbox.o: I got an mtd status update with a bad number of tokens");
+        return;
+    }
+
+    if(tokens[1] != "dvd")
+    {
+        //
+        //  This is not a DVD related mtd job (someone ripping a CD?)
+        //
+
+        return;
+    }
+
+    if(tokens[2] == "complete")
+    {
+        //
+        //  All jobs have been updated
+        //
+        showCurrentJob();
+
+        if (m_context < RIPSTATE_HAVEJOBS)
+        {
+            if(tokens.count() >= 4)
+            {
+                QString msg = tokens[3];
+                for (int i = 4; i < tokens.count(); ++i)
+                    msg += " " + tokens[i];
+                m_warningText->SetText(msg);
+            }
+            else if(m_haveDisc)
+                m_warningText->SetText(tr("No jobs and nothing else to do. You could rip a DVD."));
+            else
+                m_warningText->SetText(tr("No Jobs. Checking and/or waiting for DVD."));
+        }
+
+        return;
+    }
+
+    if(tokens[2] == "summary")
+    {
+        if(tokens.count() < 4)
+        {
+            LOG(VB_GENERAL, LOG_ERR, "dvdripbox: wrong number of tokens on a DVD job.");
+            return;
+        }
+
+        //
+        //  Summary statistic, which should tell us
+        //  how many jobs there are
+        //
+
+        if(tokens[3].toUInt() != m_jobCount)
+            adjustJobs(tokens[3].toUInt());
+
+        if (RIPSTATE_HAVEJOBS == m_context)
+        {
+            if (tokens[3].toInt() == 0)
+            {
+                m_nextjobButton->SetVisible(false);
+                m_prevjobButton->SetVisible(false);
+                m_cancelButton->SetVisible(false);
+
+                BuildFocusList();
+
+                m_overallProgress->SetVisible(false);
+                m_jobProgress->SetVisible(false);
+                m_overallText->SetVisible(false);
+                m_jobText->SetVisible(false);
+
+                m_context = RIPSTATE_NOJOBS;
+            }
+        }
+        //  if we got called, and we are still in context 0,
+        //  and there are no jobs, switch to context 2. If
+        //  there are jobs, switch to context 1 (as long as
+        //  we're not already in context 2).
+        else if (tokens[3].toInt() > 0)
+        {
+            m_cancelButton->SetCanTakeFocus(true);
+            m_context = RIPSTATE_HAVEJOBS;
+            m_warningText->SetText("");
+            m_cancelButton->SetVisible(true);
+        }
+        else
+        {
+            m_cancelButton->SetVisible(false);
+            m_context = RIPSTATE_NOJOBS;
+            if(m_haveDisc && m_firstRun)
+            {
+                m_firstRun = false;
+                goRipScreen();
+            }
+        }
+    }
+    else if (tokens[2] == "job")
+    {
+        // Part of DVD job
+        if (m_context < RIPSTATE_HAVEJOBS)
+        {
+            m_cancelButton->SetCanTakeFocus(true);
+            m_context = RIPSTATE_HAVEJOBS;
+            m_warningText->SetText("");
+            m_cancelButton->SetVisible(true);
+        }
+
+        if(tokens.count() < 6)
+        {
+            LOG(VB_GENERAL, LOG_ERR, "dvdripbox: wrong number of tokens on a DVD job.");
+            return;
+        }
+
+        if(tokens[4] == "overall")
+        {
+            QString title = "";
+            for(QStringList::size_type i = 6; i < tokens.count(); i++)
+            {
+                title.append(tokens[i]);
+                if(i != tokens.count() - 1)
+                {
+                    title.append(" ");
+                }
+            }
+            setOverallJobStatus(tokens[3].toInt(), tokens[5].toDouble(), title);
+        }
+        else if(tokens[4] == "subjob")
+        {
+            QString subjob_string = "";
+            for(QStringList::size_type i = 6; i < tokens.count(); i++)
+            {
+                subjob_string.append(tokens[i]);
+                if(i != tokens.count() - 1)
+                {
+                    subjob_string.append(" ");
+                }
+            }
+            setSubJobStatus(tokens[3].toInt(), tokens[5].toDouble(), subjob_string);
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_ERR, QString("dvdripbox: Unknown DVD job: %1").
+                arg(tokens[4]));
+        }
+    }
+    else
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("dvdripbox: Unrecognized mtd status: %1").
+            arg(tokens.join(" ")));
+    }
+}
+
+void DVDRipBox::handleMedia(QStringList tokens)
+{
+    //
+    //  Initial sanity checking
+    //
+
+    if(tokens.count() < 3)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "dvdripbox.o: I got an mtd media update with a bad number of tokens");
+        return;
+    }
+
+    if(tokens[1] != "dvd")
+    {
+        //
+        //  This is not a DVD related mtd job (someone ripping a CD?)
+        //
+
+        return;
+    }
+
+
+    if(tokens[2] == "complete")
+    {
+        m_blockMediaRequests = false;
+        if(m_dvdInfo)
+        {
+            if(m_dvdInfo->getTitles()->count() > 0)
+            {
+                m_haveDisc = true;
+                m_ripscreenButton->SetCanTakeFocus(true);
+            }
+            else
+            {
+                m_haveDisc = false;
+                m_ripscreenButton->SetCanTakeFocus(false);
+            }
+        }
+        return;
+    }
+    else if(tokens[2] == "summary")
+    {
+        m_blockMediaRequests = true;
+        if(m_dvdInfo)
+        {
+            delete m_dvdInfo;
+            m_dvdInfo = NULL;
+        }
+        if(tokens[3].toUInt() > 0)
+        {
+            QString disc_name = "";
+            for(QStringList::size_type i = 4; i < tokens.count(); i++)
+            {
+                disc_name += tokens[i];
+                if(i < tokens.count() - 1)
+                {
+                    disc_name += " ";
+                }
+            }
+            m_dvdInfo = new DVDVolInfo(disc_name);
+        }
+        else
+        {
+            m_haveDisc = false;
+            m_ripscreenButton->SetCanTakeFocus(false);
+        }
+        return;
+    }
+    else if(tokens[2] == "title")
+    {
+        if(tokens.count() != 10)
+        {
+            LOG(VB_GENERAL, LOG_ERR, "dvdripbox.o: Got wrong number of tokens in media title report.");
+            return;
+        }
+        else
+        {
+            DVDTitleInfo *new_title = new DVDTitleInfo();
+            new_title->setTrack(tokens[3].toUInt());
+            new_title->setChapters(tokens[4].toUInt());
+            new_title->setAngles(tokens[5].toUInt());
+            new_title->setTime(tokens[6].toUInt(), tokens[7].toUInt(), tokens[8].toUInt());
+            new_title->setInputID(tokens[9].toUInt());
+            m_dvdInfo->addTitle(new_title);
+        }
+        return;
+    }
+    else if(tokens[2] == "title-audio")
+    {
+        DVDTitleInfo *which_title = m_dvdInfo->getTitle(tokens[3].toUInt());
+        if(!which_title)
+        {
+            LOG(VB_GENERAL, LOG_ERR, "dvdripbox.o: Asked to add an audio track for a title that doesn't exist");
+            return;
+        }
+
+        QString audio_string = "";
+        for(QStringList::size_type i = 6; i < tokens.count(); i++)
+        {
+            audio_string += tokens[i];
+            if(i < tokens.count() - 1)
+            {
+                audio_string += " ";
+            }
+        }
+
+        DVDAudioInfo *new_audio = new DVDAudioInfo(tokens[4].toUInt() + 1, audio_string);
+        new_audio->setChannels(tokens[5].toInt());
+        which_title->addAudio(new_audio);
+    }
+    else if(tokens[2] == "title-subtitle")
+    {
+        DVDTitleInfo *which_title = m_dvdInfo->getTitle(tokens[3].toUInt());
+        if(!which_title)
+        {
+            LOG(VB_GENERAL, LOG_ERR, "dvdripbox.o: Asked to add a subtitle for a title that doesn't exist");
+            return;
+        }
+
+        QString name_string = "";
+        for(QStringList::size_type i = 6; i < tokens.count(); i++)
+        {
+            name_string += tokens[i];
+            if(i < tokens.count() - 1)
+            {
+                name_string += " ";
+            }
+        }
+        DVDSubTitleInfo *new_subtitle = new DVDSubTitleInfo(tokens[4].toInt(), name_string);
+        which_title->addSubTitle(new_subtitle);
+    }
+
+}
+
+void DVDRipBox::setOverallJobStatus(int job_number, double status, QString title)
+{
+    if(job_number + 1 > (int) m_jobs.count())
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString(
+                "dvdripbox.o: mtd job summary didn't tell us the right number of jobs\n"
+                "             (int) m_jobs.count() is %1\n"
+                "             requested job_number was %2")
+                .arg((int) m_jobs.count())
+                .arg(job_number));
+    }
+    else
+    {
+        MTDJob *which_one = m_jobs.at(job_number);
+        which_one->SetName(title);
+        which_one->setOverall(status);
+        which_one->setNumber(job_number);
+    }
+}
+
+void DVDRipBox::setSubJobStatus(int job_number, double status, QString subjob_string)
+{
+    if(job_number + 1 > (int) m_jobs.count())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "dvdripbox.o: mtd job summary didn't tell us the right number of m_jobs. The Bastard!");
+    }
+    else
+    {
+        MTDJob *which_one = m_jobs.at(job_number);
+        which_one->setActivity(subjob_string);
+        which_one->setSubjob(status);
+    }
+}
+
+void DVDRipBox::adjustJobs(uint new_number)
+{
+    while (m_jobs.count() < (int)new_number)
+    {
+        MTDJob *new_one = new MTDJob("I am a job");
+        connect(new_one, SIGNAL(toggledCancelled()), SLOT(toggleCancel()));
+        m_jobs.append(new_one);
+    }
+
+    while (m_jobs.count() > (int)new_number)
+        m_jobs.removeLast();
+
+    if (m_currentJob >= (int)new_number)
+        m_currentJob = new_number - 1;
+    else if (m_currentJob < 0 && new_number > 0)
+        m_currentJob = 0;
+
+    m_jobCount = new_number;
+    if(m_jobCount == 0)
+    {
+        if(m_ignoreCancels)
+        {
+            toggleCancel();
+        }
+    }
+}
+
+void DVDRipBox::goRipScreen()
+{
+    m_warningText->SetText("");
+    stopStatusPolling();
+    m_blockMediaRequests = true;
+    m_clientSocket.readAll(); // Flush input
+
+    MythScreenStack *screenStack = GetScreenStack();
+
+    TitleDialog *title_dialog = new TitleDialog(screenStack, "title dialog",
+                                                &m_clientSocket,
+                                                m_dvdInfo->getName(),
+                                                m_dvdInfo->getTitles());
+
+    if (title_dialog->Create())
+        screenStack->AddScreen(title_dialog);
+
+    connect(title_dialog, SIGNAL(Exiting()), SLOT(ExitingRipScreen()));
+}
+
+void DVDRipBox::ExitingRipScreen()
+{
+    m_clientSocket.readAll(); // Flush input
+    m_blockMediaRequests = false;
+    m_warningText->SetText("");
+    showCurrentJob();
+    pollStatus();
+    startStatusPolling();
+}
+
+void DVDRipBox::OnMTDLaunchAttemptComplete()
+{
+    ConnectToMTD();
+}
+
+void DVDRipBox::cancelJob()
+{
+    if( m_currentJob > -1 &&
+        m_currentJob < (int) m_jobs.count() &&
+        !m_ignoreCancels)
+    {
+        MTDJob *a_job = m_jobs.at(m_currentJob);
+        if(a_job->getNumber() >= 0)
+        {
+            m_ignoreCancels = true;
+            stopStatusPolling();
+            sendToServer(QString("abort dvd job %1").arg(a_job->getNumber()));
+            qApp->processEvents();
+            a_job->setSubjob(0.0);
+            a_job->setActivity(tr("Cancelling ..."));
+            a_job->setCancelled(true);
+            showCurrentJob();
+            startStatusPolling();
+        }
+    }
+}
+
+void DVDRipBox::toggleCancel()
+{
+    m_ignoreCancels = false;
+}
+
+#include "dvdripbox.moc"
diff --git a/mythtv/programs/mythfrontend/dvdripbox.h b/mythtv/programs/mythfrontend/dvdripbox.h
new file mode 100644
index 0000000..2b1147e
--- /dev/null
+++ b/mythtv/programs/mythfrontend/dvdripbox.h
@@ -0,0 +1,126 @@
+#ifndef DVDRIPBOX_H_
+#define DVDRIPBOX_H_
+
+#include <QStringList>
+#include <QTimer>
+#include <QTcpSocket>
+
+#include <mythscreentype.h>
+
+#include "dvdinfo.h"
+
+class MythUIButton;
+class MythUIText;
+class MythUIProgressBar;
+
+class MTDJob : public QObject
+{
+    Q_OBJECT
+
+  public:
+    MTDJob();
+    MTDJob(QString lname);
+
+    void setNumber(int a_number) { job_number = a_number; }
+    void SetName(const QString &a_name);
+    void setActivity(const QString &an_act);
+    void setOverall(double a_number) { overall_progress = a_number; }
+    void setSubjob(double a_number);
+    void setCancelled(bool yes_or_no) { cancelled = yes_or_no; }
+
+    int     getNumber() { return job_number; }
+    QString getName() { return job_name; }
+    QString getActivity() { return current_activity; }
+    double  getOverall() { return overall_progress; }
+    double  getSubjob() { return subjob_progress; }
+
+  signals:
+    void    toggledCancelled();
+
+  private:
+    int      job_number;
+    QString  job_name;
+    QString  current_activity;
+    double   overall_progress;
+    double   subjob_progress;
+    bool     cancelled;
+};
+
+class DVDRipBox : public MythScreenType
+{
+    Q_OBJECT
+
+  public:
+    DVDRipBox(MythScreenStack *lparent, QString lname, QString dev);
+    ~DVDRipBox();
+
+    bool Create();
+
+    void ConnectToMTD(void);
+
+    enum RipState { RIPSTATE_UNKNOWN = 0, RIPSTATE_NOCONNECT, RIPSTATE_NOJOBS,
+        RIPSTATE_HAVEJOBS };
+
+  private slots:
+    void OnConnectionError(QAbstractSocket::SocketError error_id);
+    void connectionMade();
+    void OnMTDConnectionDisconnected();
+    void readFromServer();
+    void parseTokens(QStringList tokens);
+    void sendToServer(const QString &some_text);
+    void startStatusPolling();
+    void stopStatusPolling();
+    void pollStatus();
+    void handleStatus(QStringList tokens);
+    void handleMedia(QStringList tokens);
+    void setOverallJobStatus(int job_number, double status, QString title);
+    void setSubJobStatus(int job_number, double status, QString subjob_string);
+    void adjustJobs(uint new_number);
+    void nextJob();
+    void prevJob();
+    void goToJob(int which_job);
+    void showCurrentJob();
+    void goRipScreen();
+    void checkDisc();
+    void cancelJob();
+    void toggleCancel();
+    void ExitingRipScreen();
+
+    void OnMTDLaunchAttemptComplete();
+
+  private:
+    void Init();
+
+    uint             m_mtdPort;
+    QTcpSocket       m_clientSocket;
+    QTimer           m_statusTimer;
+    bool             m_triedMTDLaunch;
+    bool             m_connected;
+    bool             m_firstRun;
+    bool             m_haveDisc;
+    bool             m_firstDiscFound;
+    bool             m_blockMediaRequests;
+    QList<MTDJob*>    m_jobs;
+    uint             m_jobCount;
+    int              m_currentJob;
+    bool             m_ignoreCancels;
+    RipState         m_context;
+    bool             m_inited;
+
+    QString          m_device;       ///> The most recent usable DVD drive
+    DVDVolInfo       *m_dvdInfo;
+    QTimer           m_discCheckingTimer;
+
+    MythUIText        *m_warningText;
+    MythUIText        *m_overallText;
+    MythUIText        *m_jobText;
+    MythUIText        *m_numjobsText;
+    MythUIProgressBar *m_overallProgress;
+    MythUIProgressBar *m_jobProgress;
+    MythUIButton      *m_ripscreenButton;
+    MythUIButton      *m_cancelButton;
+    MythUIButton      *m_nextjobButton;
+    MythUIButton      *m_prevjobButton;
+};
+
+#endif
diff --git a/mythtv/programs/mythfrontend/main.cpp b/mythtv/programs/mythfrontend/main.cpp
index d923a28..934941a 100644
--- a/mythtv/programs/mythfrontend/main.cpp
+++ b/mythtv/programs/mythfrontend/main.cpp
@@ -87,6 +87,7 @@ using namespace std;
 #include "videoplayersettings.h"
 #include "videometadatasettings.h"
 #include "videolist.h"
+#include "dvdripbox.h"
 
 // DVD
 #include "DVD/dvdringbuffer.h"
@@ -661,6 +662,35 @@ static void jumpScreenVideoTree()    { RunVideoScreen(VideoDialog::DLG_TREE, tru
 static void jumpScreenVideoGallery() { RunVideoScreen(VideoDialog::DLG_GALLERY, true); }
 static void jumpScreenVideoDefault() { RunVideoScreen(VideoDialog::DLG_DEFAULT, true); }
 
+QString gDVDdevice;
+
+static void startDVDRipper()
+{
+    // MTD could check this and log an error,
+    // but informing the user here/now is probably better
+    QString ripDir = gCoreContext->GetSetting("DVDRipLocation");
+    if (ripDir.length() && !QDir(ripDir).exists())
+        ShowOkPopup(QObject::tr("No directory %1 - DVD importing will fail")
+                    .arg(ripDir));
+
+    QString dvd_device = gDVDdevice;
+
+    if (dvd_device.isEmpty())
+        dvd_device = MediaMonitor::defaultDVDdevice();
+
+#ifdef Q_OS_MAC
+    // Convert the BSD 'leaf' name to a raw device in /dev
+    dvd_device.prepend("/dev/r");
+#endif
+
+    MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
+
+    DVDRipBox *mythdvdrip = new DVDRipBox(mainStack, "ripdvd", dvd_device);
+
+    if (mythdvdrip->Create())
+        mainStack->AddScreen(mythdvdrip);
+}
+
 static void playDisc()
 {
     //
@@ -767,6 +797,9 @@ static void handleDVDMedia(MythMediaDevice *dvd)
             GetMythMainWindow()->JumpTo("Main Menu");
             playDisc();
             break;
+        case 3 : //Rip DVD
+            startDVDRipper();
+            break;
         default:
             LOG(VB_GENERAL, LOG_ERR,
                 "mythdvd main.o: handleMedia() does not know what to do");
@@ -984,6 +1017,11 @@ static void TVMenuCallback(void *data, QString &selection)
         if (fa->Create())
             mainStack->AddScreen(fa);
     }
+    else if (sel == "dvd_settings_rip")
+    {
+        DVDRipperSettings settings;
+        settings.exec();
+    }
     else if (sel == "manager")
         RunVideoScreen(VideoDialog::DLG_MANAGER);
     else if (sel == "browser")
@@ -996,6 +1034,10 @@ static void TVMenuCallback(void *data, QString &selection)
     {
         playDisc();
     }
+    else if (sel == "dvd_rip")
+    {
+        startDVDRipper();
+    }
     else if (sel == "tv_status")
         showStatus();
     else if (sel == "exiting_app_prompt")
@@ -1085,6 +1127,9 @@ static void WriteDefaults()
     VideoGeneralSettings vgs;
     vgs.Load();
     vgs.Save();
+    DVDRipperSettings rsettings;
+    rsettings.Load();
+    rsettings.Save();
 }
 
 static int internal_play_media(const QString &mrl, const QString &plot,
@@ -1329,6 +1374,8 @@ static void InitJumpPoints(void)
          "The Video Gallery"), "", jumpScreenVideoGallery);
      REG_JUMP("Play Disc", QT_TRANSLATE_NOOP("MythControls",
          "Play an Optical Disc"), "", playDisc);
+     REG_JUMP("Rip DVD", QT_TRANSLATE_NOOP("MythControls",
+         "Import a DVD into your MythVideo database"), "", startDVDRipper);
 
      REG_JUMPEX(QT_TRANSLATE_NOOP("MythControls", "Toggle Show Widget Borders"),
          "", "", setDebugShowBorders, false);
diff --git a/mythtv/programs/mythfrontend/mythfrontend.pro b/mythtv/programs/mythfrontend/mythfrontend.pro
index 6ec06e3..760b0a2 100644
--- a/mythtv/programs/mythfrontend/mythfrontend.pro
+++ b/mythtv/programs/mythfrontend/mythfrontend.pro
@@ -41,6 +41,9 @@ HEADERS += videoplayersettings.h        videodlg.h
 HEADERS += videoglobalsettings.h        upnpscanner.h
 HEADERS += commandlineparser.h          idlescreen.h
 
+#MythDVD
+HEADERS += dvdripbox.h dvdinfo.h titledialog.h
+
 SOURCES += main.cpp playbackbox.cpp viewscheduled.cpp audiogeneralsettings.cpp
 SOURCES += globalsettings.cpp manualschedule.cpp programrecpriority.cpp
 SOURCES += channelrecpriority.cpp statusbox.cpp networkcontrol.cpp
@@ -66,6 +69,9 @@ HEADERS += serviceHosts/frontendServiceHost.h
 HEADERS += services/frontend.h
 SOURCES += services/frontend.cpp
 
+#MythDVD
+SOURCES += dvdripbox.cpp dvdinfo.cpp titledialog.cpp
+
 macx {
     mac_bundle {
         CONFIG -= console  # Force behaviour of producing .app bundle
diff --git a/mythtv/programs/mythfrontend/titledialog.cpp b/mythtv/programs/mythfrontend/titledialog.cpp
new file mode 100644
index 0000000..8a5ccd1
--- /dev/null
+++ b/mythtv/programs/mythfrontend/titledialog.cpp
@@ -0,0 +1,421 @@
+#include <QRegExp>
+
+#include <QTcpSocket>
+
+#include <mythmiscutil.h>
+#include <mythcontext.h>
+#include <mythmediamonitor.h>
+
+#include <mythuitext.h>
+#include <mythuitextedit.h>
+#include <mythuibutton.h>
+#include <mythuibuttonlist.h>
+#include <mythuicheckbox.h>
+#include <mythsystem.h>
+
+#include "libmythmetadata/videoutils.h"
+#include "titledialog.h"
+
+TitleDialog::TitleDialog(MythScreenStack *lparent, QString lname,
+        QTcpSocket *a_socket, QString d_name, QList<DVDTitleInfo*> *titles) :
+    MythScreenType(lparent, lname), m_discName(d_name), m_dvdTitles(titles),
+    m_currentTitle(0), m_socketToMtd(a_socket), m_nameEdit(0),
+    m_audioList(0), m_qualityList(0), m_subtitleList(0),
+    m_ripCheck(0), m_ripacthreeCheck(0), m_playlengthText(0),
+    m_numbtitlesText(0), m_viewButton(0), m_nexttitleButton(0),
+    m_prevtitleButton(0), m_ripawayButton(0)
+{
+    if(m_discName.length() < 1)
+        m_discName = tr("Unknown");
+
+    //
+    //  Find the longest title and set some defaults
+    //
+
+    uint longest = 0;
+    uint longest_time = 0;
+
+    for(int i = 0; i < m_dvdTitles->size(); i++)
+    {
+        if(m_dvdTitles->at(i)->getPlayLength() >= longest_time)
+        {
+            longest = i;
+            longest_time = m_dvdTitles->at(i)->getPlayLength();
+            m_currentTitle = m_dvdTitles->at(i);
+        }
+    }
+
+    for(int i = 0; i < m_dvdTitles->size(); i++)
+    {
+        if(m_dvdTitles->at(i) == m_currentTitle)
+        {
+            m_dvdTitles->at(i)->setName(m_discName);
+            m_dvdTitles->at(i)->setSelected(true);
+        }
+        else
+        {
+            m_dvdTitles->at(i)->setName(QString(tr("%1 - Title %2"))
+                    .arg(m_discName).arg(i + 1));
+        }
+    }
+}
+
+bool TitleDialog::Create()
+{
+    if (!LoadWindowFromXML("dvd-ui.xml", "title_dialog", this))
+        return false;
+
+    bool err = false;
+    UIUtilE::Assign(this, m_nameEdit, "name", &err);
+
+    UIUtilE::Assign(this, m_playlengthText, "playlength", &err);
+    UIUtilE::Assign(this, m_numbtitlesText, "numb_titles", &err);
+
+    UIUtilE::Assign(this, m_ripCheck, "ripcheck", &err);
+    UIUtilE::Assign(this, m_ripacthreeCheck, "ripacthree", &err);
+
+    UIUtilE::Assign(this, m_nexttitleButton, "next_title", &err);
+    UIUtilE::Assign(this, m_prevtitleButton, "prev_title", &err);
+    UIUtilE::Assign(this, m_viewButton, "view", &err);
+    UIUtilE::Assign(this, m_ripawayButton, "ripaway", &err);
+
+    UIUtilE::Assign(this, m_audioList, "audio", &err);
+    UIUtilE::Assign(this, m_qualityList, "quality", &err);
+    UIUtilE::Assign(this, m_subtitleList, "subtitle", &err);
+
+    if (err)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Cannot load screen 'title_dialog'");
+        return false;
+    }
+
+    if (m_dvdTitles->size() > 1)
+    {
+        m_nexttitleButton->SetVisible(true);
+        m_prevtitleButton->SetVisible(true);
+    }
+    else
+    {
+        m_nexttitleButton->SetVisible(false);
+        m_prevtitleButton->SetVisible(false);
+    }
+
+    m_ripawayButton->SetText(tr("Begin Ripping"));
+
+    BuildFocusList();
+
+    showCurrentTitle();
+
+    connect(m_nameEdit, SIGNAL(valueChanged()), SLOT(changeName()));
+
+    connect(m_audioList, SIGNAL(itemSelected(MythUIButtonListItem*)),
+            SLOT(setAudio(MythUIButtonListItem*)));
+    connect(m_qualityList, SIGNAL(itemSelected(MythUIButtonListItem*)),
+            SLOT(setQuality(MythUIButtonListItem*)));
+    connect(m_subtitleList, SIGNAL(itemSelected(MythUIButtonListItem*)),
+            SLOT(setSubTitle(MythUIButtonListItem*)));
+
+    connect(m_ripacthreeCheck, SIGNAL(valueChanged()), SLOT(toggleAC3()));
+    connect(m_ripCheck, SIGNAL(valueChanged()), SLOT(toggleTitle()));
+
+    connect(m_ripawayButton, SIGNAL(Clicked()), SLOT(ripTitles()));
+    connect(m_viewButton, SIGNAL(Clicked()), SLOT(viewTitle()));
+    connect(m_nexttitleButton, SIGNAL(Clicked()), SLOT(nextTitle()));
+    connect(m_prevtitleButton, SIGNAL(Clicked()), SLOT(prevTitle()));
+
+    return true;
+}
+
+void TitleDialog::showCurrentTitle()
+{
+    //
+    //  Set the widget to display correct info
+    //
+    if(m_currentTitle)
+    {
+        //
+        //  We have to if() check everything, in case the
+        //  theme designer left things out.
+        //
+
+        m_playlengthText->SetText(m_currentTitle->getTimeString());
+
+        if (m_currentTitle->getSelected())
+            m_ripCheck->SetCheckState(MythUIStateType::Full);
+        else
+            m_ripCheck->SetCheckState(MythUIStateType::Off);
+
+        m_nameEdit->SetText(m_currentTitle->getName());
+
+        // NB preserve audio state across MythUIButtonList::Reset()
+        int audio = m_currentTitle->getAudio();
+        m_audioList->Reset();
+        QList<DVDAudioInfo*> *audio_tracks = m_currentTitle->getAudioTracks();
+        for(int j = 0; j < audio_tracks->size(); j++)
+        {
+            new MythUIButtonListItem(m_audioList,
+                                audio_tracks->at(j)->getAudioString(), j + 1);
+        }
+        m_audioList->SetValueByData(audio);
+
+        int quality = m_currentTitle->getQuality();
+        m_qualityList->Reset();
+        new MythUIButtonListItem(m_qualityList, tr("ISO Image"),
+                                    qVariantFromValue(-1));
+        new MythUIButtonListItem(m_qualityList, tr("Perfect"),
+                                    qVariantFromValue(0));
+        QString q_string = QString("SELECT name,intid FROM dvdtranscode "
+                                    "WHERE input = %1 ;")
+                                    .arg(m_currentTitle->getInputID());
+
+        MSqlQuery a_query(MSqlQuery::InitCon());
+
+        if(a_query.exec(q_string))
+        {
+            while(a_query.next())
+            {
+                new MythUIButtonListItem(m_qualityList,
+                    a_query.value(0).toString(), a_query.value(1).toInt());
+            }
+        }
+        m_qualityList->SetValueByData(quality);
+
+        int subtitle = m_currentTitle->getSubTitle();
+        m_subtitleList->Reset();
+        new MythUIButtonListItem(m_subtitleList, tr("None"), -1);
+        QList<DVDSubTitleInfo*> *subtitles = m_currentTitle->getSubTitles();
+        for(int j = 0; j < subtitles->size(); ++j)
+        {
+            new MythUIButtonListItem(m_subtitleList, subtitles->at(j)->getName(),
+                                   subtitles->at(j)->getID());
+        }
+        m_subtitleList->SetValueByData(subtitle);
+
+        if (m_currentTitle->getAC3())
+            m_ripacthreeCheck->SetCheckState(MythUIStateType::Full);
+        else
+            m_ripacthreeCheck->SetCheckState(MythUIStateType::Off);
+
+        m_numbtitlesText->SetText(QString(tr("Title %1 of %2")).arg(m_currentTitle->getTrack()).arg(m_dvdTitles->size()));
+
+    }
+}
+
+void TitleDialog::nextTitle()
+{
+    int index = m_dvdTitles->indexOf(m_currentTitle);
+    if (index+1 < m_dvdTitles->size())
+        m_currentTitle = m_dvdTitles->at(index+1);
+    else
+        m_currentTitle = m_dvdTitles->first();
+
+    showCurrentTitle();
+}
+
+void TitleDialog::prevTitle()
+{
+    int index = m_dvdTitles->indexOf(m_currentTitle);
+    if(index > 0)
+        m_currentTitle = m_dvdTitles->at(index-1);
+    else
+        m_currentTitle = m_dvdTitles->last();
+
+    showCurrentTitle();
+}
+
+void TitleDialog::gotoTitle(uint title_number)
+{
+    for(int i = 0; i < m_dvdTitles->size(); i++)
+    {
+        if(m_dvdTitles->at(i)->getTrack() == title_number)
+        {
+            m_currentTitle = m_dvdTitles->at(i);
+            i = m_dvdTitles->size() + 1;
+            showCurrentTitle();
+        }
+    }
+}
+
+void TitleDialog::setQuality(MythUIButtonListItem *item)
+{
+    m_currentTitle->setQuality(item->GetData().toInt());
+}
+
+void TitleDialog::setSubTitle(MythUIButtonListItem *item)
+{
+    m_currentTitle->setSubTitle(item->GetData().toInt());
+}
+
+void TitleDialog::setAudio(MythUIButtonListItem *item)
+{
+    m_currentTitle->setAudio(item->GetData().toInt());
+}
+
+void TitleDialog::toggleTitle()
+{
+    m_currentTitle->setSelected(m_ripCheck->GetBooleanCheckState());
+
+    //m_currentTitle->setAC3(m_ripacthreeCheck->GetBooleanCheckState());
+
+    //
+    //  Should we be showing the Process Title(s)
+    //  Button ?
+    //
+
+    int numb_selected = 0;
+    for(int i = 0; i < m_dvdTitles->size(); i++)
+    {
+        if(m_dvdTitles->at(i)->getSelected())
+        {
+            ++numb_selected;
+        }
+    }
+    if(!m_ripawayButton)
+    {
+        return;
+    }
+    if(numb_selected == 0)
+    {
+        m_ripawayButton->SetVisible(false);
+        return;
+    }
+    m_ripawayButton->SetVisible(true);
+}
+
+void TitleDialog::changeName()
+{
+    m_currentTitle->setName(m_nameEdit->GetText());
+}
+
+void TitleDialog::toggleAC3()
+{
+    m_currentTitle->setAC3(m_ripacthreeCheck->GetBooleanCheckState());
+}
+
+void TitleDialog::viewTitle()
+{
+    QString player_string = gCoreContext->GetSetting("TitlePlayCommand");
+    if(player_string.length() < 1)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "No title player command defined");
+        return;
+    }
+
+    QString dvd_device = MediaMonitor::defaultDVDdevice();
+
+    int audio_track = 1;
+    int channels = 2;
+    if(m_currentTitle)
+    {
+        audio_track = m_currentTitle->getAudio();
+        DVDAudioInfo *audio_in_question = m_currentTitle->getAudioTrack(audio_track - 1);
+        if(audio_in_question)
+        {
+            channels = audio_in_question->getChannels();
+        }
+    }
+
+    if(player_string.contains("mplayer"))
+    {
+        //
+        //  Way to save a few bits mplayer
+        //
+        audio_track += 127;
+    }
+
+    player_string = player_string.replace(QRegExp("%d"), dvd_device);
+    player_string = player_string.replace(QRegExp("%t"), QString("%1").arg(m_currentTitle->getTrack()));
+    player_string = player_string.replace(QRegExp("%a"), QString("%1").arg(audio_track));
+    player_string = player_string.replace(QRegExp("%c"), QString("%1").arg(channels));
+
+    if(m_currentTitle->getSubTitle() > -1)
+    {
+        QString player_append = gCoreContext->GetSetting("SubTitleCommand");
+        if(player_append.length() > 1)
+        {
+            player_append = player_append.replace(QRegExp("%s"), QString("%1").arg(m_currentTitle->getSubTitle()));
+            player_string += " ";
+            player_string += player_append;
+        }
+    }
+    // LOG(VB_GENERAL, LOG_ERR, QString("PLAYER STRING: %1").arg(player_string));
+
+    myth_system(player_string);
+}
+
+void TitleDialog::ripTitles()
+{
+    //
+    //  OK, the user has selected whatever they want
+    //  We just need to build some job strings to
+    //  send to the mtd, send them out the socket,
+    //  and quit.
+    //
+
+    for(int i = 0; i < m_dvdTitles->size(); i++)
+    {
+        if(m_dvdTitles->at(i)->getSelected())
+        {
+            //
+            //  The spec for this command, which I'm
+            //  making up on the fly is:
+            //
+            //  job
+            //  {type}
+            //  {title #}
+            //  {audio_track}
+            //  {quality}
+            //  {ac3 flag}
+            //  {subtitle #}
+            //  {directory to end up in and final name}
+            //
+            //  note that everything after subtitle #
+            //  may include spaces (for subdirs and/or
+            //  riptitle that includes spaces)
+            //
+
+
+            //
+            //  we need to ask mythvideo stuff where it lives
+            //
+
+            QString destination_directory =
+                    gCoreContext->GetSetting("mythdvd.LocalRipDirectory");
+
+            if (!destination_directory.length())
+            {
+                // Assume import directory is first video scan directory
+#ifdef USING_MINGW
+# define kszPathSep ";"
+#else
+# define kszPathSep ":"
+#endif
+                QStringList videodirs =
+                        gCoreContext->GetSetting("VideoStartupDir").
+                            split(kszPathSep, QString::SkipEmptyParts);
+                if (videodirs.size())
+                    destination_directory = videodirs[0];
+            }
+
+            if(destination_directory.length() < 1)
+            {
+                LOG(VB_GENERAL, LOG_ERR, "titledialog.o: I can't rip, as I have nowhere to put finished files. MythVideo installed?");
+                return;
+            }
+
+            QString final_dir_and_file = destination_directory + "/" + m_dvdTitles->at(i)->getName();
+
+            QString job_string = QString("job dvd %1 %2 %3 %4 %5 %6")
+                                 .arg(m_dvdTitles->at(i)->getTrack())
+                                 .arg(m_dvdTitles->at(i)->getAudio())
+                                 .arg(m_dvdTitles->at(i)->getQuality())
+                                 .arg(m_dvdTitles->at(i)->getAC3())
+                                 .arg(m_dvdTitles->at(i)->getSubTitle())
+                                 .arg(final_dir_and_file);
+
+            QTextStream os(m_socketToMtd);
+            os << job_string << "\n" ;
+        }
+    }
+    Close();
+}
diff --git a/mythtv/programs/mythfrontend/titledialog.h b/mythtv/programs/mythfrontend/titledialog.h
new file mode 100644
index 0000000..0b960bd
--- /dev/null
+++ b/mythtv/programs/mythfrontend/titledialog.h
@@ -0,0 +1,68 @@
+#ifndef TITLEDIALOG_H_
+#define TITLEDIALOG_H_
+
+#include <QList>
+
+#include <mythscreentype.h>
+
+#include "dvdinfo.h"
+
+class QTcpSocket;
+
+class MythUIButtonList;
+class MythUIButtonListItem;
+class MythUIText;
+class MythUITextEdit;
+class MythUIButton;
+class MythUICheckBox;
+
+class TitleDialog : public MythScreenType
+{
+    Q_OBJECT
+
+  public:
+
+    TitleDialog(MythScreenStack *lparent,
+                QString lname,
+                QTcpSocket *a_socket,
+                QString d_name,
+                QList<DVDTitleInfo*> *titles);
+
+    bool Create();
+
+  public slots:
+
+    void showCurrentTitle();
+    void viewTitle();
+    void nextTitle();
+    void prevTitle();
+    void gotoTitle(uint title_number);
+    void toggleTitle();
+    void changeName();
+    void setAudio(MythUIButtonListItem *);
+    void setQuality(MythUIButtonListItem *);
+    void setSubTitle(MythUIButtonListItem *);
+    void toggleAC3();
+    void ripTitles();
+
+  private:
+    QString                  m_discName;
+    QList<DVDTitleInfo *>   *m_dvdTitles;
+    DVDTitleInfo            *m_currentTitle;
+    QTcpSocket              *m_socketToMtd;
+
+    MythUITextEdit      *m_nameEdit;
+    MythUIButtonList      *m_audioList;
+    MythUIButtonList      *m_qualityList;
+    MythUIButtonList      *m_subtitleList;
+    MythUICheckBox      *m_ripCheck;
+    MythUICheckBox      *m_ripacthreeCheck;
+    MythUIText          *m_playlengthText;
+    MythUIText          *m_numbtitlesText;
+    MythUIButton        *m_viewButton;
+    MythUIButton        *m_nexttitleButton;
+    MythUIButton        *m_prevtitleButton;
+    MythUIButton        *m_ripawayButton;
+};
+
+#endif
diff --git a/mythtv/programs/mythfrontend/videoglobalsettings.cpp b/mythtv/programs/mythfrontend/videoglobalsettings.cpp
index a492bea..abf19f5 100644
--- a/mythtv/programs/mythfrontend/videoglobalsettings.cpp
+++ b/mythtv/programs/mythfrontend/videoglobalsettings.cpp
@@ -155,6 +155,7 @@ HostComboBox *SetOnInsertDVD()
     gc->addSelection(QObject::tr("Display mythdvd menu"),"1");
     gc->addSelection(QObject::tr("Do nothing"),"0");
     gc->addSelection(QObject::tr("Play DVD"),"2");
+    gc->addSelection(QObject::tr("Rip DVD"),"3");
     gc->setHelpText(QObject::tr("Media Monitoring should be turned on to "
                    "allow this feature (Setup -> General -> CD/DVD Monitor)."));
     return gc;
@@ -170,6 +171,149 @@ HostCheckBox *VideoTreeRemember()
     return gc;
 }
 
+// Ripper Settings
+
+HostLineEdit *SetRipDirectory()
+{
+    HostLineEdit *gc = new HostLineEdit("DVDRipLocation");
+    gc->setLabel(QObject::tr("Directory to hold temporary files"));
+#ifdef Q_WS_MACX
+    gc->setValue(QDir::homePath() + "/Library/Application Support");
+#else
+    gc->setValue("/var/lib/mythdvd/temp");
+#endif
+    gc->setHelpText(QObject::tr("This directory must exist, and the user "
+                    "running MythDVD needs to have write permission "
+                    "to the directory."));
+    return gc;
+}
+
+HostLineEdit *TitlePlayCommand()
+{
+    HostLineEdit *gc = new HostLineEdit("TitlePlayCommand");
+    gc->setLabel(QObject::tr("Title Playing Command"));
+    gc->setValue("mplayer dvd://%t -dvd-device %d -fs -zoom -vo xv -aid %a "
+                 "-channels %c");
+    gc->setHelpText(QObject::tr("This is a command used to preview a given "
+                    "title on a DVD. If present %t will be set "
+                    "to the title, %d for device, %a for audio "
+                    "track, %c for audio channels."));
+    return gc;
+}
+
+HostLineEdit *SubTitleCommand()
+{
+    HostLineEdit *gc = new HostLineEdit("SubTitleCommand");
+    gc->setLabel(QObject::tr("Subtitle arguments:"));
+    gc->setValue("-sid %s");
+    gc->setHelpText(QObject::tr("If you choose any subtitles for ripping, this "
+                    "command is added to the end of the Title Play "
+                    "Command to allow previewing of subtitles. If  "
+                    "present %s will be set to the subtitle track. "));
+    return gc;
+}
+
+HostLineEdit *TranscodeCommand()
+{
+    HostLineEdit *gc = new HostLineEdit("TranscodeCommand");
+    gc->setLabel(QObject::tr("Base transcode command"));
+    gc->setValue("transcode");
+    gc->setHelpText(QObject::tr("This is the base (without arguments) command "
+                    "to run transcode on your system."));
+    return gc;
+}
+
+HostSpinBox *MTDPortNumber()
+{
+    HostSpinBox *gc = new HostSpinBox("MTDPort", 1024, 65535, 1);
+    gc->setLabel(QObject::tr("MTD port number"));
+    gc->setValue(2442);
+    gc->setHelpText(QObject::tr("The port number that should be used for "
+                    "communicating with the MTD (Myth Transcoding "
+                    "Daemon)"));
+    return gc;
+}
+
+HostCheckBox *MTDLogFlag()
+{
+    HostCheckBox *gc = new HostCheckBox("MTDLogFlag");
+    gc->setLabel(QObject::tr("MTD logs to terminal window"));
+    gc->setValue(false);
+    gc->setHelpText(QObject::tr("If set, the MTD (Myth Transcoding Daemon) "
+                    "will log to the window it is started from. "
+                    "Otherwise, it will write to a file called  "
+                    "mtd.log in the top level ripping directory."));
+    return gc;
+}
+
+HostCheckBox *MTDac3Flag()
+{
+    HostCheckBox *gc = new HostCheckBox("MTDac3Flag");
+    gc->setLabel(QObject::tr("Transcode AC3 Audio"));
+    gc->setValue(false);
+    gc->setHelpText(QObject::tr("If set, the MTD (Myth Transcoding Daemon) "
+                    "will, by default, preserve AC3 (Dolby "
+                    "Digital) audio in transcoded files. "));
+    return gc;
+}
+
+HostCheckBox *MTDxvidFlag()
+{
+    HostCheckBox *gc = new HostCheckBox("MTDxvidFlag");
+    gc->setLabel(QObject::tr("Use xvid rather than divx"));
+    gc->setValue(true);
+    gc->setHelpText(QObject::tr("If set, mythdvd will use the (open, free) "
+                    "xvid codec rather than divx whenever "
+                    "possible."));
+    return gc;
+}
+
+HostCheckBox *MTDTrustTranscodeFRDetect()
+{
+    HostCheckBox *gc = new HostCheckBox("mythvideo.TrustTranscodeFRDetect");
+    gc->setLabel(QObject::tr("Let transcode determine frame rate"));
+    gc->setValue(true);
+    gc->setHelpText(QObject::tr("If set, transcode will determine the frame "
+                                "rate automatically. If not set, 23.976 is "
+                                "assumed."));
+    return gc;
+}
+
+HostSpinBox *MTDNiceLevel()
+{
+    HostSpinBox *gc = new HostSpinBox("MTDNiceLevel", 0, 20, 1);
+    gc->setLabel(QObject::tr("Nice level for MTD"));
+    gc->setValue(20);
+    gc->setHelpText(QObject::tr("This determines the priority of the Myth "
+                    "Transcoding Daemon. Higher numbers mean "
+                    "lower priority (more CPU to other tasks)."));
+    return gc;
+}
+
+HostSpinBox *MTDConcurrentTranscodes()
+{
+    HostSpinBox *gc = new HostSpinBox("MTDConcurrentTranscodes", 1, 99, 1);
+    gc->setLabel(QObject::tr("Simultaneous Transcode Jobs"));
+    gc->setValue(1);
+    gc->setHelpText(QObject::tr("This determines the number of simultaneous "
+                    "transcode jobs. If set at 1 (the default), "
+                    "there will only be one active job at a time."));
+    return gc;
+}
+
+HostSpinBox *MTDRipSize()
+{
+    HostSpinBox *gc = new HostSpinBox("MTDRipSize", 0, 4096, 1);
+    gc->setLabel(QObject::tr("Ripped video segments"));
+    gc->setValue(0);
+    gc->setHelpText(QObject::tr("If set to something other than 0, ripped "
+                    "video titles will be broken up into files "
+                    "of this size (in MB). Applies to both perfect "
+                    "quality recordings and intermediate files "
+                    "used for transcoding."));
+    return gc;
+}
+
 struct ConfigPage
 {
     typedef std::vector<ConfigurationGroup *> PageList;
@@ -309,3 +453,28 @@ VideoGeneralSettings::VideoGeneralSettings()
         addChild(*p);
     }
 }
+
+DVDRipperSettings::DVDRipperSettings()
+{
+    VerticalConfigurationGroup *rippersettings =
+            new VerticalConfigurationGroup(false);
+    rippersettings->setLabel(QObject::tr("DVD Ripper Settings"));
+    rippersettings->addChild(SetRipDirectory());
+    rippersettings->addChild(TitlePlayCommand());
+    rippersettings->addChild(SubTitleCommand());
+    rippersettings->addChild(TranscodeCommand());
+    addChild(rippersettings);
+
+    VerticalConfigurationGroup *mtdsettings =
+            new VerticalConfigurationGroup(false);
+    mtdsettings->setLabel(QObject::tr("MTD Settings"));
+    mtdsettings->addChild(MTDPortNumber());
+    mtdsettings->addChild(MTDNiceLevel());
+    mtdsettings->addChild(MTDConcurrentTranscodes());
+    mtdsettings->addChild(MTDRipSize());
+    mtdsettings->addChild(MTDLogFlag());
+    mtdsettings->addChild(MTDac3Flag());
+    mtdsettings->addChild(MTDxvidFlag());
+    mtdsettings->addChild(MTDTrustTranscodeFRDetect());
+    addChild(mtdsettings);
+}
diff --git a/mythtv/programs/mythfrontend/videoglobalsettings.h b/mythtv/programs/mythfrontend/videoglobalsettings.h
index 9f621e6..266ed92 100644
--- a/mythtv/programs/mythfrontend/videoglobalsettings.h
+++ b/mythtv/programs/mythfrontend/videoglobalsettings.h
@@ -9,4 +9,10 @@ class VideoGeneralSettings : public ConfigurationWizard
     VideoGeneralSettings();
 };
 
+class DVDRipperSettings :  public ConfigurationWizard
+{
+  public:
+    DVDRipperSettings();
+};
+
 #endif
diff --git a/mythtv/programs/mythmtd/.gitignore b/mythtv/programs/mythmtd/.gitignore
new file mode 100644
index 0000000..a56bd17
--- /dev/null
+++ b/mythtv/programs/mythmtd/.gitignore
@@ -0,0 +1 @@
+mythmtd
diff --git a/mythtv/programs/mythmtd/dvdprobe.cpp b/mythtv/programs/mythmtd/dvdprobe.cpp
new file mode 100644
index 0000000..86a1433
--- /dev/null
+++ b/mythtv/programs/mythmtd/dvdprobe.cpp
@@ -0,0 +1,813 @@
+/*
+    dvdprobe.cpp
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    implementation for dvd probing (libdvdread)
+*/
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#if defined(__linux__) || defined(__FreeBSD__)
+#include <sys/ioctl.h>
+#include <linux/cdrom.h>
+#endif
+#include <fcntl.h>
+#include <unistd.h>
+
+#include <cmath>
+#include <climits> // for CDSL_CURRENT which is currently INT_MAX
+
+// Qt
+#include <QFile>
+
+#include "dvdprobe.h"
+
+#include <mythcontext.h>
+#include <mythdbcon.h>
+#include <mythlogging.h>
+
+namespace
+{
+    // decode a dvd_time_t time value
+    uint decdt(uint8_t c)
+    {
+        return 10 * (c >> 4) + (c & 0xF);
+    }
+
+    bool fcomp(float lhs, float rhs, float ep = 0.0001)
+    {
+        return std::fabs((lhs - rhs) / rhs) <= ep;
+    }
+
+    QString lctola(uint16_t lang_code)
+    {
+        return QString("%1%2").arg(char(lang_code >> 8))
+                .arg(char(lang_code & 0xff));
+    }
+}
+
+#define LOC_ERR  QString("dvdprobe.cpp, Error: ")
+#define LOC_WARN QString("dvdprobe.cpp, Warning: ")
+#define LOC      QString("dvdprobe.cpp: ")
+
+DVDSubTitle::DVDSubTitle(int subtitle_id, const QString &a_language) :
+    id(subtitle_id), language(a_language.toUtf8())
+{
+    if (language.isEmpty())
+        language = "unknown";
+}
+
+DVDAudio::DVDAudio() : audio_format(""), multichannel_extension(false),
+    language(""), application_mode(""), quantization(""),
+    sample_frequency(""), channels(0), language_extension("")
+{
+}
+
+void DVDAudio::printYourself(void) const
+{
+    //
+    //  Debugging
+    //
+
+    LOG(VB_GENERAL, LOG_INFO, QString("    Audio track: %1 %2 %3 %4 Ch")
+            .arg(language)
+            .arg(audio_format)
+            .arg(sample_frequency)
+            .arg(channels));
+}
+
+QString DVDAudio::GetAudioString(void) const
+{
+    return QString("%1 %2 %3Ch").arg(language).arg(audio_format).arg(channels);
+}
+
+void DVDAudio::fill(audio_attr_t *audio_attributes)
+{
+    //
+    //  this just travels down the audio_attributes struct
+    //  (defined in libdvdread) and ticks off the right
+    //  information
+    //
+
+    switch (audio_attributes->audio_format)
+    {
+        case 0:
+            audio_format = "ac3";
+            break;
+        case 1:
+            audio_format = "oops";
+            break;
+        case 2:
+            audio_format = "mpeg1";
+            break;
+        case 3:
+            audio_format = "mpeg2ext";
+            break;
+        case 4:
+            audio_format = "lpcm";
+            break;
+        case 5:
+            audio_format = "oops";
+            break;
+        case 6:
+            audio_format = "dts";
+            break;
+        default:
+            audio_format = "oops";
+    }
+
+    if (audio_attributes->multichannel_extension)
+    {
+        multichannel_extension = true;
+    }
+
+    switch (audio_attributes->lang_type)
+    {
+        case 0:
+            language = "nl";
+            break;
+        case 1:
+            language = lctola(audio_attributes->lang_code);
+            break;
+        default:
+            language = "oops";
+    }
+
+    switch (audio_attributes->application_mode)
+    {
+        case 0:
+            application_mode = "unknown";
+            break;
+        case 1:
+            application_mode = "karaoke";
+            break;
+        case 2:
+            application_mode = "surround sound";
+            break;
+        default:
+            application_mode = "oops";
+    }
+
+    switch (audio_attributes->quantization)
+    {
+        case 0:
+            quantization = "16bit";
+            break;
+        case 1:
+            quantization = "20bit";
+            break;
+        case 2:
+            quantization = "24bit";
+            break;
+        case 3:
+            quantization = "drc";
+            break;
+        default:
+            quantization = "oops";
+    }
+
+    switch (audio_attributes->sample_frequency)
+    {
+        case 0:
+            sample_frequency = "48kHz";
+            break;
+        default:
+            sample_frequency = "oops";
+    }
+
+    channels = audio_attributes->channels + 1;
+
+    switch (audio_attributes->lang_extension)
+    {
+        case 0:
+            language_extension = "Unknown";
+            break;
+        case 1:
+            language_extension = "Normal Caption";
+            break;
+        case 2:
+            language_extension = "Audio for Visually Impaired";
+            break;
+        case 3:
+            language_extension = "Directors 1";
+            break;
+        case 4:
+            language_extension = "Directors 2 or Music Score";
+            break;
+        default:
+            language_extension = "oops";
+    }
+}
+
+DVDAudio::~DVDAudio()
+{
+}
+
+/*
+---------------------------------------------------------------------
+*/
+
+DVDTitle::DVDTitle() :
+    numb_chapters(0), numb_angles(0), track_number(0),
+
+    hours(0), minutes(0), seconds(0),
+
+    hsize(0), vsize(0), frame_rate(0.0), fr_code(0), ar_numerator(0),
+    ar_denominator(0), aspect_ratio(""), letterbox(false),
+    video_format("unknown"), dvdinput_id(0)
+{
+}
+
+bool DVDTitle::IsValid(void) const
+{
+    return
+        numb_chapters || numb_angles || track_number ||
+        hours || minutes || seconds ||
+        hsize || vsize || frame_rate != 0.0 ||
+        fr_code || ar_numerator ||
+        ar_denominator || !aspect_ratio.isEmpty() || letterbox ||
+        (video_format != "unknown") || dvdinput_id ||
+        audio_tracks.size() || subtitles.size();
+}
+
+void DVDTitle::SetTime(uint h, uint m, uint s, double fr)
+{
+    hours = h;
+    minutes = m;
+    seconds = s;
+    frame_rate = fr;
+
+    //
+    //  These are transcode frame rate codes
+    //
+
+    if (fr > 23.0 && fr < 24.0)
+        fr_code = 1;
+    else if (fcomp(fr, 24.0))
+        fr_code = 2;
+    else if (fcomp(fr, 25.0))
+        fr_code = 3;
+    else if (fr >  20.0 && fr < 30.0)
+        fr_code = 4;
+    else if (fcomp(fr, 30.0))
+        fr_code = 5;
+    else if (fcomp(fr, 50.0))
+        fr_code = 6;
+    else if (fr > 59.0 && fr < 60.0)
+        fr_code = 7;
+    else if (fcomp(fr, 60.0))
+        fr_code = 8;
+    else if (fcomp(fr, 1.0))
+        fr_code = 9;
+    else if (fcomp(fr, 5.0))
+        fr_code = 10;
+    else if (fcomp(fr, 10.0))
+        fr_code = 11;
+    else if (fcomp(fr, 12.0))
+        fr_code = 12;
+    else if (fcomp(fr, 15.0))
+        fr_code = 13;
+    else
+    {
+        fr_code = 0;
+        LOG(VB_GENERAL, LOG_ERR,
+                QString("dvdprobe.o: Could not find a frame rate code given a"
+                        " frame rate of %1").arg(fr));
+    }
+}
+
+void DVDTitle::SetAR(uint n, uint d, const QString &ar)
+{
+    ar_numerator = n;
+    ar_denominator = d;
+    aspect_ratio = ar;
+}
+
+uint DVDTitle::GetPlayLength(void) const
+{
+    return seconds + (60 * minutes) + (60 * 60 * hours);
+}
+
+QString DVDTitle::GetTimeString(void) const
+{
+    return QString().sprintf("%d:%02d:%02d", hours, minutes, seconds);
+}
+
+void DVDTitle::printYourself(void) const
+{
+    //
+    //  Debugging
+    //
+
+    LOG(VB_GENERAL, LOG_ERR, QString("Track %1 has %2 chapters, %3 angles, "
+                                  "and runs for %4 hour(s) %5 minute(s) "
+                                  "and %6 seconds at %7 fps.")
+            .arg(track_number).arg(numb_chapters).arg(numb_angles).arg(hours)
+            .arg(minutes).arg(seconds).arg(frame_rate));
+
+    if (!audio_tracks.empty())
+    {
+        for (uint i = 0; i < (uint)audio_tracks.size(); ++i)
+        {
+            audio_tracks[i].printYourself();
+        }
+    }
+    else
+    {
+        LOG(VB_GENERAL, LOG_ERR, "    No Audio Tracks");
+    }
+}
+
+void DVDTitle::AddAudio(const DVDAudio &new_audio_track)
+{
+    audio_tracks.push_back(new_audio_track);
+}
+
+void DVDTitle::AddSubTitle(const DVDSubTitle &subtitle)
+{
+    //
+    //  Check if this language already exists
+    //  (which happens a lot)
+    //
+    DVDSubTitle new_subtitle = subtitle;
+
+    int lang_count = 0;
+    for (uint i = 0; i < (uint)subtitles.size(); ++i)
+    {
+        if (subtitles[i].GetLanguage() == new_subtitle.GetLanguage())
+        {
+            ++lang_count;
+        }
+    }
+    if (lang_count == 0)
+    {
+        new_subtitle.SetName(QString("<%1>").arg(new_subtitle.GetLanguage()));
+    }
+    else
+    {
+        ++lang_count;
+        new_subtitle.SetName(QString("<%1> (%2)")
+                             .arg(new_subtitle.GetLanguage())
+                             .arg(lang_count));
+    }
+    subtitles.push_back(new_subtitle);
+}
+
+void DVDTitle::determineInputID(void)
+{
+    MSqlQuery a_query(MSqlQuery::InitCon());
+    a_query.prepare("SELECT intid FROM dvdinput WHERE "
+                              "hsize = :HSIZE and "
+                              "vsize = :VSIZE and "
+                              "ar_num = :ARNUM and "
+                              "ar_denom = :ARDENOM and "
+                              "fr_code = :FRCODE and "
+                              "letterbox = :LETTERBOX and "
+                              "v_format = :VFORMAT;");
+    a_query.bindValue(":HSIZE", hsize);
+    a_query.bindValue(":VSIZE", vsize);
+    a_query.bindValue(":ARNUM", ar_numerator);
+    a_query.bindValue(":ARDENOM", ar_denominator);
+    a_query.bindValue(":FRCODE", fr_code);
+    a_query.bindValue(":LETTERBOX", letterbox);
+    a_query.bindValue(":VFORMAT", video_format);
+
+    if (a_query.exec() && a_query.isActive() && a_query.size() > 0)
+    {
+        a_query.next();
+        dvdinput_id = a_query.value(0).toInt();
+    }
+    else
+    {
+        QString msg =
+                QString("You have a title on your dvd in a format myth doesn't"
+                    " understand.\n"
+                    "Either that, or you haven't installed the dvdinput"
+                    " table.\n"
+                    "You probably want to report this to a mailing list or"
+                    " something:\n"
+                    "                  height = %1\n"
+                    "                   width = %2\n"
+                    "            aspect ratio = %3 (%4/%5)\n"
+                    "              frame rate = %6\n"
+                    "                 fr_code = %7\n"
+                    "             letterboxed = %8\n"
+                    "                  format = %9")
+                .arg(hsize).arg(vsize)
+                .arg(aspect_ratio).arg(ar_numerator).arg(ar_denominator)
+                .arg(frame_rate).arg(fr_code).arg(letterbox).arg(video_format);
+        LOG(VB_GENERAL, LOG_ERR, msg);
+    }
+}
+
+DVDTitle::~DVDTitle()
+{
+}
+
+/*
+---------------------------------------------------------------------
+*/
+
+
+/** \class DVDProbe
+ *  \brief This object just figures out what is on a disc
+ *         and tells whomever asks about it.
+ */
+
+DVDProbe::DVDProbe(const QString &dvd_device) :
+    dvd(NULL), first_time(true), device(dvd_device),
+    volume_name(QObject::tr("Unknown"))
+{
+    device.detach();
+    volume_name.detach();
+}
+
+void DVDProbe::Reset(void)
+{
+    first_time = true;
+    volume_name = QObject::tr("Unknown");
+    titles.clear();
+}
+
+bool DVDProbe::Probe(void)
+{
+    //  Before touching libdvdread stuff
+    //  (below), see if there's actually
+    //  a drive with media in it
+    {
+        QFile dvdDevice(device);
+        if (!dvdDevice.exists())
+        {
+            //  Device doesn't exist. Silly user
+            Reset();
+            return false;
+        }
+    }
+
+    // On UNIX like file systems O_NONBLOCK should be used to
+    // indicate we don't want to do reading or writing, we
+    // just want to issue some ioctls. This will prevent the
+    // OS from helping out and shearing the fingers off any
+    // person's attempting to place a DVD in the drive when
+    // we call open.
+    int flags = O_RDONLY;
+#ifdef O_NONBLOCK
+    flags |= O_NONBLOCK;
+#endif
+
+    // Ideally we can open with exclusive flag.
+#ifdef O_EXCL
+    flags |= O_EXCL;
+#endif
+
+    int drive_handle = open(device.toLocal8Bit().constData(), flags);
+
+#ifdef O_EXCL
+    // If this failed with exclusive, try without.
+    if (drive_handle < 0)
+    {
+        flags &= ~O_EXCL;
+        drive_handle = open(device.toLocal8Bit().constData(), flags);
+    }
+#endif
+
+    if (drive_handle < 0)
+    {
+        LOG(VB_GENERAL, LOG_ERR, LOC +
+                "Failed to open file descriptor for DVD." + ENO);
+        Reset();
+        return false;
+    }
+
+#if defined(__linux__) || defined(__FreeBSD__)
+    //  I have no idea if the following code block
+    //  is anywhere close to the "right way" of doing
+    //  this, but it seems to work.
+
+    // Sometimes the first result following an open is a lie. Often the
+    // first call will return 4, however an immediate second call will
+    // return 2. Anecdotally the first result after an open has only
+    // a 1 in 8 chance of detecting changes from 4 to 2, while a second call
+    // (in an admittedly small test number) seems to make it much more
+    // accurate (with only a 1 in 6 chance that the first result was more
+    // accurate than the second).
+    int status = ioctl(drive_handle, CDROM_DRIVE_STATUS, CDSL_CURRENT);
+    if (status < 0)
+    {
+        Reset();
+        close(drive_handle);
+        return false;
+    }
+
+    status = ioctl(drive_handle, CDROM_DRIVE_STATUS, CDSL_CURRENT);
+    if (status < 4)
+    {
+        //
+        // -1  error (no disc)
+        //  1 = no info
+        //  2 = tray open
+        //  3 = not ready
+        //
+        Reset();
+        close(drive_handle);
+        return false;
+    }
+
+    status = ioctl(drive_handle, CDROM_MEDIA_CHANGED, NULL);
+
+    if (!status && !first_time)
+    {
+        //  the disc has not changed. but if this is our
+        //  first time running, we still need to check it
+        //  so return whatever we returned before
+        close(drive_handle);
+        return titles.size();
+    }
+#endif
+
+    close(drive_handle);
+    drive_handle = -1;
+
+    //
+    //  Try to open the disc
+    //  (as far as libdvdread is concerned, the argument
+    //  could be a path, file, whatever).
+    //
+
+    Reset();
+    first_time = false;
+    QByteArray dev = device.toLocal8Bit();
+    dvd = DVDOpen(dev.constData());
+    if (!dvd)
+        return false;
+
+    //
+    //  Grab the title of this DVD
+    //
+
+    const int arbitrary = 1024;
+    char volume_name_buffr[arbitrary + 1];
+    unsigned char set_name[arbitrary + 1];
+
+    if (DVDUDFVolumeInfo(dvd, volume_name_buffr, arbitrary, set_name,
+                         arbitrary) > -1)
+    {
+        volume_name = volume_name_buffr;
+    }
+    else
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Error getting volume name, setting to"
+                "\"Unknown\"");
+    }
+
+    ifo_handle_t *ifo_file = ifoOpen(dvd, 0);
+    if (!ifo_file)
+    {
+        DVDClose(dvd);
+        dvd = NULL;
+        return false;
+    }
+
+    //
+    //  Most of this is taken from title_info.c and
+    //  ifo_dump.c located in the libdvdread ./src/
+    //  directory. Some if is also based on dvd_reader.c
+    //  in the transcode source.
+    //
+
+    tt_srpt_t *title_info = ifo_file->tt_srpt;
+    for (int i = 0; i < title_info->nr_of_srpts; ++i )
+    {
+        DVDTitle new_title;
+        new_title.SetTrack(i + 1);
+        new_title.SetChapters((uint) title_info->title[i].nr_of_ptts);
+        new_title.SetAngles((uint) title_info->title[i].nr_of_angles);
+
+        ifo_handle_t *video_transport_file = NULL;
+
+        video_transport_file =
+            ifoOpen(dvd, title_info->title[i].title_set_nr);
+        if (!video_transport_file)
+        {
+            LOG(VB_GENERAL, LOG_ERR,
+                    QString("Can't get video transport for track %1")
+                    .arg(i+1));
+        }
+        else
+        {
+
+            //
+            //  See how simple libdvdread makes it to find the playing
+            //  time?
+            //
+            //  Why have a playingTime(track_number) function, when you
+            //  could jump through all these hoops:
+            //
+
+            int some_index = title_info->title[i].vts_ttn;
+            int some_other_index = video_transport_file->vts_ptt_srpt->
+                title[some_index - 1].ptt[0].pgcn;
+            pgc_t *current_pgc = video_transport_file->vts_pgcit->
+                pgci_srp[some_other_index - 1].pgc;
+
+            dvd_time_t *libdvdread_playback_time =
+                &current_pgc->playback_time;
+
+            double framerate = 0.0;
+
+            switch ((libdvdread_playback_time->frame_u & 0xc0) >> 6)
+            {
+                case 1:
+                    framerate = 25.0;  // PAL
+                    break;
+                case 3:
+                    framerate = 24000/1001.0;  // NTSC_FILM
+                    break;
+                default:
+                    LOG(VB_GENERAL, LOG_ERR,
+                            "For some odd reason (!), I couldn't get a"
+                            " video frame rate");
+                    break;
+            }
+
+            //
+            //  Somebody who knows something about how to program a
+            //  computer should clean this up
+            //
+
+            new_title.SetTime(decdt(libdvdread_playback_time->hour),
+                              decdt(libdvdread_playback_time->minute),
+                              decdt(libdvdread_playback_time->second),
+                              framerate);
+
+            vtsi_mat_t *vtsi_mat = video_transport_file->vtsi_mat;
+            if (vtsi_mat)
+            {
+                //
+                //  and now, wave the divining rod over audio bits
+                //
+
+                for (int j = 0; j < vtsi_mat->nr_of_vts_audio_streams; j++)
+                {
+                    audio_attr_t *audio_attributes =
+                        &vtsi_mat->vts_audio_attr[j];
+                    DVDAudio new_audio;
+                    new_audio.fill(audio_attributes);
+                    new_title.AddAudio(new_audio);
+                }
+
+                //
+                //  determine, with any luck, subtitles
+                //
+
+                for (int j = 0; j < vtsi_mat->nr_of_vts_subp_streams;
+                     j++)
+                {
+                    subp_attr_t *sub_attributes =
+                        &vtsi_mat->vts_subp_attr[j];
+                    if (sub_attributes->type           == 0 &&
+                        sub_attributes->zero1          == 0 &&
+                        sub_attributes->lang_code      == 0 &&
+                        sub_attributes->lang_extension == 0 &&
+                        sub_attributes->zero2          == 0)
+                    {
+                        // ignore this sub attribute
+                    }
+                    else
+                    {
+                        //
+                        //  The Freakin Disney Corporation seems to
+                        //  think it's useful to set language codes
+                        //  with weird ass characters. This should
+                        //  probably handle that.
+                        //
+                        QString tmp = QString(
+                            lctola(sub_attributes->lang_code).toUtf8());
+                        new_title.AddSubTitle(DVDSubTitle(j, tmp));
+
+                    }
+                }
+
+                //
+                //  Figure out size, aspect ratio, etc.
+                //
+
+                video_attr_t *video_attributes =
+                    &vtsi_mat->vts_video_attr;
+
+                switch (video_attributes->display_aspect_ratio)
+                {
+                    case 0:
+                        new_title.SetAR(4, 3, "4:3");
+                        break;
+                    case 3:
+                        new_title.SetAR(16, 9, "16:9");
+                        break;
+                    default:
+                        LOG(VB_GENERAL, LOG_ERR, "couldn't get aspect"
+                                " ratio for a title");
+                }
+
+                switch (video_attributes->video_format)
+                {
+                    case 0:
+                        new_title.SetVFormat("ntsc");
+                        break;
+                    case 1:
+                        new_title.SetVFormat("pal");
+                        break;
+                    default:
+                        LOG(VB_GENERAL, LOG_ERR, "Could not get video"
+                                " format for a title");
+                }
+
+                if (video_attributes->letterboxed)
+                {
+                    new_title.SetLBox(true);
+                }
+
+                uint c_height = 480;
+                if (video_attributes->video_format != 0)
+                {
+                    c_height = 576;
+                }
+
+                switch (video_attributes->picture_size)
+                {
+                    case 0:
+                        new_title.SetSize(720, c_height);
+                        break;
+                    case 1:
+                        new_title.SetSize(704, c_height);
+                        break;
+                    case 2:
+                        new_title.SetSize(352, c_height);
+                        break;
+                    case 3:
+                        new_title.SetSize(352, c_height / 2);
+                        break;
+                    default:
+                        LOG(VB_GENERAL, LOG_ERR, "Could not determine for"
+                                " video size for a title.");
+                }
+                ifoClose(video_transport_file);
+            }
+            else
+            {
+                LOG(VB_GENERAL, LOG_ERR,
+                        QString("Couldn't find any audio or video"
+                                " information for track %1").arg(i+1));
+            }
+        }
+
+        //
+        //  Debugging output
+        //
+        //  new_title.printYourself();
+
+        //
+        //  Have the new title figure out it's
+        //  appropriate id number vis-a-vis the
+        //  dvdinput table
+        //
+
+        new_title.determineInputID();
+
+        //
+        //  Add this new title to the container
+        //
+
+        titles.push_back(new_title);
+    }
+
+    ifoClose(ifo_file);
+    ifo_file = NULL;
+
+    DVDClose(dvd);
+    dvd = NULL;
+
+    return true;
+}
+
+DVDTitle DVDProbe::GetTitle(uint which_one) const
+{
+    DVDTitleList::const_iterator it = titles.begin();
+    for (; it != titles.end(); ++it)
+    {
+        if ((*it).GetTrack() == which_one)
+            return *it;
+    }
+    return DVDTitle();
+}
+
+DVDProbe::~DVDProbe(void)
+{
+    if (dvd)
+    {
+        DVDClose(dvd);
+        dvd = NULL;
+    }
+    Reset();
+}
diff --git a/mythtv/programs/mythmtd/dvdprobe.h b/mythtv/programs/mythmtd/dvdprobe.h
new file mode 100644
index 0000000..ef2f23e
--- /dev/null
+++ b/mythtv/programs/mythmtd/dvdprobe.h
@@ -0,0 +1,190 @@
+/*
+    dvdprobe.h
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    header for dvd probing code (libdvdread)
+*/
+
+#ifndef DVDPROBE_H_
+#define DVDPROBE_H_
+
+#include <inttypes.h>
+
+#ifndef UINT8_MAX
+#define UINT8_MAX
+#define UINT16_MAX
+#define INT32_MAX
+#define MAXDEFS
+#endif
+
+#include <dvdread/ifo_types.h>
+#include <dvdread/ifo_read.h>
+#include <dvdread/dvd_reader.h>
+#include <dvdread/nav_read.h>
+
+#ifdef MAXDEFS
+#undef UINT8_MAX
+#undef UINT16_MAX
+#undef INT32_MAX
+#endif
+
+// Qt headers
+#include <QString>
+#include <QList>
+
+class DVDSubTitle
+{
+    //
+    //  A DVDTitle (below) holds zero or more
+    //  of these objects, each describing available
+    //  subtitles.
+    //
+
+  public:
+    DVDSubTitle(int subtitle_id, const QString &a_language);
+
+    void    SetName(const QString &a_name) { name = a_name; }
+    QString GetLanguage(void) const { return language; }
+    QString GetName(void) const { return name; }
+    int     GetID(void) const { return id; }
+
+  private:
+    int     id;
+    QString language;
+    QString name;
+};
+typedef QList<DVDSubTitle> DVDSubTitleList;
+
+class DVDAudio
+{
+    //
+    //  A DVDTitle (see below) holds a pointer list
+    //  of zero or more DVDAudio objects (one per audio
+    //  track)
+    //
+
+  public:
+    DVDAudio();
+    ~DVDAudio();
+
+    void    printYourself(void) const;
+    void    fill(audio_attr_t *audio_attributes);
+    int     GetChannels(void) const { return channels; }
+    QString GetAudioString(void) const;
+
+  private:
+    QString audio_format;
+    bool    multichannel_extension;
+    QString language;
+    QString application_mode;
+    QString quantization;
+    QString sample_frequency;
+    int     channels;
+    QString language_extension;
+};
+typedef QList<DVDAudio>    DVDAudioList;
+
+class DVDTitle
+{
+    //
+    //  A little "struct" class that holds
+    //  DVD Title informations
+    //  (n.b. a DVD "title" is a logically distinct section
+    //  of video, i.e. A movie, a special, a featurette, etc.)
+    //
+
+  public:
+    DVDTitle();
+    ~DVDTitle();
+
+    //
+    //  Set
+    //
+
+    void    SetChapters(uint a_uint) { numb_chapters = a_uint; }
+    void    SetAngles(uint a_uint) { numb_angles = a_uint; }
+    void    SetTrack(uint a_uint) { track_number = a_uint; }
+    void    SetTime(uint h, uint m, uint s, double fr);
+    void    SetAR(uint n, uint d, const QString &ar);
+    void    SetSize(uint h, uint v) { hsize = h; vsize = v; }
+    void    SetLBox(bool yes_or_no) { letterbox = yes_or_no; }
+    void    SetVFormat(const QString &a_string) { video_format = a_string; }
+    void    determineInputID();
+
+    //
+    //  Get
+    //
+
+    uint    GetChapters(void)            const { return numb_chapters; }
+    uint    GetAngles(void)              const { return numb_angles; }
+    uint    GetTrack(void)               const { return track_number; }
+    uint    GetHours(void)               const { return hours; }
+    uint    GetMinutes(void)             const { return minutes; }
+    uint    GetSeconds(void)             const { return seconds; }
+    uint    GetInputID(void)             const { return dvdinput_id; }
+    DVDAudioList    GetAudioTracks(void) const { return audio_tracks; }
+    DVDSubTitleList GetSubTitles(void)   const { return subtitles; }
+    uint    GetPlayLength(void) const;
+    QString GetTimeString(void) const;
+    bool    IsValid(void) const;
+
+    void    AddAudio(const DVDAudio &new_audio_track);
+    void    AddSubTitle(const DVDSubTitle &new_subitle);
+
+    void    printYourself(void) const;
+
+  private:
+    uint    numb_chapters;
+    uint    numb_angles;
+    uint    track_number;
+
+    uint    hours;
+    uint    minutes;
+    uint    seconds;
+
+    uint    hsize;
+    uint    vsize;
+    double  frame_rate;
+    int     fr_code;
+    uint    ar_numerator;
+    uint    ar_denominator;
+    QString aspect_ratio;
+    bool    letterbox;
+    QString video_format;
+    uint    dvdinput_id;
+
+    DVDAudioList    audio_tracks;
+    DVDSubTitleList subtitles;
+};
+typedef QList<DVDTitle> DVDTitleList;
+
+class DVDProbe
+{
+    //
+    //  A little class that figures out what's on that
+    //  disc in the drive (only DVD's)
+    //
+
+  public:
+    DVDProbe(const QString &dvd_device);
+    ~DVDProbe();
+
+    bool          Probe(void);
+    QString       GetName(void)   const { return volume_name; }
+    DVDTitleList  GetTitles(void) const { return titles;      }
+    DVDTitle      GetTitle(uint which_one) const;
+
+  private:
+    void          Reset(void);
+
+  private:
+    dvd_reader_t *dvd;
+    bool          first_time;
+    QString       device;
+    QString       volume_name;
+    DVDTitleList  titles;
+};
+
+#endif  // dvdprobe_h_
diff --git a/mythtv/programs/mythmtd/fileobs.cpp b/mythtv/programs/mythmtd/fileobs.cpp
new file mode 100644
index 0000000..9a6d03c
--- /dev/null
+++ b/mythtv/programs/mythmtd/fileobs.cpp
@@ -0,0 +1,195 @@
+/*
+    fileobs.cpp
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    Implementation for file objects that know
+    how to do clever things
+
+*/
+
+#include <unistd.h>
+
+#include <mythcontext.h>
+#include <mythlogging.h>
+#include "fileobs.h"
+#include <QDir>
+
+RipFile::RipFile(const QString &a_base, const QString &an_extension,
+                 bool auto_remove_bad) :
+    base_name(a_base), extension(an_extension),
+    active_file(-1), bytes_written(0),
+    use_multiple_files(true),
+    auto_remove_bad_rips(auto_remove_bad)
+{
+    filesize = gCoreContext->GetNumSetting("MTDRipSize", 0) * 1024 * 1024;
+}
+
+bool RipFile::open(const QIODevice::OpenMode &mode, bool multiple_files)
+{
+    use_multiple_files = multiple_files;
+    access_mode        = mode;
+    active_file        = files.size();
+    files.push_back(new QFile(base_name + "_001of"));
+
+    return files[active_file]->open(access_mode);
+
+/*
+    if (!use_multiple_files)
+    {
+        filesize = 0;
+    }
+*/
+}
+
+QStringList RipFile::close()
+{
+    QStringList output_file_names;
+
+    auto_remove_bad_rips = false;
+
+    if (((uint)active_file) < (uint)files.size())
+        files[active_file]->close();
+
+    if (files.size() == 1)
+    {
+        active_file = 0;
+        QString new_name = base_name + extension;
+        if (!QDir::current().rename(files[active_file]->fileName(), new_name))
+        {
+            LOG(VB_GENERAL, LOG_ERR,
+                    "Couldn't rename a ripped file on close ... \n\t\t\t" +
+                    QString("old name: '%1'\n\t\t\t"
+                            "new name: '%2'")
+                    .arg(files[active_file]->fileName()).arg(new_name));
+        }
+        else
+        {
+            files[active_file]->setFileName(new_name);
+            output_file_names.push_back(new_name);
+        }
+    }
+    else
+    {
+        QList<QFile*>::iterator it = files.begin();
+        for (; it != files.end(); ++it)
+        {
+            // TODO FIXME This doesn't sense, Thor probably meant to
+            // use the index not files.size() as the middle value.
+            QString new_name = QString("%1%2%3")
+                .arg((*it)->fileName()).arg(files.size()).arg(extension);
+
+            if (!QDir::current().rename((*it)->fileName(), new_name))
+            {
+                LOG(VB_GENERAL, LOG_ERR, QString("Couldn't rename '%1' to '%2'")
+                        .arg((*it)->fileName()).arg(new_name));
+            }
+            else
+            {
+                (*it)->setFileName(new_name);
+                output_file_names.push_back(new_name);
+            }
+        }
+    }
+
+    return output_file_names;
+}
+
+void RipFile::remove()
+{
+    if (((uint)active_file) < (uint)files.size())
+        files[active_file]->close();
+
+    while (!files.empty())
+    {
+        files.back()->remove();
+        delete files.back();
+        files.pop_back();
+    }
+}
+
+QString RipFile::name(void) const
+{
+    if (((uint)active_file) < (uint)files.size())
+        return files[active_file]->fileName();
+    else
+        return QString::null;
+}
+
+bool RipFile::writeBlocks(unsigned char *the_data, int how_much)
+{
+    if (((uint)active_file) >= (uint)files.size())
+        return false;
+
+    if (filesize > 0 && how_much + bytes_written > filesize)
+    {
+        //
+        //  Need to break here
+        //
+        files[active_file]->close();
+
+        //
+        //  and start a new file
+        //
+
+        QString number_extension;
+        number_extension.sprintf("_%03dof", files.size() + 1);
+        active_file = files.size();
+        files.push_back(new QFile(base_name + number_extension));
+        if (!files[active_file]->open(access_mode))
+        {
+            LOG(VB_GENERAL, LOG_ERR,
+                    "couldn't open another file in a set of rip files.");
+            return false;
+        }
+        bytes_written = 0;
+    }
+
+    int result = write(files[active_file]->handle(), the_data, how_much);
+    if (result < 0)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Got a negative result while writing blocks."
+                " World may end shortly.");
+        return false;
+    }
+
+    if (result == 0)
+    {
+        if (how_much == 0)
+        {
+            LOG(VB_GENERAL, LOG_ERR, "Ripfile wrote 0 bytes, but that's all it"
+                    " was asked to. Unlikely coincidence?");
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_ERR, "Ripfile writing 0 bytes of data. That's"
+                    " probably not a good sign.");
+            return false;
+        }
+    }
+
+    if (result != how_much)
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("Ripfile tried to write %1 bytes, but"
+                                      " only managed to write %2")
+                                      .arg(how_much).arg(result));
+        return false;
+    }
+
+    bytes_written += result;
+
+    return true;
+}
+
+RipFile::~RipFile()
+{
+    if ((active_file >= 0) && auto_remove_bad_rips)
+        remove();
+
+    while (!files.empty())
+    {
+        delete files.back();
+        files.pop_back();
+    }
+}
diff --git a/mythtv/programs/mythmtd/fileobs.h b/mythtv/programs/mythmtd/fileobs.h
new file mode 100644
index 0000000..c3cc58e
--- /dev/null
+++ b/mythtv/programs/mythmtd/fileobs.h
@@ -0,0 +1,44 @@
+#ifndef FILEOBS_H_
+#define FILEOBS_H_
+/*
+    fileobs.h
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    Headers for file objects that know
+    how to do clever things
+
+*/
+
+#include <QFile>
+#include <QStringList>
+
+class RipFile
+{
+
+  public:
+
+    RipFile(const QString &a_base, const QString &an_extension,
+            bool auto_remove_bad);
+    ~RipFile();
+
+    bool    open(const QIODevice::OpenMode &mode, bool multiple_files);
+    QStringList close();
+    void    remove();
+    QString name(void) const;
+    bool    writeBlocks(unsigned char *the_data, int how_much);
+
+  private:
+    QString         base_name;
+    QString         extension;
+    int             filesize;
+    int             active_file;
+    int             bytes_written;
+    QIODevice::OpenMode access_mode;
+    QList<QFile*>   files;
+    bool            use_multiple_files;
+    bool            auto_remove_bad_rips;
+};
+
+#endif  // fileobs_h_
diff --git a/mythtv/programs/mythmtd/jobthread.cpp b/mythtv/programs/mythmtd/jobthread.cpp
new file mode 100644
index 0000000..4412aec
--- /dev/null
+++ b/mythtv/programs/mythmtd/jobthread.cpp
@@ -0,0 +1,1539 @@
+/*
+    jobthread.cpp
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    Where things actually happen
+
+*/
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include <algorithm>
+#include <vector>
+using namespace std;
+
+#include <QDateTime>
+#include <QDir>
+#include <QApplication>
+#include <QWaitCondition>
+#include <QProcess>
+
+#include <mythcontext.h>
+#include <mythdbcon.h>
+#include <compat.h>
+#include <mythmiscutil.h>
+#include <mythlogging.h>
+
+#include "jobthread.h"
+#include "mtd.h"
+#include "threadevents.h"
+#include "dvdprobe.h"
+
+//#define DEBUG_STAGE_2 "/path/to/vob/from/rip/stage/filaname.vob"
+
+namespace {
+    struct delete_file {
+        bool operator()(const QString &filename)
+        {
+            LOG(VB_GENERAL,LOG_INFO, QString("Deleting file: %1").arg(filename));
+            return QDir::current().remove(filename);
+        }
+    };
+}
+
+static QString shell_escape(const QString &orig)
+{
+    if (!orig.contains(' ') && !orig.contains('\t') &&
+        !orig.contains("'") && !orig.contains('\n') &&
+        !orig.contains('`') && !orig.contains('\r') &&
+        !orig.contains('"'))
+    {
+        return orig;
+    }
+
+    QString tmp = orig;
+    tmp.replace('"', "\\\"");
+    tmp.replace("`", "\\`");
+    return QString("\"%1\"").arg(tmp);
+};
+
+JobThread::JobThread(
+    MythTranscodeDaemon *owner,
+    const QString       &start_string,
+    int                  nice_priority) :
+    QThread(),
+
+    problem_string(""),
+    job_name(""),
+    subjob_name(""),
+    job_string(start_string),
+
+    overall_progress(0.0),
+    subjob_progress(0.0),
+    sub_to_overall_multiple(1.0),
+    parent(owner),
+    nice_level(nice_priority),
+
+    cancelLock(new QMutex()),
+    cancelWaitCond(new QWaitCondition()),
+    cancel_me(false)
+{
+}
+
+JobThread::~JobThread()
+{
+    delete cancelLock;
+    delete cancelWaitCond;
+}
+
+void JobThread::run(void)
+{
+    LOG(VB_GENERAL, LOG_ERR,
+            "Programmer Error: JobThread::run() needs to be subclassed");
+}
+
+void JobThread::Cancel(bool chatty)
+{
+    if (chatty)
+    {
+        SetSubProgress(0.0, 0);
+        SetSubName("Cancelling ...", 0);
+    }
+
+    QMutexLocker locker(cancelLock);
+    cancel_me = true;
+    cancelWaitCond->wakeAll();
+}
+
+bool JobThread::IsCancelled(void) const
+{
+    QMutexLocker locker(cancelLock);
+    return cancel_me;
+}
+
+QString JobThread::GetLastProblem(void) const
+{
+    QMutexLocker qml(&problem_string_mutex);
+    QString tmp = problem_string; tmp.detach();
+    return tmp;
+}
+
+QString JobThread::GetJobString(void) const
+{
+    QMutexLocker qml(&job_string_mutex);
+    QString tmp = job_string; tmp.detach();
+    return tmp;
+}
+
+void JobThread::UpdateSubjobString(int seconds_elapsed,
+                                   const QString &pre_string)
+{
+    int estimated_job_time = 0;
+    if (subjob_progress > 0.0)
+    {
+        estimated_job_time = (int)
+            ( (double) seconds_elapsed / subjob_progress );
+    }
+    else
+    {
+        estimated_job_time = (int)
+            ( (double) seconds_elapsed / 0.000001 );
+    }
+
+    QString new_name = "";
+    if (estimated_job_time >= 3600)
+    {
+        new_name.sprintf(" %d:%02d:%02d/%d:%02d:%02d",
+                         seconds_elapsed / 3600,
+                         (seconds_elapsed % 3600) / 60,
+                         (seconds_elapsed % 3600) % 60,
+                         estimated_job_time / 3600,
+                         (estimated_job_time % 3600) / 60,
+                         (estimated_job_time % 3600) % 60);
+    }
+    else
+    {
+        new_name.sprintf(" %02d:%02d/%02d:%02d",
+                         seconds_elapsed / 60,
+                         seconds_elapsed % 60,
+                         estimated_job_time / 60,
+                         estimated_job_time % 60);
+    }
+    new_name.prepend(pre_string);
+    SetSubName(new_name, 1);
+}
+
+void JobThread::SetSubProgress(double some_value, uint priority)
+{
+    if (priority > 0)
+    {
+        while (!subjob_progress_mutex.tryLock())
+        {
+            QMutexLocker locker(cancelLock);
+            if (!cancel_me)
+                cancelWaitCond->wait(cancelLock, 1000 * priority);
+        }
+
+        if (!IsCancelled())
+            subjob_progress = some_value;
+    }
+    else
+    {
+        subjob_progress_mutex.lock();
+        if (!IsCancelled())
+            subjob_progress = some_value;
+    }
+    subjob_progress_mutex.unlock();
+}
+
+void JobThread::SetSubName(const QString &new_name, uint priority)
+{
+    if (priority > 0)
+    {
+        while (!subjob_name_mutex.tryLock())
+        {
+            QMutexLocker locker(cancelLock);
+            if (!cancel_me)
+                cancelWaitCond->wait(cancelLock, 1000 * priority);
+        }
+
+        if (!IsCancelled())
+            subjob_name = new_name;
+    }
+    else
+    {
+        subjob_name_mutex.lock();
+        if (!IsCancelled())
+            subjob_name = new_name;
+    }
+    subjob_name_mutex.unlock();
+
+}
+
+QString JobThread::GetJobName(void) const
+{
+    QMutexLocker qml(&job_name_mutex);
+    QString tmp = job_name; tmp.detach();
+    return tmp;
+}
+
+QString JobThread::GetSubName(void) const
+{
+    QMutexLocker qml(&subjob_name_mutex);
+    QString tmp = subjob_name; tmp.detach();
+    return tmp;
+}
+
+void JobThread::SendProblemEvent(const QString &a_problem)
+{
+    ErrorEvent *ee = new ErrorEvent(a_problem);
+    QApplication::postEvent(parent, ee);
+
+    SetLastProblem(a_problem);
+}
+
+void JobThread::SendLoggingEvent(const QString &event_string)
+{
+    LoggingEvent *le = new LoggingEvent(event_string);
+    QApplication::postEvent(parent, le);
+}
+
+void JobThread::SetJobName(const QString &jname)
+{
+    QMutexLocker qml(&job_name_mutex);
+    job_name = jname;
+    job_name.detach();
+}
+
+void JobThread::SetLastProblem(const QString &prob)
+{
+    QMutexLocker qml(&problem_string_mutex);
+    problem_string = prob;
+    problem_string.detach();
+}
+
+/*
+---------------------------------------------------------------------
+*/
+
+namespace
+{
+    class MutexUnlocker
+    {
+      public:
+        MutexUnlocker(QMutex *mutex) : m_mutex(mutex)
+        {
+            if (!m_mutex)
+            {
+                LOG(VB_GENERAL, LOG_ERR,
+                        QString("%1: Invalid mutex passed to MutexUnlocker")
+                        .arg(__FILE__));
+            }
+        }
+
+        ~MutexUnlocker()
+        {
+            m_mutex->unlock();
+        }
+
+      private:
+        QMutex *m_mutex;
+    };
+
+    template <typename HTYPE>
+    struct is_handle_null
+    {
+        bool operator()(HTYPE handle)
+        {
+            return handle == NULL;
+        }
+    };
+
+    template <typename HTYPE>
+    struct is_bad_stdio_handle
+    {
+        bool operator()(HTYPE handle)
+        {
+            return handle == -1;
+        }
+    };
+
+    template <typename HTYPE, typename CLEANF_RET = void,
+             typename handle_checker = is_handle_null<HTYPE> >
+    class SmartHandle
+    {
+      private:
+        typedef CLEANF_RET (*clean_fun_t)(HTYPE);
+
+      public:
+        SmartHandle(HTYPE handle, clean_fun_t cleaner) : m_handle(handle),
+                                                         m_cleaner(cleaner)
+        {
+        }
+
+        ~SmartHandle()
+        {
+            handle_checker hc;
+            if (!hc(m_handle))
+            {
+                m_cleaner(m_handle);
+            }
+        }
+
+        HTYPE get()
+        {
+            return m_handle;
+        }
+
+        HTYPE operator->()
+        {
+            return m_handle;
+        }
+
+      private:
+        HTYPE m_handle;
+        clean_fun_t m_cleaner;
+    };
+}
+
+DVDThread::DVDThread(
+    MythTranscodeDaemon *owner,
+    QMutex              *drive_mutex,
+    const QString       &dvd_device,
+    int                  track,
+    const QString       &dest_file,
+    const QString       &name,
+    const QString       &start_string,
+    int                  nice_priority) :
+    JobThread(owner, start_string, nice_priority),
+    dvd_device_access(drive_mutex),
+    dvd_device_location(dvd_device),
+    destination_file_string(dest_file),
+    dvd_title(track - 1),
+    rip_name(name)
+{
+}
+
+void DVDThread::run(void)
+{
+    LOG(VB_GENERAL, LOG_ERR,
+            "Programmer Error: DVDThread::run() needs to be subclassed");
+}
+
+bool DVDThread::ripTitle(int            title_number,
+                         const QString &to_location,
+                         const QString &extension,
+                         bool           multiple_files,
+                         QStringList   *output_files)
+{
+    //  Can't do much until I have a lock on the device
+    SetSubName(QObject::tr("Waiting For Access to DVD"), 1);
+    bool loop = true;
+    while (loop)
+    {
+        if (dvd_device_access->tryLock())
+        {
+            loop = false;
+        }
+        else
+        {
+            QMutexLocker locker(cancelLock);
+            if (!cancel_me)
+                cancelWaitCond->wait(cancelLock, 5000);
+
+            if (cancel_me)
+            {
+                SendProblemEvent("abandoned job because master control "
+                                 "said we need to shut down");
+                return false;
+            }
+        }
+    }
+
+    MutexUnlocker qmul(dvd_device_access);
+
+    if (IsCancelled())
+    {
+        SendProblemEvent("abandoned job because master control "
+                         "said we need to shut down");
+        return false;
+    }
+
+    SendLoggingEvent("job thread beginning to rip dvd title");
+
+#ifdef DEBUG_STAGE_2
+    if (output_files)
+        *output_files = QStringList(DEBUG_STAGE_2);
+    SendLoggingEvent("job thread finished ripping dvd title");
+    return true;
+#endif // DEBUG_STAGE_2
+
+    // OK, we got the device lock. Lets open our destination file
+    RipFile ripfile(to_location, extension, true);
+    if (!ripfile.open(QIODevice::WriteOnly | QIODevice::Unbuffered |
+                      QIODevice::Truncate, multiple_files))
+    {
+        SendProblemEvent(
+            QString("DVDPerfectThread could not open output file: '%1'")
+            .arg(ripfile.name()));
+        return false;
+    }
+
+    // Time to open up access with all the funky structs from libdvdnav
+    int angle = 0; // TODO Change this at some point
+    QByteArray dvd_dev_loc = dvd_device_location.toLocal8Bit();
+    SmartHandle<dvd_reader_t *> the_dvd(
+        DVDOpen(dvd_dev_loc.constData()), DVDClose);
+
+    if (!the_dvd.get())
+    {
+        SendProblemEvent(
+            QString("DVDPerfectThread could not access this dvd device: '%1'")
+            .arg(dvd_device_location));
+        return false;
+    }
+
+    SmartHandle<ifo_handle_t *> vmg_file(ifoOpen(the_dvd.get(), 0), ifoClose);
+    if (!vmg_file.get())
+    {
+        SendProblemEvent("DVDPerfectThread could not open VMG info.");
+        return false;
+    }
+    tt_srpt_t *tt_srpt = vmg_file->tt_srpt;
+
+    //  Check title # is valid
+    if (title_number < 0 || title_number > tt_srpt->nr_of_srpts )
+    {
+        SendProblemEvent(
+            QString("DVDPerfectThread could not open title number %1")
+            .arg(title_number + 1));
+        return false;
+    }
+
+    SmartHandle<ifo_handle_t *> vts_file(
+            ifoOpen(the_dvd.get(), tt_srpt->title[title_number].title_set_nr),
+            ifoClose);
+    if (!vts_file.get())
+    {
+        SendProblemEvent(
+            "DVDPerfectThread could not open the title's info file");
+        return false;
+    }
+
+    //  Determine the program chain (?)
+    int             ttn          = tt_srpt->title[title_number].vts_ttn;
+    vts_ptt_srpt_t *vts_ptt_srpt = vts_file->vts_ptt_srpt;
+    int             pgc_id       = vts_ptt_srpt->title[ttn-1].ptt[0].pgcn;
+    int             pgn          = vts_ptt_srpt->title[ttn-1].ptt[0].pgn;
+    pgc_t          *cur_pgc      = vts_file->vts_pgcit->pgci_srp[pgc_id-1].pgc;
+    int             start_cell   = cur_pgc->program_map[pgn-1]-1;
+
+    //  Hmmmm ... need some sort of total to calculate
+    //  progress display against .... I guess disc
+    //  sectors will have to do ....
+    int total_sectors = 0;
+    for (int i = start_cell; i < cur_pgc->nr_of_cells; i++)
+    {
+        total_sectors += (cur_pgc->cell_playback[i].last_sector -
+                          cur_pgc->cell_playback[i].first_sector);
+    }
+
+    //  OK ... now actually open
+    SmartHandle<dvd_file_t *> title(
+            DVDOpenFile(the_dvd.get(),
+                    tt_srpt->title[title_number].title_set_nr,
+                    DVD_READ_TITLE_VOBS),
+            DVDCloseFile);
+
+    if (!title.get())
+    {
+        SendProblemEvent(
+            "DVDPerfectThread could not open the title's actual VOB(s)");
+        return false;
+    }
+
+    int sector_counter = 0;
+
+    QTime job_time;
+    job_time.start();
+
+    vector<unsigned char> video_data(1024 * DVD_VIDEO_LB_LEN);
+
+    int next_cell = start_cell;
+    for (int cur_cell = start_cell; next_cell < cur_pgc->nr_of_cells; )
+    {
+        cur_cell = next_cell;
+        if (cur_pgc->cell_playback[cur_cell].block_type ==
+            BLOCK_TYPE_ANGLE_BLOCK)
+        {
+
+            cur_cell += angle;
+            for (int i=0;; ++i)
+            {
+                if (cur_pgc->cell_playback[cur_cell + i].block_mode ==
+                    BLOCK_MODE_LAST_CELL)
+                {
+                    next_cell = cur_cell + i + 1;
+                    break;
+                }
+             }
+         }
+         else
+         {
+            next_cell = cur_cell + 1;
+         }
+
+         // Loop until we're out of this cell
+         for (uint cur_pack = cur_pgc->cell_playback[cur_cell].first_sector;
+              cur_pack < cur_pgc->cell_playback[cur_cell].last_sector; )
+         {
+            dsi_t dsi_pack;
+            unsigned int next_vobu, cur_output_size;
+
+            //  Read the NAV packet.
+            int len = DVDReadBlocks(title.get(), (int) cur_pack, 1,
+                                    &video_data[0]);
+            if ( len != 1)
+            {
+                SendProblemEvent(
+                    QString("DVDPerfectThread read failed for block %1")
+                    .arg(cur_pack));
+                return false;
+            }
+
+            //  Parse the contained dsi packet
+            navRead_DSI(&dsi_pack, &video_data[DSI_START_BYTE]);
+
+            //  Figure out where to go next
+            cur_output_size = dsi_pack.dsi_gi.vobu_ea;
+
+            if (dsi_pack.vobu_sri.next_vobu != SRI_END_OF_CELL )
+            {
+                next_vobu = cur_pack +
+                    ( dsi_pack.vobu_sri.next_vobu & 0x7fffffff );
+            }
+            else
+            {
+                next_vobu = cur_pack + cur_output_size + 1;
+            }
+
+            cur_pack++;
+            sector_counter++;
+
+            //  Read in cursize packs
+            len = DVDReadBlocks(
+                title.get(), (int)cur_pack, cur_output_size, &video_data[0]);
+            if (len != (int) cur_output_size)
+            {
+                SendProblemEvent(QString("DVDPerfectThread read failed for %1 "
+                                         "blocks at %2")
+                                 .arg(cur_output_size).arg(cur_pack));
+                return false;
+            }
+
+            if (IsCancelled())
+            {
+                SendProblemEvent("abandoned job because master control "
+                                 "said we need to shut down");
+                return false;
+            }
+
+            // Set the progress and write out the blocks..
+            SetSubProgress((double) (sector_counter) /
+                           (double) (total_sectors), 1);
+            overall_progress = subjob_progress * sub_to_overall_multiple;
+            UpdateSubjobString(job_time.elapsed() / 1000,
+                               QObject::tr("Ripping to file ~"));
+            if (!ripfile.writeBlocks(&video_data[0],
+                            cur_output_size * DVD_VIDEO_LB_LEN))
+            {
+                SendProblemEvent("Couldn't write blocks during a rip. "
+                                 "Filesystem size exceeded? Disc full?");
+                return false;
+            }
+
+            sector_counter += next_vobu - cur_pack;
+            cur_pack = next_vobu;
+
+            if (IsCancelled())
+            {
+                SendProblemEvent("abandoned job because master control "
+                                 "said we need to shut down");
+                return false;
+            }
+        }
+    }
+
+    // Wow, we're done.
+    QStringList sl = ripfile.close();
+
+    if (output_files)
+        *output_files = sl;
+
+    SendLoggingEvent("job thread finished ripping dvd title");
+
+    LOG(VB_GENERAL,LOG_INFO, QString("Output files from rip: '") +
+            sl.join("','") + "'");
+
+    return true;
+}
+
+DVDThread::~DVDThread()
+{
+}
+
+/*
+---------------------------------------------------------------------
+*/
+
+DVDISOCopyThread::DVDISOCopyThread(
+    MythTranscodeDaemon *owner,
+    QMutex              *drive_mutex,
+    const QString       &dvd_device,
+    int                  track,
+    const QString       &dest_file,
+    const QString       &name,
+    const QString       &start_string,
+    int                  nice_priority) :
+    DVDThread(owner, drive_mutex, dvd_device, track, dest_file, name,
+              start_string, nice_priority)
+{
+    SendLoggingEvent(QString("Using DVD source: %1").arg(dvd_device));
+}
+
+void DVDISOCopyThread::run(void)
+{
+    myth_nice(nice_level);
+    SetJobName(QString(QObject::tr("ISO copy of %1")).arg(rip_name));
+    if (!IsCancelled())
+    {
+        copyFullDisc();
+    }
+}
+
+bool DVDISOCopyThread::copyFullDisc(void)
+{
+    bool loop = true;
+
+    SetSubName(QObject::tr("Waiting for access to DVD"), 1);
+
+    while (loop)
+    {
+        if (dvd_device_access->tryLock())
+        {
+            loop = false;
+        }
+        else
+        {
+            QMutexLocker locker(cancelLock);
+            if (!cancel_me)
+                cancelWaitCond->wait(cancelLock, 5000);
+
+            if (cancel_me)
+            {
+                SendProblemEvent("abandoned job because master control "
+                                 "said we need to shut down");
+                return false;
+            }
+        }
+    }
+
+    MutexUnlocker qmul(dvd_device_access);
+    if (IsCancelled())
+    {
+        SendProblemEvent("abandoned job because master control "
+                         "said we need to shut down");
+        return false;
+    }
+
+    RipFile ripfile(destination_file_string, ".iso", true);
+    if (!ripfile.open(QIODevice::WriteOnly | QIODevice::Unbuffered |
+                      QIODevice::Truncate, false))
+    {
+        SendProblemEvent(
+            QString("DVDISOCopyThread could not open output file: %1")
+            .arg(ripfile.name()));
+        return false;
+    }
+
+    SendLoggingEvent(QString("ISO DVD image copy to: %1").arg(ripfile.name()));
+
+    QByteArray dvd_dev_loc = dvd_device_location.toLocal8Bit();
+    SmartHandle<int, int, is_bad_stdio_handle<int> > file(
+        open(dvd_dev_loc.constData(), O_RDONLY), close);
+
+    if (file.get() == -1)
+    {
+        SendProblemEvent(
+            QString("DVDISOCopyThread could not open dvd device: %1")
+            .arg(dvd_device_location));
+        return false;
+    }
+
+    off_t dvd_size = lseek(file.get(), 0, SEEK_END);
+    lseek(file.get(), 0, SEEK_SET);
+
+    // Only happens on Darwin?
+    if (dvd_size < 2048)
+        SendLoggingEvent(QString("DVDISOCopyThread: bad disk size (%1 bytes)")
+                         .arg(dvd_size));
+
+    const int buf_size = 1024 * 1024;
+    std::vector<unsigned char> buffer(buf_size);
+    long long total_bytes(0);
+
+    QTime job_time;
+    job_time.start();
+
+    while (1)
+    {
+        int bytes_read = read(file.get(), &buffer[0], buf_size);
+        if (bytes_read == -1)
+        {
+            perror("read");
+            SendProblemEvent("DVDISOCopyThread dvd device read error");
+            return false;
+        }
+        if (bytes_read == 0)
+        {
+            break;
+        }
+
+        if (!ripfile.writeBlocks(&buffer[0], bytes_read))
+        {
+            SendProblemEvent("DVDISOCopyThread rip file write error");
+            return false;
+        }
+
+        total_bytes += bytes_read;
+
+        SetSubProgress((double) (total_bytes) / (double) (dvd_size), 1);
+        overall_progress = subjob_progress * sub_to_overall_multiple;
+        UpdateSubjobString(job_time.elapsed() / 1000,
+                           QObject::tr("Ripping to file ~"));
+
+        //  Escape out and clean up if mtd main thread tells us to
+        if (IsCancelled())
+        {
+            SendProblemEvent("abandoned job because master control "
+                             "said we need to shut down");
+            return false;
+        }
+    }
+
+    ripfile.close();
+    SendLoggingEvent("job thread finished copying ISO image");
+    return true;
+}
+
+DVDISOCopyThread::~DVDISOCopyThread()
+{
+}
+
+/*
+---------------------------------------------------------------------
+*/
+
+DVDPerfectThread::DVDPerfectThread(
+    MythTranscodeDaemon *owner,
+    QMutex              *drive_mutex,
+    const QString       &dvd_device,
+    int                  track,
+    const QString       &dest_file,
+    const QString       &name,
+    const QString       &start_string,
+    int nice_priority) :
+    DVDThread(owner, drive_mutex, dvd_device, track, dest_file, name,
+              start_string, nice_priority)
+{
+}
+
+void DVDPerfectThread::run(void)
+{
+    myth_nice(nice_level);
+
+    SetJobName(QString(QObject::tr("Perfect DVD Rip of %1")).arg(rip_name));
+
+    if (!IsCancelled())
+        ripTitle(dvd_title, destination_file_string, ".vob", true);
+}
+
+DVDPerfectThread::~DVDPerfectThread()
+{
+}
+
+/*
+---------------------------------------------------------------------
+*/
+
+DVDTranscodeThread::DVDTranscodeThread(
+    MythTranscodeDaemon *owner,
+    QMutex              *drive_mutex,
+    const QString       &dvd_device,
+    int                  track,
+    const QString       &dest_file,
+    const QString       &name,
+    const QString       &start_string,
+    int                  nice_priority,
+    int                  quality_level,
+    bool                 do_ac3,
+    int                  which_audio,
+    int                  numb_seconds,
+    int                  subtitle_track_numb) :
+    DVDThread(owner, drive_mutex, dvd_device, track, dest_file, name,
+              start_string, nice_priority),
+    used_transcode_slot(false),
+
+    quality(quality_level),
+    working_directory(NULL),
+    two_pass(false),
+    audio_track(which_audio),
+    ac3_flag(do_ac3),
+    subtitle_track(subtitle_track_numb),
+    secs_mult(1.0f),
+    tc_process(NULL),
+    tc_command(QString::null),
+    tc_current_pass(0),
+    tc_tick_tock(0),
+    tc_seconds_encoded(0),
+    tc_timer(0)
+{
+    uint length_in_seconds = (numb_seconds) ? numb_seconds : 1;
+    secs_mult = 1.0f / length_in_seconds;
+    moveToThread(this);
+}
+
+void DVDTranscodeThread::run(void)
+{
+    myth_nice(nice_level);
+
+    // Make working directory
+    if (IsCancelled() || !makeWorkingDirectory())
+        return;
+
+    if (IsCancelled())
+        return;
+
+    // Build the transcode command line. We do this early
+    // (before ripping) so we can figure out if this is
+    // a two pass job or not (for the progress display)
+    if (!buildTranscodeCommandLine(1))
+    {
+        cleanUp();
+        return;
+    }
+
+    if (two_pass)
+    {
+        SetJobName(QString(QObject::tr("Transcode of %1")).arg(rip_name));
+        sub_to_overall_multiple = 0.333333333;
+    }
+    else
+    {
+        SetJobName(QString(QObject::tr("Transcode of %1")).arg(rip_name));
+        sub_to_overall_multiple = 0.50;
+    }
+
+    if (IsCancelled())
+        return;
+
+    //  Rip VOB to working directory
+    QStringList output_files;
+    QString rip_file_string = QString("%1/vob/%2")
+        .arg(working_directory->path()).arg(rip_name);
+    if (!ripTitle(dvd_title, rip_file_string, ".vob", true, &output_files))
+    {
+        cleanUp();
+        return;
+    }
+
+    // Get permission to start transcoding from MTD instance.
+    SetSubName(QObject::tr("Waiting for Permission to Start Transcoding"), 1);
+    bool loop = true;
+    while (loop)
+    {
+        if (parent->IncrConcurrentTranscodeCounter() && !IsCancelled())
+        {
+            used_transcode_slot = true;
+            loop = false;
+        }
+        else
+        {
+            QMutexLocker locker(cancelLock);
+            if (!cancel_me)
+                cancelWaitCond->wait(cancelLock, 5000);
+
+            if (cancel_me)
+            {
+                SendProblemEvent("abandoned job because master control "
+                                 "said we need to shut down");
+                return;
+            }
+        }
+    }
+
+    //  Run the first (only?) crack at transcoding
+    if (!IsCancelled() && !runTranscode(1))
+    {
+        wipeClean();
+        return;
+    }
+
+    // Second pass, if enabled
+    if (two_pass && !IsCancelled() && !runTranscode(2))
+        wipeClean();
+
+#ifndef DEBUG_STAGE_2
+    if (!gCoreContext->GetNumSetting("mythdvd.mtd.SaveTranscodeIntermediates", 0))
+    {
+        // remove any temporary titles that are now transcoded
+        std::for_each(output_files.begin(), output_files.end(), delete_file());
+    }
+#endif
+
+    cleanUp();
+}
+
+void DVDTranscodeThread::Cancel(bool chatty)
+{
+    DVDThread::Cancel(chatty);
+#if 0 // Timers must be started/stopped in the thread owning the event loop
+    QMutexLocker locker(cancelLock);
+    if (tc_timer)
+    {
+        killTimer(tc_timer);
+        tc_timer = QObject::startTimer(0);
+    }
+#endif
+}
+
+bool DVDTranscodeThread::makeWorkingDirectory(void)
+{
+    QString dir_name = gCoreContext->GetSetting("DVDRipLocation");
+    if (dir_name.isEmpty())
+    {
+        SendProblemEvent("could not find rip directory in settings");
+        return false;
+    }
+
+    working_directory = new QDir(dir_name);
+    if (!working_directory->exists())
+    {
+        SendProblemEvent(QString("rip directory '%1' does not seem to exist")
+                         .arg(dir_name));
+        return false;
+    }
+
+#ifndef DEBUG_STAGE_2
+    if (!working_directory->exists(rip_name) &&
+        !working_directory->mkdir(rip_name))
+    {
+        SendProblemEvent(QString("Could not create directory called '%1/%2' ")
+                         .arg(dir_name).arg(rip_name));
+        return false;
+    }
+#endif
+
+    if (!working_directory->cd(rip_name))
+    {
+        SendProblemEvent(QString("Could not cd into '%1/%2'")
+                         .arg(dir_name).arg(rip_name));
+        return false;
+    }
+
+#ifndef DEBUG_STAGE_2
+    if (!working_directory->exists("vob") &&
+        !working_directory->mkdir("vob"))
+    {
+        SendProblemEvent(QString("could not create a vob subdirectory "
+                                 "in the working directory '%1/%2'")
+                         .arg(dir_name).arg(rip_name));
+        return false;
+    }
+#endif
+
+    return true;
+}
+
+bool DVDTranscodeThread::buildTranscodeCommandLine(int which_run)
+{
+    //  If our destination file already exists, bail out
+    QFile a_file(QString("%1.avi").arg(destination_file_string));
+    if (a_file.exists())
+    {
+        SendProblemEvent("Transcode cannot run, "
+                         "destination file already exists");
+        return false;
+    }
+
+    tc_command = gCoreContext->GetSetting("TranscodeCommand");
+    if (tc_command.isEmpty())
+    {
+        SendProblemEvent(
+            "There is no TranscodeCommand setting for this system");
+        return false;
+    }
+
+    tc_arguments.clear();
+
+    MSqlQuery a_query(MSqlQuery::InitCon());
+    a_query.prepare(
+        "SELECT sync_mode, use_yv12,    "
+        "   cliptop,     clipbottom,  clipleft,    clipright,   "
+        "   f_resize_h,  f_resize_w,  hq_resize_h, hq_resize_w, "
+        "   grow_h,      grow_w,                                "
+        "   clip2top,    clip2bottom, clip2left,   clip2right,  "
+        "   codec,       codec_param, "
+        "   bitrate,     a_sample_r,  a_bitrate,   "
+        "   input,       name,        two_pass,    tc_param     "
+        "FROM dvdtranscode "
+        "WHERE intid = :INTID");
+    a_query.bindValue(":INTID", quality);
+
+    if (!a_query.exec())
+    {
+        SendProblemEvent("buildTranscodeCommandLine query failed 1");
+        return false;
+    }
+
+    if (!a_query.next())
+    {
+        SendProblemEvent("buildTranscodeCommandLine query null return 1");
+        return false;
+    }
+
+    // Convert query results to named variables
+    int       sync_mode = a_query.value(0).toInt();
+    int         cliptop = a_query.value(2).toInt();
+    int      clipbottom = a_query.value(3).toInt();
+    int        clipleft = a_query.value(4).toInt();
+    int       clipright = a_query.value(5).toInt();
+    int      f_resize_h = a_query.value(6).toInt();
+    int      f_resize_w = a_query.value(7).toInt();
+    int     hq_resize_h = a_query.value(8).toInt();
+    int     hq_resize_w = a_query.value(9).toInt();
+    int          grow_h = a_query.value(10).toInt();
+    int          grow_w = a_query.value(11).toInt();
+    int        clipttop = a_query.value(12).toInt();
+    int     cliptbottom = a_query.value(13).toInt();
+    int       cliptleft = a_query.value(14).toInt();
+    int      cliptright = a_query.value(15).toInt();
+    QString       codec = a_query.value(16).toString();
+    QString codec_param = a_query.value(17).toString();
+    int         bitrate = a_query.value(18).toInt();
+    int      a_sample_r = a_query.value(19).toInt();
+    int       a_bitrate = a_query.value(20).toInt();
+    int   input_setting = a_query.value(21).toInt();
+    QString        name = a_query.value(22).toString();
+    two_pass = a_query.value(23).toBool();
+    QString    tc_param = a_query.value(24).toString();
+
+    // And now, another query to get frame rate code and
+    //input video dimensions from the dvdinput table
+    a_query.prepare(
+        "SELECT hsize, vsize, fr_code "
+        "FROM dvdinput "
+        "WHERE intid = :INTID");
+    a_query.bindValue(":INTID", input_setting);
+
+    if (!a_query.exec())
+    {
+        SendProblemEvent("buildTranscodeCommandLine query failed 2");
+        return false;
+    }
+
+    if (!a_query.next())
+    {
+        SendProblemEvent("buildTranscodeCommandLine query null return 2");
+        return false;
+    }
+
+    int input_hsize = a_query.value(0).toInt();
+    int input_vsize = a_query.value(1).toInt();
+    int fr_code = a_query.value(2).toInt();
+
+    QProcess versionCheck;
+
+    QString version;
+    versionCheck.setReadChannelMode(QProcess::MergedChannels);
+    versionCheck.start("transcode", QStringList() << "-v");
+    versionCheck.waitForFinished();
+    QByteArray result = versionCheck.readAll();
+    QString resultString(result);
+
+    if (resultString.contains("v1.0"))
+        version = "1.0";
+    else if (resultString.contains("v1.1"))
+        version = "1.1";
+
+    LOG(VB_GENERAL,LOG_INFO, QString("Found Transcode Version: %1").arg(version));
+
+    //  Check if we are doing subtitles
+    if (subtitle_track > -1)
+    {
+        QString subtitle_arguments = QString("extsub=track=%1")
+            .arg(subtitle_track);
+
+        if (cliptbottom > 0)
+        {
+            subtitle_arguments.push_back(QString(":vershift=%1")
+                                         .arg(cliptbottom));
+        }
+        tc_arguments.push_back("-x");
+        tc_arguments.push_back("vob");
+        tc_arguments.push_back("-J");
+
+        tc_arguments.push_back(subtitle_arguments);
+    }
+
+    tc_arguments.push_back("-i");
+    tc_arguments.push_back(QString("%1/vob/").arg(working_directory->path()));
+    tc_arguments.push_back("-g");
+    tc_arguments.push_back(QString("%1x%2").arg(input_hsize).arg(input_vsize));
+
+    if (!gCoreContext->GetNumSetting("mythvideo.TrustTranscodeFRDetect"))
+    {
+        tc_arguments.push_back("-f");
+        tc_arguments.push_back(QString("0,%1").arg(fr_code));
+    }
+
+    tc_arguments.push_back("-M");
+    tc_arguments.push_back(QString("%1").arg(sync_mode));
+
+    //  The order of these is defined by transcode
+    if (clipbottom || cliptop || clipleft || clipright)
+    {
+        tc_arguments.push_back("-j");
+        tc_arguments.push_back(
+            QString("%1,%2,%3,%4")
+            .arg(cliptop).arg(clipleft).arg(clipbottom).arg(clipright));
+    }
+    if (grow_h > 0 || grow_w > 0)
+    {
+        tc_arguments.push_back("-X");
+        tc_arguments.push_back(QString("%1,%2").arg(grow_h).arg(grow_w));
+    }
+    if (f_resize_h > 0 || f_resize_w > 0)
+    {
+        tc_arguments.push_back("-B");
+        tc_arguments.push_back(
+            QString("%1,%2").arg(f_resize_h).arg(f_resize_w));
+    }
+    if (hq_resize_h > 0 && hq_resize_w > 0)
+    {
+        tc_arguments.push_back("-Z");
+        tc_arguments.push_back(
+            QString("%1x%2").arg(hq_resize_w).arg(hq_resize_h));
+    }
+    if (cliptbottom || clipttop || cliptleft || cliptright)
+    {
+        tc_arguments.push_back("-Y");
+        tc_arguments.push_back(
+            QString("%1,%2,%3,%4")
+            .arg(clipttop).arg(cliptleft).arg(cliptbottom).arg(cliptright));
+    }
+
+    if (codec.isEmpty())
+    {
+        SendProblemEvent("Yo! Kaka-brain! Can't transcode without a codec");
+        return false;
+    }
+
+    if (codec.contains("divx") && gCoreContext->GetNumSetting("MTDxvidFlag"))
+    {
+        codec = "xvid";
+    }
+
+    tc_arguments.push_back("-y");
+    // in two pass, the audio from first pass is garbage
+    if (two_pass && which_run == 1)
+        tc_arguments.push_back(QString("%1,null").arg(codec));
+    else
+        tc_arguments.push_back(codec);
+
+    if (codec_param.length())
+    {
+        tc_arguments.push_back("-F");
+        tc_arguments.push_back(codec_param);
+    }
+
+    if (tc_param.length())
+    {
+        tc_arguments += tc_param.split(" ", QString::SkipEmptyParts);
+    }
+
+    if (bitrate > 0)
+    {
+        tc_arguments.push_back("-w");
+        tc_arguments.push_back(QString("%1").arg(bitrate));
+    }
+
+    if (ac3_flag && !name.contains("VCD", Qt::CaseInsensitive))
+    {
+        tc_arguments.push_back("-A");
+        tc_arguments.push_back("-N");
+        tc_arguments.push_back("0x2000");
+    }
+    else
+    {
+        if (a_sample_r > 0)
+        {
+            tc_arguments.push_back("-E");
+            tc_arguments.push_back(QString("%1").arg(a_sample_r));
+        }
+        if (a_bitrate > 0)
+        {
+            tc_arguments.push_back("-b");
+            tc_arguments.push_back(QString("%1").arg(a_bitrate));
+        }
+    }
+    if (audio_track > 1)
+    {
+        tc_arguments.push_back("-a");
+        tc_arguments.push_back(QString("%1").arg(audio_track - 1));
+    }
+
+    tc_arguments.push_back("-o");
+
+    // In a two pass encoding the video from the first run is garbage,
+    // so redirect it to /dev/null
+    tc_arguments.push_back(
+        (two_pass && which_run == 1) ?
+        QString("/dev/null") : QString("%1.avi").arg(destination_file_string));
+
+    if (version == "1.0")
+    {
+        tc_arguments.push_back("--color");
+        tc_arguments.push_back("0");
+    }
+    else
+    {
+        tc_arguments.push_back("--progress_rate");
+        tc_arguments.push_back("20");
+        tc_arguments.push_back("--progress_meter");
+        tc_arguments.push_back("2");
+        tc_arguments.push_back("--log_no_color");
+    }
+
+    if (two_pass)
+    {
+        tc_arguments.push_back("-R");
+        tc_arguments.push_back(QString("%1,twopass.log").arg(which_run));
+    }
+
+    // Produce shell safe version of command for user cut-n-paste
+    QStringList args;
+    for (int i = 0; i < tc_arguments.size(); i++)
+        args.push_back(shell_escape(tc_arguments[i]));
+    QString transcode_command_string =
+        QString("transcode command will be: '%1 %2'")
+        .arg(tc_command).arg(args.join(" "));
+
+    SendLoggingEvent(transcode_command_string);
+
+    return true;
+}
+
+bool DVDTranscodeThread::runTranscode(int which_run)
+{
+    // Set description strings to let the user
+    // know what is going on.
+
+    SendLoggingEvent(QString("runTranscode pass %1").arg(which_run));
+    SetSubName(QObject::tr("Transcode is thinking..."), 1);
+    SetSubProgress(0.0, 1);
+
+    // Second pass?
+    if ((which_run > 1) && !buildTranscodeCommandLine(which_run))
+    {
+        SendProblemEvent("Problem building second pass command line.");
+        return false;
+    }
+
+    tc_process = new QProcess();
+    tc_process->setWorkingDirectory(working_directory->path());
+    tc_process->setProcessChannelMode(QProcess::MergedChannels);
+    tc_process->setReadChannel(QProcess::StandardOutput);
+    tc_process->start(tc_command, tc_arguments);
+
+    if (!tc_process->waitForStarted())
+    {
+        SendProblemEvent("Could not start transcode");
+        tc_process->kill();
+        tc_process->waitForFinished();
+        delete tc_process; // don't use deleteLater(), no event loop...
+        tc_process = NULL;
+        return false;
+    }
+
+    tc_current_pass    = which_run;
+    tc_seconds_encoded = 0;
+    tc_tick_tock       = 99;          // sentinel value, 99
+    tc_job_start_time  = QDateTime(); // sentinel value, null date time
+
+    {
+        QMutexLocker locker(cancelLock);
+        tc_timer = QObject::startTimer(0);
+    }
+
+    //LOG(VB_GENERAL, LOG_ERR, "entering event loop");
+    bool ok = (0 == DVDTranscodeThread::exec());
+    //LOG(VB_GENERAL, LOG_ERR, "exiting event loop");
+
+    {
+        QMutexLocker locker(cancelLock);
+        killTimer(tc_timer);
+        tc_timer = 0;
+    }
+    tc_current_pass = 0;
+
+    return ok;
+}
+
+void DVDTranscodeThread::timerEvent(QTimerEvent *te)
+{
+    // Ignore timers we are not listening to...
+    if (te->timerId() != tc_timer)
+        return;
+
+    // These vars should always be set when in event loop...
+    if (!tc_process || !tc_current_pass)
+        return;
+
+    if (99 == tc_tick_tock)
+    {
+        tc_tick_tock = 3;
+        QMutexLocker locker(cancelLock);
+        killTimer(tc_timer);
+        tc_timer = QObject::startTimer(kCheckFrequency);
+    }
+
+    if (IsCancelled())
+    {
+        SendProblemEvent("abandoned job because master control "
+                         "said we need to shut down");
+
+        tc_process->terminate();
+        if (!tc_process->waitForFinished(3000))
+            tc_process->kill();
+        tc_process->waitForFinished();
+        tc_process->deleteLater();
+        tc_process = NULL;
+        DVDTranscodeThread::exit(1);
+        return;
+    }
+
+    QString status_line = QString::null;
+    while (tc_process->canReadLine())
+    {
+        QByteArray stat_buf = tc_process->readLine();
+        QString stat = QString(stat_buf);
+        if (stat.contains("timestamp=") || stat.contains("EMT:") || stat.contains("CFT:"))
+            status_line = stat;
+    }
+
+    if (!status_line.isEmpty())
+    {
+        //QString orig_stat = status_line;
+        if (status_line.contains("timestamp="))
+        {
+            status_line = status_line.section("timestamp=", 1, 1);
+            QString s_string = status_line.section(".",     0, 0);
+            tc_seconds_encoded = s_string.toUInt();
+        }
+        else
+        {
+            if (status_line.contains("EMT:"))
+                status_line      = status_line.section("EMT: ", 1, 1);
+            else
+                status_line      = status_line.section("CFT: ", 1, 1);
+            status_line      = status_line.section(",",     0, 0);
+            QString h_string = status_line.section(":",     0, 0);
+            QString m_string = status_line.section(":",     1, 1);
+            QString s_string = status_line.section(":",     2, 2);
+
+            tc_seconds_encoded = s_string.toUInt() +
+                (60 * m_string.toUInt()) +
+                (60 * 60 * h_string.toUInt());
+        }
+
+        //LOG(VB_GENERAL, LOG_ERR,
+        //        QString("status_line: '%1' secs: %2")
+        //        .arg(orig_stat).arg(tc_seconds_encoded));
+    }
+    else
+    {
+        //LOG(VB_GENERAL, LOG_ERR,
+        //        QString("no status_line, secs: %1")
+        //        .arg(tc_seconds_encoded));
+    }
+
+    if (tc_seconds_encoded)
+    {
+        long long elapsed = 0;
+        QDateTime now = QDateTime::currentDateTime();
+        if (tc_job_start_time.isValid())
+            elapsed = tc_job_start_time.secsTo(now);
+        else
+            tc_job_start_time = now;
+
+        float percent_transcoded = tc_seconds_encoded * secs_mult;
+
+        if (two_pass)
+        {
+            if (tc_current_pass == 1)
+            {
+                SetSubProgress(percent_transcoded, 1);
+                overall_progress = 0.333333 +
+                    (0.333333 * percent_transcoded);
+                UpdateSubjobString(
+                    elapsed, QObject::tr("Transcoding Pass 1 of 2 ~"));
+            }
+            else if (tc_current_pass == 2)
+            {
+                SetSubProgress(percent_transcoded, 1);
+                overall_progress = 0.666666 +
+                    (0.333333 * percent_transcoded);
+                UpdateSubjobString(
+                    elapsed, QObject::tr("Transcoding Pass 2 of 2 ~"));
+            }
+        }
+        else
+        {
+            // Set feedback strings and calculate
+            // estimated time left
+            SetSubProgress(percent_transcoded, 1);
+            overall_progress = 0.50 + (0.50 * percent_transcoded);
+            UpdateSubjobString(elapsed, QObject::tr("Transcoding ~"));
+        }
+    }
+    else
+    {
+        QString a_string = QObject::tr("Transcode is thinking");
+        tc_tick_tock = (tc_tick_tock % 3) + 1;
+        for (uint i = 0; i < 3; i++)
+            a_string += (i < tc_tick_tock) ? " ." : "   ";
+
+        SetSubName(a_string, 1);
+    }
+
+    if (QProcess::NotRunning == tc_process->state())
+    {
+        int exitCode;
+        QString err = QString("runTranscode(%1) ").arg(tc_current_pass);
+
+        if (QProcess::CrashExit == tc_process->exitStatus())
+        {
+            exitCode = -1;
+            err += QString("QProcess::error(): %1").arg(tc_process->error());
+            LOG(VB_GENERAL, LOG_ERR, err);
+            SendProblemEvent(err);
+        }
+        else
+        {
+            exitCode = tc_process->exitCode();
+            err += QString("%1 exit code: %2").arg(tc_command).arg(exitCode);
+
+            QByteArray err_out = tc_process->readAllStandardError();
+            if (err_out.size())
+            {
+                err += "\nstderr output was:\n\n";
+                err += QString(err_out);
+            }
+
+            if (exitCode)
+            {
+                LOG(VB_GENERAL, LOG_ERR, err);
+                SendProblemEvent(err);
+            }
+            else
+            {
+                SendLoggingEvent(err);
+            }
+        }
+
+        tc_process->deleteLater();
+        tc_process = NULL;
+        DVDTranscodeThread::exit(exitCode);
+    }
+}
+
+/// \brief Erase rip file(s) and temporary working directory
+void DVDTranscodeThread::cleanUp(void)
+{
+    if (!working_directory)
+        return;
+
+    if (two_pass)
+        working_directory->remove("twopass.log");
+
+    working_directory->rmdir("vob");
+    working_directory->cd("..");
+    working_directory->rmdir(rip_name);
+    delete working_directory;
+    working_directory = NULL;
+    SetSubProgress(1, 1);
+    SetSubName(QObject::tr("Transcode complete."), 1);
+}
+
+/** \brief Clean up and remove any output files that may have been
+ *         partially created.
+ */
+void DVDTranscodeThread::wipeClean(void)
+{
+    cleanUp();
+    QDir::current().remove(QString("%1.avi").arg(destination_file_string));
+}
+
+DVDTranscodeThread::~DVDTranscodeThread(void)
+{
+    if (working_directory)
+        delete working_directory;
+    if (tc_process)
+        delete tc_process;
+}
diff --git a/mythtv/programs/mythmtd/jobthread.h b/mythtv/programs/mythmtd/jobthread.h
new file mode 100644
index 0000000..66b287b
--- /dev/null
+++ b/mythtv/programs/mythmtd/jobthread.h
@@ -0,0 +1,241 @@
+/*
+    jobthread.h
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    Headers for the mtd threads that actually do things
+
+*/
+
+#ifndef JOBTHREAD_H_
+#define JOBTHREAD_H_
+
+#include <QStringList>
+#include <QDateTime>
+#include <QThread>
+#include <QMutex>
+
+#include "fileobs.h"
+
+class QProcess;
+class QDir;
+class MythTranscodeDaemon;
+class QWaitCondition;
+class QTimerEvent;
+
+/** \class JobThread
+ *  \brief Base class for all MythTranscodeDaemon threads
+ */
+class JobThread : public QThread
+{
+  public:
+    JobThread(MythTranscodeDaemon *owner,
+              const QString       &start_string,
+              int                  nice_priority);
+
+    // Commands
+    virtual void run(void);
+    virtual void Cancel(bool chatty = false);
+
+    // Gets
+    QString GetJobName(void)     const;
+    QString GetSubName(void)     const;
+    QString GetLastProblem(void) const;
+    QString GetJobString(void)   const;
+    bool    IsCancelled(void)    const;
+    double  GetProgress(void)    const { return overall_progress; }
+    double  GetSubProgress(void) const { return subjob_progress;  }
+    virtual QString GetFinalFileName(void) const { return ""; }
+    virtual bool transcodeSlotUsed(void) const { return false; }
+    virtual bool usesDevice(const QString &device) const
+        { (void)device; return false; }
+
+  protected:
+    ~JobThread();
+
+    // Commands
+    void    SendProblemEvent(const QString &a_problem);
+    void    SendLoggingEvent(const QString &event_string);
+    void    UpdateSubjobString(int seconds_elapsed,
+                               const QString &pre_string);
+    // Sets
+    void    SetSubProgress(double a_value, uint priority);
+    void    SetSubName(const QString &new_name, uint priority);
+    void    SetJobName(const QString &jname);
+    void    SetLastProblem(const QString &prob);
+
+  private:
+    QString problem_string;
+    QString job_name;
+    QString subjob_name;
+    QString job_string;
+
+  protected:
+    double  overall_progress;
+    double  subjob_progress;
+    double  sub_to_overall_multiple;
+    MythTranscodeDaemon *parent;
+    int     nice_level;
+
+    mutable QMutex  subjob_progress_mutex;
+    mutable QMutex  subjob_name_mutex;
+    mutable QMutex  problem_string_mutex;
+    mutable QMutex  job_name_mutex;
+    mutable QMutex  job_string_mutex;
+
+    QMutex         *cancelLock;
+    QWaitCondition *cancelWaitCond;
+    volatile bool   cancel_me;
+};
+typedef QList<JobThread*> JobThreadList;
+
+
+/** \class DVDThread
+ *  \brief Base class for all *DVD* related job threads
+ *         (perfect copy, transcode)
+ */
+class DVDThread : public JobThread
+{
+  public:
+
+    DVDThread(MythTranscodeDaemon *owner,
+              QMutex              *drive_mutex,
+              const QString       &dvd_device,
+              int                  track,
+              const QString       &dest_file,
+              const QString       &name,
+              const QString       &start_string,
+              int                  nice_priority);
+
+    ~DVDThread();
+
+    virtual void run(void);
+    virtual QString GetFinalFileName(void) const
+        { return destination_file_string; }
+    bool    usesDevice(const QString &device) const
+        { return dvd_device_location.contains(device); }
+
+  protected:
+
+    bool         ripTitle(int title_number,
+                          const QString &to_location,
+                          const QString &extension,
+                          bool multiple_files,
+                          QStringList *output_files = 0);
+
+    QMutex      *dvd_device_access;
+    QString      dvd_device_location;
+    QString      destination_file_string;
+    int          dvd_title;
+    QString      rip_name;
+};
+
+    //
+    // Copy a byte-for-byte image of the disk
+    // to an iso file.
+    //
+
+class DVDISOCopyThread : public DVDThread
+{
+  public:
+    DVDISOCopyThread(MythTranscodeDaemon *owner,
+                     QMutex              *drive_mutex,
+                     const QString       &dvd_device,
+                     int                  track,
+                     const QString       &dest_file,
+                     const QString       &name,
+                     const QString       &start_string,
+                     int                  nice_priority);
+
+    ~DVDISOCopyThread();
+
+    virtual void run(void);
+
+    bool copyFullDisc(void);
+};
+
+    //
+    //  Fairly simple class that just knows
+    //  how to copy
+    //
+
+class DVDPerfectThread : public DVDThread
+{
+  public:
+    DVDPerfectThread(MythTranscodeDaemon *owner,
+                     QMutex              *drive_mutex,
+                     const QString       &dvd_device,
+                     int                  track,
+                     const QString       &dest_file,
+                     const QString       &name,
+                     const QString       &start_string,
+                     int                  nice_priority);
+
+    ~DVDPerfectThread();
+
+    virtual void run(void);
+};
+
+
+    //
+    //  An object that can rip a VOB off a DVD
+    //  and then transcode it
+    //
+
+class DVDTranscodeThread : public DVDThread
+{
+  public:
+    DVDTranscodeThread(MythTranscodeDaemon *owner,
+                       QMutex              *drive_mutex,
+                       const QString       &dvd_device,
+                       int                  track,
+                       const QString       &dest_file,
+                       const QString       &name,
+                       const QString       &start_string,
+                       int                  nice_priority,
+                       int                  quality_level,
+                       bool                 do_ac3,
+                       int                  which_audio,
+                       int                  numb_seconds,
+                       int                  subtitle_track_numb);
+    ~DVDTranscodeThread();
+
+    virtual void run(void);
+    virtual void Cancel(bool chatty = false);
+
+    virtual bool transcodeSlotUsed(void) const { return used_transcode_slot; }
+
+    bool    makeWorkingDirectory(void);
+    bool    buildTranscodeCommandLine(int which_run);
+    bool    runTranscode(int run);
+    void    cleanUp(void);
+    void    wipeClean(void);
+    bool    used_transcode_slot;
+
+  protected:
+    void timerEvent(QTimerEvent*);
+
+  private:
+    int          quality;
+    QDir        *working_directory;
+    bool         two_pass;
+    int          audio_track;
+    bool         ac3_flag;
+    int          subtitle_track;
+    float        secs_mult;
+
+    QProcess    *tc_process;
+    QString      tc_command;
+    QStringList  tc_arguments;
+    uint         tc_current_pass;
+    uint         tc_tick_tock;
+    uint         tc_seconds_encoded;
+    QDateTime    tc_job_start_time;
+
+    volatile int tc_timer; // protect with cancelLock..
+
+    static const int kCheckFrequency = 1000; // update progress bar freq (ms)
+};
+
+#endif  // jobthread_h_
diff --git a/mythtv/programs/mythmtd/logging.cpp b/mythtv/programs/mythmtd/logging.cpp
new file mode 100644
index 0000000..6054e1d
--- /dev/null
+++ b/mythtv/programs/mythmtd/logging.cpp
@@ -0,0 +1,120 @@
+/*
+    logging.cpp
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    Methods for logging object of the myth transcoding daemon
+
+*/
+#include "logging.h"
+
+#include <unistd.h>
+#include <cstdlib>
+#include <QDateTime>
+
+#include "compat.h"
+#include <mythcontext.h>
+#include <mythlogging.h>
+
+#define LOC      QString("MTDLogger: ")
+#define LOC_WARN QString("MTDLogger, Warning: ")
+#define LOC_ERR  QString("MTDLogger, Error: ")
+
+MTDLogger::MTDLogger(bool log_stdout) :
+    QObject(),
+    log_to_stdout(log_stdout)
+{
+}
+
+bool MTDLogger::Init(void)
+{
+    QString logfile_name = gCoreContext->GetSetting("DVDRipLocation");
+    if (logfile_name.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, LOC_ERR +
+                "You do not have a DVD rip directory set. Run Setup.");
+        return false;
+    }
+
+    logfile_name += "/mtd.log";
+
+    if (!log_to_stdout)
+    {
+        logging_file.setFileName(logfile_name);
+        if (!logging_file.open(QIODevice::WriteOnly))
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC_ERR + "\n\t\t\t" +
+                    QString("Could not open logfile '%1' for writing")
+                    .arg(logfile_name) +
+                    "\n\t\t\tSending log output to stdout instead");
+            log_to_stdout = true;
+        }
+    }
+
+    return true;
+}
+
+void MTDLogger::addEntry(const QString &log_entry)
+{
+    writeStampedString(log_entry);
+}
+
+void MTDLogger::addStartup()
+{
+    char hostname[1024];
+    QString startup_message = "mtd started at " +
+        QDateTime(QDateTime::currentDateTime()).toString();
+    writeString(startup_message);
+
+    gethostname(hostname, 1024);
+
+    startup_message = hostname;
+    startup_message.prepend("mtd is running on a host called ");
+
+    writeString(startup_message);
+    writeStampedString("Waiting for connections/jobs");
+}
+
+void MTDLogger::addShutdown()
+{
+    QString shutdown_message = "mtd shutting down at " +
+      QDateTime(QDateTime::currentDateTime()).toString();
+    writeString(shutdown_message);
+}
+
+void MTDLogger::socketOpened()
+{
+    writeStampedString("a client socket has been opened");
+}
+
+void MTDLogger::socketClosed()
+{
+    writeStampedString("a client socket has been closed");
+}
+
+void MTDLogger::writeString(const QString &log_entry)
+{
+    if (log_to_stdout)
+    {
+        LOG(VB_GENERAL, LOG_ERR, log_entry);
+    }
+    else
+    {
+        QTextStream stream(&logging_file);
+        stream << log_entry << endl << flush;
+    }
+}
+
+void MTDLogger::writeStampedString(const QString &log_entry)
+{
+    QString stamped_log_entry = log_entry;
+    stamped_log_entry.prepend(": ");
+    stamped_log_entry.prepend(QTime(QTime::currentTime()).toString());
+    writeString(stamped_log_entry);
+}
+
+MTDLogger::~MTDLogger()
+{
+    logging_file.close();
+}
diff --git a/mythtv/programs/mythmtd/logging.h b/mythtv/programs/mythmtd/logging.h
new file mode 100644
index 0000000..bc9f90a
--- /dev/null
+++ b/mythtv/programs/mythmtd/logging.h
@@ -0,0 +1,53 @@
+#ifndef MTDLOGGING_H_
+#define MTDLOGGING_H_
+/*
+    logging.h
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    Headers for logging object of the myth transcoding daemon
+
+*/
+
+#include <QObject>
+#include <QString>
+#include <QFile>
+
+
+/** \class MTDLogger
+ *  \brief Simple little class to log mtd information.
+ *
+ *  Doesn't do much at the moment, but in place early
+ *  so that it will be easy to change logging information
+ *  (in transcoding directories, syslog, etc.) later.
+ */
+
+class MTDLogger : public QObject
+{
+    Q_OBJECT
+
+  public:
+    MTDLogger(bool log_stdout);
+    bool Init(void);
+
+  public slots:
+
+    void addEntry(const QString &log_entry);
+    void addStartup();
+    void addShutdown();
+    void socketOpened();
+    void socketClosed();
+
+  private:
+    ~MTDLogger();
+
+  private:
+    void writeString(const QString &log_entry);
+    void writeStampedString(const QString &log_entry);
+    QFile logging_file;
+    bool  log_to_stdout;
+
+};
+
+#endif  // mtdlogging_h_
diff --git a/mythtv/programs/mythmtd/main.cpp b/mythtv/programs/mythmtd/main.cpp
new file mode 100644
index 0000000..f76ea63
--- /dev/null
+++ b/mythtv/programs/mythmtd/main.cpp
@@ -0,0 +1,182 @@
+/*
+    main.cpp
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    Starting point for the myth transcoding daemon
+
+*/
+
+#include <iostream>
+using std::cout;
+using std::cerr;
+#include <unistd.h>
+
+#include <QApplication>
+#include <QSqlDatabase>
+#include <QFile>
+
+#include <exitcodes.h>
+#include <mythcontext.h>
+#include <mythdbcon.h>
+#include <mythversion.h>
+#include "mythtranslation.h"
+#include <mythlogging.h>
+#include <compat.h>
+
+#include "libmythtv/videodbcheck.h"
+#include "mtd.h"
+
+int main(int argc, char **argv)
+{
+    QApplication a(argc, argv, false);
+    bool daemon_mode = false;
+    int  special_port = -1;
+
+    //
+    //  Check command line arguments
+    //
+
+    for (int argpos = 1; argpos < a.argc(); ++argpos)
+    {
+        if (!strcmp(a.argv()[argpos],"-d") ||
+            !strcmp(a.argv()[argpos],"--daemon"))
+        {
+            daemon_mode = true;
+        }
+        else if (!strcmp(a.argv()[argpos],"-n") ||
+                 !strcmp(a.argv()[argpos],"--nodaemon"))
+        {
+            daemon_mode = false;
+        }
+        else if (!strcmp(a.argv()[argpos],"-p") ||
+                 !strcmp(a.argv()[argpos],"--port"))
+        {
+            if (a.argc() > argpos)
+            {
+                QString port_number = a.argv()[argpos+1];
+                ++argpos;
+                special_port = port_number.toInt();
+                if (special_port < 1 ||
+                   special_port > 65534)
+                {
+                    LOG(VB_GENERAL, LOG_ERR, "mtd: Bad port number");
+                    return GENERIC_EXIT_INVALID_CMDLINE;
+                }
+            }
+            else
+            {
+                LOG(VB_GENERAL, LOG_ERR, "mtd: Missing argument to -p/--port option");
+                return GENERIC_EXIT_INVALID_CMDLINE;
+            }
+        }
+        else if (!strcmp(a.argv()[argpos],"-v"))
+        {
+            if (++argpos >= argc) {
+                cerr << "Error: -v requires parameters (try -v help)" <<
+                        std::endl;
+                return GENERIC_EXIT_INVALID_CMDLINE;
+            }
+#if 0 // TODO
+            int err;
+            if ((err = parse_verbose_arg(a.argv()[argpos])) !=
+                GENERIC_EXIT_OK)
+            {
+                return err;
+            }
+#endif
+        }
+        else
+        {
+            cerr << "Invalid argument: " << a.argv()[argpos] << endl
+                 << "Valid options are: " << endl
+                 << "-p or --port number  "
+                 << "A port number to listen on (default is 2442) " << endl
+                 << "-d or --daemon       Runs mtd as a daemon " << endl
+                 << "-n or --nodaemon     Does not run mtd as a daemon (default)"
+                 << endl;
+            return GENERIC_EXIT_INVALID_CMDLINE;
+        }
+    }
+
+    //
+    //  Switch to daemon mode?
+    //
+
+    if (daemon_mode)
+    {
+        if (daemon(0, 1) < 0)
+        {
+            cerr << "mtd: Failed to run as a daemon. Bailing out." << endl ;
+            return GENERIC_EXIT_DAEMONIZING_ERROR;
+        }
+        cout << endl;
+    }
+
+    //
+    //  Get the Myth context and db hooks
+    //
+
+    gContext = NULL;
+    gContext = new MythContext(MYTH_BINARY_VERSION);
+    if (!gContext->Init(false))
+    {
+        cerr << "Could not initialize myth context. Exiting." << endl;
+        return GENERIC_EXIT_NO_MYTHCONTEXT;
+    }
+
+    if (!MSqlQuery::testDBConnection())
+    {
+        cerr << "mtd: Couldn't open database. I go away now. " << endl;
+        return GENERIC_EXIT_DB_ERROR;
+    }
+
+    gCoreContext->ActivateSettingsCache(false);
+    doUpgradeVideoDatabaseSchema();
+    gCoreContext->ActivateSettingsCache(true);
+
+    //
+    //  Figure out port to listen on
+    //
+
+    int assigned_port = gCoreContext->GetNumSetting("MTDPort", 2442);
+    if (special_port > 0)
+    {
+        assigned_port = special_port;
+    }
+
+    //
+    //  Where to log
+    //
+
+    bool log_stdout = false;
+    if (gCoreContext->GetNumSetting("MTDLogFlag", 0))
+    {
+        log_stdout = true;
+    }
+
+    if (!daemon_mode)
+    {
+        log_stdout = true;
+    }
+
+    //
+    //  Nice ourself
+    //
+
+    MythTranslation::load("mythdvd");
+
+    MythTranscodeDaemon *mtd =
+      new MythTranscodeDaemon(assigned_port, log_stdout);
+
+    if (!mtd->Init())
+        return GENERIC_EXIT_NOT_OK;
+
+    int ret = a.exec();
+
+    delete mtd;
+    delete gContext;
+
+    return ret;
+}
diff --git a/mythtv/programs/mythmtd/mtd.cpp b/mythtv/programs/mythmtd/mtd.cpp
new file mode 100644
index 0000000..cf2d3b2
--- /dev/null
+++ b/mythtv/programs/mythmtd/mtd.cpp
@@ -0,0 +1,1030 @@
+/*
+    mtd.cpp
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    Methods for the core mtd object
+
+*/
+
+// POSIX headers
+#include <unistd.h>
+
+// C headers
+#include <cstdlib>
+
+// Qt headers
+#include <QWaitCondition>
+#include <QApplication>
+#include <QStringList>
+#include <QTcpServer>
+#include <QTcpSocket>
+#include <QRegExp>
+#include <QTimer>
+#include <QDir>
+
+// MythTV headers
+#include <mythmiscutil.h>
+#include <mythcontext.h>
+#include <compat.h>
+#include <mythlogging.h>
+
+// MythTranscodeDaemon headers
+#include "mtd.h"
+#include "logging.h"
+
+enum RIP_QUALITIES { QUALITY_ISO = -1, QUALITY_PERFECT, QUALITY_TRANSCODE };
+
+/** \class DiscCheckingThread
+ *  \brief Periodically checks if there is a disc in the DVD drive.
+ *
+ *  This is just a little object that asks the DVDProbe object to
+ *  keep checking the drive to see if we have a disc, if the disc
+ *  has changed, etc.
+ */
+DiscCheckingThread::DiscCheckingThread(
+    DVDProbe *probe,
+    QMutex   *drive_access_mutex,
+    QMutex   *mutex_for_titles) :
+    dvd_probe(probe), have_disc(false),
+    dvd_drive_access(drive_access_mutex),
+    titles_mutex(mutex_for_titles),
+    cancelLock(new QMutex()),
+    cancelWaitCond(new QWaitCondition()),
+    cancel_me(false)
+{
+}
+
+DiscCheckingThread::~DiscCheckingThread()
+{
+    delete cancelLock;
+    delete cancelWaitCond;
+}
+
+void DiscCheckingThread::Cancel(void)
+{
+    QMutexLocker locker(cancelLock);
+    cancel_me = true;
+    cancelWaitCond->wakeAll();
+}
+
+/// \brief Checks if the MythTranscodeDaemon class has asked us to stop.
+bool DiscCheckingThread::IsCancelled(void) const
+{
+    QMutexLocker locker(cancelLock);
+    return cancel_me;
+}
+
+void DiscCheckingThread::run(void)
+{
+    while (!IsCancelled())
+    {
+        bool gota = dvd_drive_access->tryLock();
+        bool gotb = titles_mutex->tryLock();
+
+        if (gota && gotb)
+            have_disc = dvd_probe->Probe();
+
+        if (gota)
+            dvd_drive_access->unlock();
+        if (gotb)
+            titles_mutex->unlock();
+
+        QMutexLocker locker(cancelLock);
+        if (!cancel_me)
+            cancelWaitCond->wait(cancelLock, 14000);
+    }
+}
+
+/*
+---------------------------------------------------------------------
+*/
+
+#define LOC      QString("MTD: ")
+#define LOC_WARN QString("MTD, Warning: ")
+#define LOC_ERR  QString("MTD, Error: ")
+
+MythTranscodeDaemon::MythTranscodeDaemon(int port, bool log_stdout) :
+    QObject(),
+    listening_port(port),
+    log_to_stdout(log_stdout),
+    mtd_log(NULL),
+    server_socket(new QTcpServer(this)),
+    dvd_drive_access(new QMutex()),
+    titles_mutex(new QMutex()),
+    have_disc(false),
+    thread_cleaning_timer(new QTimer(this)),
+    disc_checking_timer(new QTimer(this)),
+    dvd_device(gCoreContext->GetSetting("DVDDeviceLocation")),
+    dvd_probe(new DVDProbe(dvd_device)),
+    disc_checking_thread(NULL),
+    nice_level(gCoreContext->GetNumSetting("MTDNiceLevel", 20)),
+    concurrent_transcodings_mutex(new QMutex()),
+    concurrent_transcodings(0),
+    max_concurrent_transcodings(
+        gCoreContext->GetNumSetting("MTDConcurrentTranscodings", 1)),
+    m_statusCount(0)
+{
+    myth_nice(nice_level);
+
+    connect(server_socket, SIGNAL(newConnection()),
+            this,          SLOT(  newConnection()));
+    connect(thread_cleaning_timer, SIGNAL(timeout()),
+            this,                  SLOT(  cleanThreads()));
+    connect(disc_checking_timer,   SIGNAL(timeout()),
+            this,                  SLOT(checkDisc()));
+
+    disc_checking_thread = new DiscCheckingThread(
+        dvd_probe, dvd_drive_access, titles_mutex);
+    disc_checking_thread->start();
+}
+
+MythTranscodeDaemon::~MythTranscodeDaemon()
+{
+    disconnect();
+
+    if (mtd_log)
+    {
+        mtd_log->addShutdown();
+        mtd_log->deleteLater();
+        mtd_log = NULL;
+    }
+
+    // server_socket is auto deleted by Qt
+    // thread_cleaning_timer is auto deleted by Qt
+    thread_cleaning_timer->disconnect();
+    // disc_checking_timer is auto deleted by Qt
+    disc_checking_timer->disconnect();
+
+    if (disc_checking_thread)
+    {
+        disc_checking_thread->Cancel();
+        disc_checking_thread->wait();
+        disc_checking_thread->deleteLater();
+        disc_checking_thread = NULL;
+    }
+
+    if (dvd_drive_access)
+    {
+        delete dvd_drive_access;
+        dvd_drive_access = NULL;
+    }
+
+    if (titles_mutex)
+    {
+        delete titles_mutex;
+        titles_mutex = NULL;
+    }
+
+    if (concurrent_transcodings_mutex)
+    {
+        delete concurrent_transcodings_mutex;
+        concurrent_transcodings_mutex = NULL;
+    }
+}
+
+bool MythTranscodeDaemon::Init(void)
+{
+    // Start listening on the server socket
+    if (!server_socket->listen(QHostAddress::Any, listening_port))
+    {
+         LOG(VB_GENERAL, LOG_ERR, LOC_ERR +
+                 QString("Can't bind to server port %1").arg(listening_port) +
+                 "\n\t\t\tThere is probably copy of mtd already running."
+                 "\n\t\t\tYou can verify this by running 'ps ax | grep mtd'.");
+         return false;
+    }
+
+    //  Create the logging object
+    mtd_log = new MTDLogger(log_to_stdout);
+    if (!mtd_log->Init())
+        return false;
+    mtd_log->addStartup();
+    connect(this,    SIGNAL(writeToLog(const QString&)),
+            mtd_log, SLOT(  addEntry(  const QString&)));
+
+    // Announce in the log the port we're listening on
+    emit writeToLog(QString("mtd is listening on port %1")
+                    .arg(listening_port));
+
+    // Start timers
+    thread_cleaning_timer->start(2000);
+    disc_checking_timer->start(1000);
+
+    return true;
+}
+
+void MythTranscodeDaemon::checkDisc()
+{
+    // forgetDVD() can delete dvd_probe
+    if (!dvd_probe)
+        return;
+
+    bool had_disc = have_disc;
+    QString old_name = dvd_probe->GetName();
+    if (disc_checking_thread->IsDiscPresent())
+    {
+        have_disc = true;
+        if (had_disc)
+        {
+            if (old_name != dvd_probe->GetName())
+            {
+                //
+                //  DVD changed
+                //
+                emit writeToLog(QString("DVD changed to: %1")
+                                .arg(dvd_probe->GetName()));
+            }
+        }
+        else
+        {
+            //
+            //  DVD inserted
+            //
+            emit writeToLog(QString("DVD inserted: %1")
+                            .arg(dvd_probe->GetName()));
+
+            DVDTitleList list_of_titles = dvd_probe->GetTitles();
+            for (uint i = 0; i < (uint)list_of_titles.size(); i++)
+            {
+                emit writeToLog(
+                    QString("            : Title %1 is of "
+                            "type %2 (dvdinput table)")
+                    .arg(i+1)
+                    .arg(list_of_titles[i].GetInputID()));
+            }
+        }
+    }
+    else
+    {
+        have_disc = false;
+        if (had_disc)
+        {
+            //
+            //  DVD removed
+            //
+            emit writeToLog("DVD removed");
+        }
+    }
+}
+
+void MythTranscodeDaemon::cleanThreads()
+{
+    //
+    //  Should probably have the job threads
+    //  post an event when they are done, but
+    //  this works.
+    //
+
+    JobThreadList::iterator it = job_threads.begin();
+    while (it != job_threads.end())
+    {
+        if (!(*it)->isFinished())
+        {
+            ++it;
+            continue;
+        }
+
+        QString problem = (*it)->GetLastProblem();
+        QString job_command = (*it)->GetJobString();
+        if (problem.length() > 0)
+        {
+            emit writeToLog(QString("job failed: %1").arg(job_command));
+            //emit writeToLog(QString("    reason: %1").arg(problem));
+        }
+        else
+        {
+            emit writeToLog(QString("job finished successfully: %1")
+                            .arg(job_command));
+        }
+
+        //
+        //  If this is a transcoding thread, adjust the
+        //  count.
+        //
+
+        if ((*it)->transcodeSlotUsed())
+        {
+            QMutexLocker locker(concurrent_transcodings_mutex);
+            concurrent_transcodings--;
+            if (concurrent_transcodings < 0)
+            {
+                LOG(VB_GENERAL, LOG_ERR, LOC_ERR +
+                        "One of the transcode jobs died very early.\n\t\t\t"
+                        "There may or may not be anything informative in "
+                        "the log.");
+                concurrent_transcodings = 0;
+            }
+        }
+
+        (*it)->deleteLater();
+        it = job_threads.erase(it);
+    }
+
+}
+
+void MythTranscodeDaemon::newConnection(void)
+{
+    QTcpSocket *socket = server_socket->nextPendingConnection();
+    while (socket)
+    {
+        connect(socket, SIGNAL(readyRead()),
+                this,   SLOT(  readSocket()));
+        connect(socket, SIGNAL(disconnected()),
+                this,   SLOT(  endConnection()));
+        mtd_log->socketOpened();
+
+        socket = server_socket->nextPendingConnection();
+    }
+}
+
+void MythTranscodeDaemon::endConnection(void)
+{
+    QTcpSocket *socket = dynamic_cast<QTcpSocket*>(sender());
+    if (socket)
+    {
+        socket->close();
+        socket->deleteLater();
+        mtd_log->socketClosed();
+    }
+}
+
+void MythTranscodeDaemon::readSocket(void)
+{
+    QTcpSocket *socket = dynamic_cast<QTcpSocket*>(sender());
+    if (socket && socket->canReadLine())
+    {
+        QString incoming_data = socket->readLine();
+        incoming_data = incoming_data.replace( QRegExp("\n"), "" );
+        incoming_data = incoming_data.replace( QRegExp("\r"), "" );
+        incoming_data.simplified();
+        QStringList tokens = incoming_data.split(" ");
+        parseTokens(tokens, socket);
+    }
+}
+
+void MythTranscodeDaemon::parseTokens(const QStringList &tokens,
+                                      QTcpSocket *socket)
+{
+    //
+    //  parse commands coming in from the socket
+    //
+
+    if (tokens[0] == "halt" ||
+       tokens[0] == "quit" ||
+       tokens[0] == "shutdown")
+    {
+        ShutDownThreads();
+        // The rest will be handled when the class is deleted..
+        QApplication::exit(0);
+    }
+    else if (tokens[0] == "hello")
+    {
+        sayHi(socket);
+    }
+    else if (tokens[0] == "status")
+    {
+        sendStatusReport(socket);
+    }
+    else if (tokens[0] == "media")
+    {
+        sendMediaReport(socket);
+    }
+    else if (tokens[0] == "job")
+    {
+        startJob(tokens);
+    }
+    else if (tokens[0] == "abort")
+    {
+        startAbort(tokens);
+    }
+    else if (tokens[0] == "use")
+    {
+        useDrive(tokens);
+    }
+    else if (tokens[0] == "no")
+    {
+        noDrive(tokens);
+    }
+    else
+    {
+        QString did_not_parse = tokens.join(" ");
+        emit writeToLog(QString("failed to parse this: %1").arg(did_not_parse));
+    }
+}
+
+void MythTranscodeDaemon::ShutDownThreads(void)
+{
+    // Tell job threads to exit soon...
+    JobThreadList::iterator it = job_threads.begin();
+    for (; it != job_threads.end(); ++it)
+        (*it)->Cancel();
+
+    // Tell disc checking thread to exit soon...
+    if (disc_checking_thread)
+        disc_checking_thread->Cancel();
+
+    // Wait for job threads to actually exit, then delete
+    while (!job_threads.empty())
+    {
+        job_threads.back()->wait();
+        job_threads.back()->deleteLater();
+        job_threads.pop_back();
+    }
+
+    // Wait for disc checking thread to actually exit, then delete
+    if (disc_checking_thread)
+    {
+        disc_checking_thread->wait();
+        disc_checking_thread->deleteLater();
+        disc_checking_thread = NULL;
+    }
+}
+
+void MythTranscodeDaemon::sendMessage(QTcpSocket *where, const QString &what)
+{
+    QString message = what;
+    message.append("\n");
+    QByteArray buf = message.toUtf8();
+    where->write(buf);
+}
+
+void MythTranscodeDaemon::sayHi(QTcpSocket *socket)
+{
+    sendMessage(socket, "greetings");
+}
+
+void MythTranscodeDaemon::sendStatusReport(QTcpSocket *socket)
+{
+    //
+    //  Tell the client how many jobs are
+    //  in progress, and then details of
+    //  each job.
+    //
+
+    sendMessage(socket, QString("status dvd summary %1")
+                .arg(job_threads.size()));
+
+    for (uint i = 0; i < (uint)job_threads.size() ; i++)
+    {
+        QString a_status_message = QString("status dvd job %1 overall %2 %3")
+                                   .arg(i)
+                                   .arg(job_threads[i]->GetProgress())
+                                   .arg(job_threads[i]->GetJobName());
+        sendMessage(socket, a_status_message);
+        a_status_message = QString("status dvd job %1 subjob %2 %3")
+                                   .arg(i)
+                                   .arg(job_threads[i]->GetSubProgress())
+                                   .arg(job_threads[i]->GetSubName());
+        sendMessage(socket, a_status_message);
+    }
+
+    QString s =  "status dvd complete";
+    if (!m_statusMsg.isEmpty())
+    {
+        s += " " + m_statusMsg;
+        if (++m_statusCount > 10)
+            m_statusMsg.clear();
+    }
+    sendMessage(socket, s);
+}
+
+void MythTranscodeDaemon::sendMediaReport(QTcpSocket *socket)
+{
+    //
+    //  Tell the client what's on a disc
+    //
+
+    if (have_disc)
+    {
+        //
+        //  Send number of titles and disc's name
+        //
+
+        QMutexLocker locker(titles_mutex);
+
+        DVDTitleList dvd_titles = dvd_probe->GetTitles();
+        sendMessage(socket, QString("media dvd summary %1 %2")
+                    .arg(dvd_titles.size()).arg(dvd_probe->GetName()));
+
+        //
+        //  For each title, send:
+        //      track/title number, numb chapters, numb angles,
+        //      hours, minutes, seconds, and type of disc
+        //      (from the dvdinput table in the database)
+        //
+
+        for (uint i = 0; i < (uint)dvd_titles.size(); i++)
+        {
+            sendMessage(socket, QString("media dvd title %1 %2 %3 %4 %5 %6 %7")
+                        .arg(dvd_titles[i].GetTrack())
+                        .arg(dvd_titles[i].GetChapters())
+                        .arg(dvd_titles[i].GetAngles())
+                        .arg(dvd_titles[i].GetHours())
+                        .arg(dvd_titles[i].GetMinutes())
+                        .arg(dvd_titles[i].GetSeconds())
+                        .arg(dvd_titles[i].GetInputID())
+                       );
+            //
+            //  For each track, send all the audio info
+            //
+            DVDAudioList audio_tracks = dvd_titles[i].GetAudioTracks();
+            for (uint j = 0; j < (uint)audio_tracks.size(); j++)
+            {
+                //
+                //  Send title/track #, audio track #, descriptive string
+                //
+
+                sendMessage(socket, QString("media dvd title-audio %1 %2 %3 %4")
+                            .arg(dvd_titles[i].GetTrack())
+                            .arg(j+1)
+                            .arg(audio_tracks[j].GetChannels())
+                            .arg(audio_tracks[j].GetAudioString())
+                           );
+            }
+
+            //
+            //  For each subtitle, send the id number, the lang code, and the name
+            //
+            DVDSubTitleList subtitles = dvd_titles[i].GetSubTitles();
+            for (uint j = 0; j < (uint)subtitles.size(); j++)
+            {
+                sendMessage(socket,
+                            QString("media dvd title-subtitle %1 %2 %3 %4")
+                            .arg(dvd_titles[i].GetTrack())
+                            .arg(subtitles[j].GetID())
+                            .arg(subtitles[j].GetLanguage())
+                            .arg(subtitles[j].GetName())
+                            );
+            }
+
+
+
+        }
+    }
+    else
+    {
+        sendMessage(socket, "media dvd summary 0 No Disc");
+    }
+    sendMessage(socket, "media dvd complete");
+}
+
+void MythTranscodeDaemon::startAbort(const QStringList &tokens)
+{
+    QString flat = tokens.join(" ");
+
+    //
+    //  Sanity check
+    //
+
+    if (tokens.size() < 4)
+    {
+        emit writeToLog(QString("bad abort request: %1").arg(flat));
+        return;
+    }
+
+    if (tokens[1] != "dvd" ||
+       tokens[2] != "job")
+    {
+        emit writeToLog(QString("I don't know how to handle this abort request: %1").arg(flat));
+        return;
+    }
+
+    bool ok;
+    int job_to_kill = tokens[3].toInt(&ok);
+    if (!ok || job_to_kill < 0)
+    {
+        emit writeToLog(QString("Could not make out a job number in this abort request: %1").arg(flat));
+        return;
+    }
+
+    if (job_to_kill >= (int) job_threads.size())
+    {
+        emit writeToLog(QString("Was asked to kill a job that does not exist: %1").arg(flat));
+        return;
+    }
+
+    // OK, we can probably kill this job
+    job_threads[job_to_kill]->Cancel(true);
+}
+
+void MythTranscodeDaemon::startJob(const QStringList &tokens)
+{
+    //
+    //  Check that the tokens make sense
+    //
+
+    if (tokens.size() < 2)
+    {
+        QString flat = tokens.join(" ");
+        emit writeToLog(QString("bad job request: %1").arg(flat));
+        return;
+    }
+
+    if (tokens[1] == "dvd")
+    {
+        m_statusCount = 0;
+        m_statusMsg.clear();
+        startDVD(tokens);
+    }
+    else
+    {
+        emit writeToLog(QString("I don't know how to process jobs of type %1").arg(tokens[1]));
+    }
+
+}
+
+void MythTranscodeDaemon::startDVD(const QStringList &tokens)
+{
+    QString flat = tokens.join(" ");
+    bool ok;
+
+    if (tokens.size() < 8)
+    {
+        emit writeToLog(QString("bad dvd job request: %1").arg(flat));
+        return;
+    }
+
+    //
+    //  Parse the tokens into "real" variables,
+    //  checking for silly values as we go. If
+    //  everything checks out, fire it up.
+    //
+
+    int dvd_title = tokens[2].toInt(&ok);
+    if (dvd_title < 1 || dvd_title > 99 || !ok)
+    {
+        writeStatus(QString("bad title number in job request: %1")
+                        .arg(flat));
+        return;
+    }
+
+    int audio_track = tokens[3].toInt(&ok);
+    if (audio_track < 0 || audio_track > 10 || !ok)
+    {
+        // 10 ?? I just made that up as a boundary ??
+        writeStatus(QString("bad audio track in job request: %1")
+                        .arg(flat));
+        return;
+    }
+
+    int quality = tokens[4].toInt(&ok);
+    if (quality < QUALITY_ISO || !ok)
+    {
+        writeStatus(QString("bad quality value in job request: %1")
+                        .arg(flat));
+        return;
+    }
+
+    bool ac3_flag = false;
+    int flag_value = tokens[5].toUInt(&ok);
+    if (!ok)
+    {
+        writeStatus(QString("bad ac3 flag in job request: %1").arg(flat));
+        return;
+    }
+    if (flag_value)
+    {
+        ac3_flag = true;
+    }
+
+    int subtitle_track = tokens[6].toInt(&ok);
+    if (!ok)
+    {
+        writeStatus(QString("bad subtitle reference "
+                                "in job request: %1").arg(flat));
+        return;
+    }
+
+    //
+    //  Parse the dir and file as one string
+    //  and then break it up
+    //
+
+    QString dir_and_file = "";
+
+    for (QStringList::size_type i = 7; i < tokens.size(); i++)
+    {
+        dir_and_file += tokens[i];
+        if (i != tokens.size() - 1)
+        {
+            dir_and_file += " ";
+        }
+    }
+
+    QDir dest_dir(dir_and_file.section("/", 0, -2));
+    if (!dest_dir.exists())
+    {
+        writeStatus(QString("bad destination directory "
+                                "in job request: '%1'").arg(flat));
+        return;
+    }
+
+    QString file_name = dir_and_file.section("/", -1, -1);
+
+    if (dvd_device.length() < 1)
+    {
+        writeStatus("Can not launch DVD job until a dvd device is defined");
+        return;
+    }
+
+    //
+    //  OK, we are ready to launch this job
+    //
+
+    if (quality == QUALITY_ISO)
+    {
+        QFile final_file(dest_dir.filePath(file_name));
+
+        if (!checkFinalFile(&final_file, ".iso"))
+        {
+            writeStatus(
+                QString("Final file name '%1' is not useable. "
+                        "File exists? Other Pending job?")
+                .arg(final_file.fileName()));
+            return;
+        }
+
+        emit writeToLog(QString("launching job: %1").arg(flat));
+
+        //
+        //  Full disc copy to an iso image.
+        //
+
+        JobThread *new_job = new DVDISOCopyThread(this,
+                                                  dvd_drive_access,
+                                                  dvd_device,
+                                                  dvd_title,
+                                                  final_file.fileName(),
+                                                  file_name,
+                                                  flat,
+                                                  nice_level);
+        job_threads.push_back(new_job);
+        new_job->start();
+    }
+    else if (quality == QUALITY_PERFECT)
+    {
+        QFile final_file(dest_dir.filePath(file_name));
+
+        if (!checkFinalFile(&final_file, ".mpg"))
+        {
+            writeStatus(
+                QString("Final file name '%1' is not useable. "
+                        "File exists? Other Pending job?")
+                .arg(final_file.fileName()));
+            return;
+        }
+
+        emit writeToLog(QString("launching job: %1").arg(flat));
+
+        //
+        //  perfect quality, straight copy via libdvdread
+        //
+
+        JobThread *new_job = new DVDPerfectThread(
+            this, dvd_drive_access, dvd_device, dvd_title,
+            final_file.fileName(), file_name,
+            flat, nice_level);
+
+        job_threads.push_back(new_job);
+        new_job->start();
+    }
+    else if (quality >= QUALITY_TRANSCODE)
+    {
+        QFile final_file(dest_dir.filePath(file_name));
+
+        if (!checkFinalFile(&final_file, ".avi"))
+        {
+            writeStatus(
+                QString("Final file name '%1' is not useable. "
+                        "File exists? Other Pending job?")
+                .arg(final_file.fileName()));
+            return;
+        }
+
+        titles_mutex->lock();
+        DVDTitle which_title = dvd_probe->GetTitle(dvd_title);
+        titles_mutex->unlock();
+
+        if (!which_title.IsValid())
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC_ERR + "Title number not valid?");
+            return;
+        }
+
+        uint numb_seconds = which_title.GetPlayLength();
+
+        emit writeToLog(QString("launching job: %1").arg(flat));
+
+        //
+        //  transcoding job
+        //
+
+        JobThread *new_job = new DVDTranscodeThread(
+            this, dvd_drive_access, dvd_device, dvd_title,
+            final_file.fileName(), file_name,
+            flat, nice_level, quality, ac3_flag, audio_track,
+            numb_seconds, subtitle_track);
+
+        job_threads.push_back(new_job);
+        new_job->start();
+
+    }
+    else
+    {
+        LOG(VB_GENERAL, LOG_ERR, LOC_ERR +
+                "Invalid transcode quality parameter, ignoring job");
+    }
+}
+
+/**
+ * Remember the supplied device path
+ */
+void MythTranscodeDaemon::useDrive(const QStringList &tokens)
+{
+    if (tokens.size() != 3)
+    {
+        emit writeToLog("Bad usedrive request: " + tokens.join(" "));
+        return;
+    }
+
+    if (tokens[1] == "dvd")
+        useDVD(tokens);
+    else
+        emit writeToLog("I don't know how to use drives of type: " + tokens[1]);
+}
+
+/**
+ * Remember the supplied DVD device path, and create a DVDProbe & thread for it
+ */
+void MythTranscodeDaemon::useDVD(const QStringList &tokens)
+{
+    if (dvd_device == tokens[2])  // Same drive? Nothing to do.
+        return;
+
+    DVDProbe *newDrive = new DVDProbe(tokens[2]);
+    if (!newDrive->Probe())
+    {
+        emit writeToLog("Drive not available: " + tokens[2]);
+        return;
+    }
+
+    forgetDVD();
+
+    dvd_device = tokens[2];
+    dvd_probe  = newDrive;
+
+    disc_checking_thread = new DiscCheckingThread(dvd_probe,
+                                                  dvd_drive_access,
+                                                  titles_mutex);
+    disc_checking_thread->start();
+
+    have_disc  = true;
+}
+
+/**
+ * Stop using the specified, or current, drive. Also stop any related jobs
+ */
+void MythTranscodeDaemon::noDrive(const QStringList &tokens)
+{
+    if (tokens.size() < 2 || tokens.size() > 3)
+    {
+        emit writeToLog("Bad no drive request: " + tokens.join(" "));
+        return;
+    }
+
+    QString device;
+
+    if (tokens[1] == "dvd")
+        device = noDVD(tokens);
+    else
+    {
+        emit writeToLog("I don't know how to forget drives of type: "
+                        + tokens[1]);
+        return;
+    }
+
+    JobThreadList::iterator it = job_threads.begin();
+    for (; it != job_threads.end(); ++it)
+    {
+        if ((*it)->usesDevice(device))
+        {
+            (*it)->Cancel();
+
+            emit writeToLog("Waiting for job : " + (*it)->GetJobName());
+            (*it)->wait();
+
+            (*it)->deleteLater();
+            job_threads.erase(it);
+        }
+    }
+}
+
+/**
+ * Stop using the specified, or current, dvd drive
+ */
+QString MythTranscodeDaemon::noDVD(const QStringList &tokens)
+{
+    QString device;
+
+    if (tokens.size() == 2)
+        device = dvd_device;
+    else
+        device = tokens[2];
+
+    // In multi-drive setups, the user could be ripping several.
+    // The drive we are forgetting about may not be the current one:
+    if (device == dvd_device)
+        forgetDVD();
+
+    return device;
+}
+
+/**
+ * Clear the current DVD device path, disc checking thread and DVDProbe object
+ */
+void MythTranscodeDaemon::forgetDVD(void)
+{
+    if (disc_checking_thread)
+    {
+        disc_checking_thread->Cancel();
+        disc_checking_thread->wait();
+        disc_checking_thread->deleteLater();
+        disc_checking_thread = NULL;
+    }
+
+    QMutexLocker locker(dvd_drive_access);
+    if (dvd_probe)
+    {
+        delete dvd_probe;
+        dvd_probe = NULL;
+    }
+
+    dvd_device = "";     // Prevent new jobs
+    have_disc  = false;  // For sendMediaReport()
+}
+
+bool MythTranscodeDaemon::checkFinalFile(
+    QFile *final_file, const QString &extension)
+{
+    //
+    //  Check if file exists
+    //
+
+    QString final_with_extension_string = final_file->fileName() + extension;
+    QFile tester(final_with_extension_string);
+
+    if (tester.exists())
+    {
+        return false;
+    }
+
+    //
+    //  Check already active jobs
+    //
+    JobThreadList::iterator it = job_threads.begin();
+    for (; it != job_threads.end(); ++it)
+    {
+        if ((*it)->GetFinalFileName() == final_file->fileName())
+            return false;
+    }
+
+    return true;
+}
+
+bool MythTranscodeDaemon::IncrConcurrentTranscodeCounter(void)
+{
+    QMutexLocker locker(concurrent_transcodings_mutex);
+    if (concurrent_transcodings < max_concurrent_transcodings)
+    {
+        concurrent_transcodings++;
+        return true;
+    }
+    return false;
+}
+
+void MythTranscodeDaemon::customEvent(QEvent *ce)
+{
+    if (ce->type() == LoggingEvent::kEventType)
+    {
+        LoggingEvent *le = (LoggingEvent*)ce;
+        emit writeToLog(le->getString());
+    }
+    else if (ce->type() == ErrorEvent::kEventType)
+    {
+        ErrorEvent *ee = (ErrorEvent*)ce;
+        QString error_string = "Error: " + ee->getString();
+        emit writeToLog(error_string);
+    }
+    else
+    {
+        LOG(VB_GENERAL, LOG_ERR, LOC_ERR + "Unrecognized event");
+    }
+}
+
+void MythTranscodeDaemon::writeStatus(const QString &s)
+{
+    m_statusMsg = s;
+    emit writeToLog(s);
+}
diff --git a/mythtv/programs/mythmtd/mtd.h b/mythtv/programs/mythmtd/mtd.h
new file mode 100644
index 0000000..5f0e6f4
--- /dev/null
+++ b/mythtv/programs/mythmtd/mtd.h
@@ -0,0 +1,128 @@
+#ifndef MTD_H_
+#define MTD_H_
+/*
+    mtd.h
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    Headers for the core mtd object
+
+*/
+
+#include <QObject>
+#include <QList>
+
+#include "logging.h"
+#include "jobthread.h"
+#include "dvdprobe.h"
+#include "threadevents.h"
+
+class QStringList;
+class QTimer;
+class QMutex;
+class QTcpServer;
+class QTcpSocket;
+class QWaitCondition;
+
+class MythTranscodeDaemon;
+
+class DiscCheckingThread : public QThread
+{
+  public:
+    DiscCheckingThread(DVDProbe *probe,
+                       QMutex   *drive_access_mutex,
+                       QMutex   *mutex_for_titles);
+    virtual void run(void);
+    void    Cancel(void);
+
+    bool    IsDiscPresent(void) const { return have_disc; }
+
+  private:
+    ~DiscCheckingThread();
+    bool    IsCancelled(void) const;
+
+  private:
+    MythTranscodeDaemon *parent;
+    DVDProbe            *dvd_probe;
+    volatile bool        have_disc;
+    QMutex              *dvd_drive_access;
+    QMutex              *titles_mutex;
+    QMutex              *cancelLock;
+    QWaitCondition      *cancelWaitCond;
+    bool                 cancel_me;
+};
+
+class MythTranscodeDaemon : public QObject
+{
+
+    Q_OBJECT
+
+    //
+    //  Core logic (wait for connections, launch transcoding
+    //  threads)
+    //
+
+  public:
+
+    MythTranscodeDaemon(int port, bool log_stdout);
+    ~MythTranscodeDaemon();
+    bool Init(void);
+
+    bool threadsShouldContinue(void) const { return keep_running; }
+    bool IncrConcurrentTranscodeCounter(void);
+
+  signals:
+
+    void writeToLog(const QString &entry);
+
+  private slots:
+
+    void newConnection(void);
+    void endConnection(void);
+    void readSocket(void);
+    void parseTokens(const QStringList &tokens, QTcpSocket *socket);
+    void sendMessage(QTcpSocket *where, const QString &what);
+    void sayHi(QTcpSocket *socket);
+    void sendStatusReport(QTcpSocket *socket);
+    void sendMediaReport(QTcpSocket *socket);
+    void startJob  (const QStringList &tokens);
+    void startAbort(const QStringList &tokens);
+    void startDVD  (const QStringList &tokens);
+    void useDrive  (const QStringList &tokens);
+    void useDVD    (const QStringList &tokens);
+    void noDrive   (const QStringList &tokens);
+    QString noDVD  (const QStringList &tokens);
+    void forgetDVD();
+    void cleanThreads();
+    void checkDisc();
+    bool checkFinalFile(QFile *final_file, const QString &extension);
+    void writeStatus(const QString &);
+
+  private:
+    void customEvent(QEvent *ce);
+    void ShutDownThreads(void);
+
+    int                 listening_port;
+    bool                log_to_stdout;
+    MTDLogger          *mtd_log;
+    QTcpServer         *server_socket;
+    JobThreadList       job_threads;
+    mutable QMutex     *dvd_drive_access;
+    mutable QMutex     *titles_mutex;
+    volatile bool       keep_running;
+    bool                have_disc;
+    QTimer             *thread_cleaning_timer;
+    QTimer             *disc_checking_timer;
+    QString             dvd_device;
+    DVDProbe           *dvd_probe;
+    DiscCheckingThread *disc_checking_thread;
+    int                 nice_level;
+    mutable QMutex     *concurrent_transcodings_mutex;
+    int                 concurrent_transcodings;
+    int                 max_concurrent_transcodings;
+    QString             m_statusMsg;
+    int                 m_statusCount;
+};
+
+#endif  // mtd_h_
diff --git a/mythtv/programs/mythmtd/mythmtd.pro b/mythtv/programs/mythmtd/mythmtd.pro
new file mode 100644
index 0000000..06578c0
--- /dev/null
+++ b/mythtv/programs/mythmtd/mythmtd.pro
@@ -0,0 +1,24 @@
+include ( ../../settings.pro )
+include ( ../../version.pro )
+include ( ../programs-libs.pro )
+
+QT += sql xml network
+
+TEMPLATE = app
+CONFIG += thread opengl
+target.path = $${PREFIX}/bin
+INSTALLS += target
+
+HEADERS += libmythtv/videodbcheck.h logging.h mtd.h
+HEADERS += jobthread.h dvdprobe.h fileobs.h threadevents.h
+
+LIBS += -L../../libs/libmythdvdnav
+LIBS += -lmythdvdnav-$$LIBVERSION
+
+SOURCES += main.cpp libmythtv/videodbcheck.cpp logging.cpp mtd.cpp
+SOURCES += jobthread.cpp dvdprobe.cpp fileobs.cpp threadevents.cpp
+
+mingw:DEFINES += USING_MINGW
+
+win32:LIBS += -lws2_32
+macx :LIBS += -framework CoreFoundation
diff --git a/mythtv/programs/mythmtd/threadevents.cpp b/mythtv/programs/mythmtd/threadevents.cpp
new file mode 100644
index 0000000..e39bb1e
--- /dev/null
+++ b/mythtv/programs/mythmtd/threadevents.cpp
@@ -0,0 +1,38 @@
+/*
+    threadevents.cpp
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    Methods for thread <--> mtd communication
+    events.
+
+
+*/
+
+#include "threadevents.h"
+
+QEvent::Type LoggingEvent::kEventType =
+    (QEvent::Type) QEvent::registerEventType();
+QEvent::Type ErrorEvent::kEventType =
+    (QEvent::Type) QEvent::registerEventType();
+
+LoggingEvent::LoggingEvent(const QString &init_logging_string) :
+    QEvent(kEventType), logging_string(init_logging_string)
+{
+}
+
+const QString &LoggingEvent::getString()
+{
+    return logging_string;
+}
+
+ErrorEvent::ErrorEvent(const QString &init_error_string) :
+    QEvent(kEventType), error_string(init_error_string)
+{
+}
+
+const QString &ErrorEvent::getString()
+{
+    return error_string;
+}
diff --git a/mythtv/programs/mythmtd/threadevents.h b/mythtv/programs/mythmtd/threadevents.h
new file mode 100644
index 0000000..1e6eb00
--- /dev/null
+++ b/mythtv/programs/mythmtd/threadevents.h
@@ -0,0 +1,41 @@
+#ifndef THREADEVENTS_H_
+#define THREADEVENTS_H_
+/*
+    threadevents.h
+
+    (c) 2003 Thor Sigvaldason and Isaac Richards
+    Part of the mythTV project
+
+    Headers for custom events that the main mtd and
+    the job threads can pass to each other.
+
+*/
+
+#include <QEvent>
+#include <QString>
+
+class LoggingEvent : public QEvent
+{
+  public:
+    LoggingEvent(const QString &init_logging_string);
+    const QString &getString();
+
+    static Type kEventType;
+
+  private:
+    QString logging_string;
+};
+
+class ErrorEvent : public QEvent
+{
+  public:
+    ErrorEvent(const QString &init_error_string);
+    const QString &getString();
+
+    static Type kEventType;
+
+  private:
+    QString error_string;
+};
+
+#endif
diff --git a/mythtv/programs/programs.pro b/mythtv/programs/programs.pro
index 358c0ae..d5cba01 100644
--- a/mythtv/programs/programs.pro
+++ b/mythtv/programs/programs.pro
@@ -8,6 +8,7 @@ using_frontend {
     SUBDIRS += mythjobqueue mythlcdserver mythlogserver
     SUBDIRS += mythwelcome mythshutdown mythutil
     SUBDIRS += mythpreviewgen mythmediaserver mythccextractor
+    SUBDIRS += mythmtd
     !mingw: SUBDIRS += mythtranscode/replex
 }
 
diff --git a/mythtv/themes/DVR/main_settings.xml b/mythtv/themes/DVR/main_settings.xml
index ded5cbb..7709a9d 100644
--- a/mythtv/themes/DVR/main_settings.xml
+++ b/mythtv/themes/DVR/main_settings.xml
@@ -77,7 +77,7 @@
     <button>
         <type>SETTINGS_VIDEO</type>
         <text>Videos Settings</text>
-        <description>Configure playback and metadata</description>
+        <description>Configure playback, metadata and DVD ripping</description>
         <action>MENU video_settings.xml</action>
     </button>
 
diff --git a/mythtv/themes/DVR/video_settings.xml b/mythtv/themes/DVR/video_settings.xml
index 48bce80..9a8bd1f 100644
--- a/mythtv/themes/DVR/video_settings.xml
+++ b/mythtv/themes/DVR/video_settings.xml
@@ -28,4 +28,12 @@
       <description>Associate new file extensions</description>
    </button>
 
+   <!-- MythDVD -->
+   <button>
+      <type>DVD_RIP</type>
+      <text>Rip Settings</text>
+      <action>DVD_SETTINGS_RIP</action>
+      <description>DVD Rip and Transcode options</description>
+   </button>
+
 </mythmenu>
diff --git a/mythtv/themes/DVR/videomenu.xml b/mythtv/themes/DVR/videomenu.xml
index 7a0e15d..8e69869 100644
--- a/mythtv/themes/DVR/videomenu.xml
+++ b/mythtv/themes/DVR/videomenu.xml
@@ -31,6 +31,12 @@
       <action>DISC_PLAY</action>
    </button>
 
+    <button>
+      <type>DVD_RIP</type>
+      <text>Rip DVD</text>
+      <action>DVD_RIP</action>
+   </button>
+
    <button>
       <type>EJECT</type>
       <text>Eject media</text>
@@ -41,7 +47,7 @@
     <button>
         <type>SETTINGS_VIDEO</type>
         <text>Video Settings</text>
-        <description>Configure video and DVD playback</description>
+        <description>Configure playback, metadata and DVD ripping</description>
         <action>MENU video_settings.xml</action>
     </button>
 
diff --git a/mythtv/themes/classic/main_settings.xml b/mythtv/themes/classic/main_settings.xml
index 28efb59..004923e 100644
--- a/mythtv/themes/classic/main_settings.xml
+++ b/mythtv/themes/classic/main_settings.xml
@@ -85,7 +85,7 @@
     <button>
         <type>SETTINGS_VIDEO</type>
         <text>Videos Settings</text>
-        <description>Configure playback and metadata</description>
+        <description>Configure playback, metadata and DVD ripping</description>
         <action>MENU video_settings.xml</action>
     </button>
 
diff --git a/mythtv/themes/classic/video_settings.xml b/mythtv/themes/classic/video_settings.xml
index 48bce80..9a8bd1f 100644
--- a/mythtv/themes/classic/video_settings.xml
+++ b/mythtv/themes/classic/video_settings.xml
@@ -28,4 +28,12 @@
       <description>Associate new file extensions</description>
    </button>
 
+   <!-- MythDVD -->
+   <button>
+      <type>DVD_RIP</type>
+      <text>Rip Settings</text>
+      <action>DVD_SETTINGS_RIP</action>
+      <description>DVD Rip and Transcode options</description>
+   </button>
+
 </mythmenu>
diff --git a/mythtv/themes/classic/videomenu.xml b/mythtv/themes/classic/videomenu.xml
index 7a0e15d..8e69869 100644
--- a/mythtv/themes/classic/videomenu.xml
+++ b/mythtv/themes/classic/videomenu.xml
@@ -31,6 +31,12 @@
       <action>DISC_PLAY</action>
    </button>
 
+    <button>
+      <type>DVD_RIP</type>
+      <text>Rip DVD</text>
+      <action>DVD_RIP</action>
+   </button>
+
    <button>
       <type>EJECT</type>
       <text>Eject media</text>
@@ -41,7 +47,7 @@
     <button>
         <type>SETTINGS_VIDEO</type>
         <text>Video Settings</text>
-        <description>Configure video and DVD playback</description>
+        <description>Configure playback, metadata and DVD ripping</description>
         <action>MENU video_settings.xml</action>
     </button>
 
diff --git a/mythtv/themes/default-wide/dvd-ui.xml b/mythtv/themes/default-wide/dvd-ui.xml
new file mode 100644
index 0000000..fcd9521
--- /dev/null
+++ b/mythtv/themes/default-wide/dvd-ui.xml
@@ -0,0 +1,246 @@
+<mythuitheme>
+
+    <!-- The dvd ripping/transcoding screen -->
+    <window name="dvd_rip">
+        <imagetype name="banner">
+            <filename>md_rip_banner.png</filename>
+        </imagetype>
+
+        <textarea name="title" from="basetextarea">
+            <font>baselarge</font>
+            <area>200,25,600,95</area>
+            <value>Rip/Transcode</value>
+        </textarea>
+
+        <imagetype name="progress_background">
+            <filename>md_progress_background.png</filename>
+            <position>50,120</position>
+        </imagetype>
+
+        <!--
+            Context 1 & 2
+            Warnings or Status Messages
+            -->
+
+        <textarea name="warning" from="basetextarea">
+            <multiline>yes</multiline>
+            <area>100,170,600,300</area>
+            <align>allcenter</align>
+        </textarea>
+
+        <!--
+            Context 3
+            Browse active jobs
+            -->
+
+        <textarea name="overall_text" from="basetextarea">
+            <area>50,150,700,30</area>
+            <align>allcenter</align>
+        </textarea>
+
+        <textarea name="job_text" from="basetextarea">
+            <area>50,300,700,30</area>
+            <align>allcenter</align>
+        </textarea>
+
+        <textarea name="numbjobs" from="basetextarea">
+            <area>325,450,150,30</area>
+            <align>allcenter</align>
+        </textarea>
+
+        <progressbar name="overall_progress" from="baseprogressbar">
+            <position>132,190</position>
+        </progressbar>
+
+        <progressbar name="job_progress" from="baseprogressbar">
+            <position>132,340</position>
+        </progressbar>
+
+        <button name="next">
+            <area>485,435,37,64</area>
+            <statetype name="buttonstate">
+                <state name="active">
+                    <imagetype name="background">
+                        <filename>mv_next_off.png</filename>
+                    </imagetype>
+                </state>
+                <state name="selected" from="active">
+                    <imagetype name="background">
+                        <filename>mv_next_on.png</filename>
+                    </imagetype>
+                </state>
+                <state name="disabled" from="active" />
+                <state name="pushed" from="active">
+                    <imagetype name="background">
+                        <filename>mv_next_pushed.png</filename>
+                    </imagetype>
+                </state>
+            </statetype>
+        </button>
+
+        <button name="prev">
+            <area>255,435,37,64</area>
+            <statetype name="buttonstate">
+                <state name="active">
+                    <imagetype name="background">
+                        <filename>mv_prev_off.png</filename>
+                    </imagetype>
+                </state>
+                <state name="selected" from="active">
+                    <imagetype name="background">
+                        <filename>mv_prev_on.png</filename>
+                    </imagetype>
+                </state>
+                <state name="disabled" from="active" />
+                <state name="pushed" from="active">
+                    <imagetype name="background">
+                        <filename>mv_prev_pushed.png</filename>
+                    </imagetype>
+                </state>
+            </statetype>
+        </button>
+
+        <button name="ripscreen" from="basebutton">
+            <position>225,530</position>
+        </button>
+
+        <button name="cancel" from="basebutton">
+            <position>425,530</position>
+        </button>
+    </window>
+
+    <window name="title_dialog">
+
+        <imagetype name="banner">
+            <filename>md_rip_banner.png</filename>
+        </imagetype>
+
+        <textarea name="title" from="basetextarea">
+            <area>200,25,600,95</area>
+            <font>baselarge</font>
+            <value>Rip/Transcode</value>
+        </textarea>
+
+        <imagetype name="progress_background">
+            <filename>md_progress_background.png</filename>
+            <position>50,120</position>
+        </imagetype>
+
+        <!-- A bunch of text "labels" -->
+        <textarea name="playtime_text" from="basetextarea">
+            <area>70,150,250,30</area>
+            <value>Length:</value>
+            <align>right</align>
+        </textarea>
+
+        <textarea name="ripcheck_text" from="playtime_text">
+            <position>70,178</position>
+            <value>Select:</value>
+        </textarea>
+
+        <textarea name="ripname_text" from="playtime_text">
+            <position>70,228</position>
+            <value>Name:</value>
+        </textarea>
+
+        <textarea name="ripquality_text" from="playtime_text">
+            <position>70,273</position>
+            <value>Quality:</value>
+        </textarea>
+
+        <textarea name="ripaudio_text" from="playtime_text">
+            <position>70,318</position>
+            <value>Audio Track:</value>
+        </textarea>
+
+        <textarea name="ripacthree_text" from="playtime_text">
+            <position>70,363</position>
+            <value>AC3 Audio:</value>
+        </textarea>
+
+        <textarea name="subtitle_text" from="playtime_text">
+            <position>70,398</position>
+            <value>Subtitles:</value>
+        </textarea>
+
+        <textarea name="ripview_text" from="playtime_text">
+            <position>70,436</position>
+            <value>View:</value>
+        </textarea>
+
+        <!-- Widgets that actually do things -->
+
+        <textarea name="playlength" from="basetextarea">
+            <area>330,150,300,40</area>
+            <value>0:00:00</value>
+        </textarea>
+
+        <checkbox name="ripcheck" from="basecheckbox">
+            <position>330,178</position>
+        </checkbox>
+
+        <textedit name="name" from="basetextedit">
+            <position>330,213</position>
+        </textedit>
+
+        <buttonlist name="quality" from="baseselector">
+            <position>330,268</position>
+        </buttonlist>
+
+        <buttonlist name="audio" from="baseselector">
+            <position>330,313</position>
+        </buttonlist>
+
+        <checkbox name="ripacthree" from="basecheckbox">
+            <position>330,358</position>
+        </checkbox>
+
+        <buttonlist name="subtitle" from="baseselector">
+            <position>330,393</position>
+        </buttonlist>
+
+        <button name="view">
+            <area>330,435,32,32</area>
+            <statetype name="buttonstate">
+                <state name="active">
+                    <imagetype name="background">
+                        <filename>blankbutton_off.png</filename>
+                    </imagetype>
+                </state>
+                <state name="selected" from="active">
+                    <imagetype name="background">
+                        <filename>blankbutton_on.png</filename>
+                    </imagetype>
+                </state>
+                <state name="disabled" from="active" />
+                <state name="pushed" from="active">
+                    <imagetype name="background">
+                        <filename>blankbutton_pushed.png</filename>
+                    </imagetype>
+                </state>
+            </statetype>
+        </button>
+
+        <textarea name="numb_titles" from="basetextarea">
+            <area>416,478,266,30</area>
+            <value>Title 1 of 1</value>
+            <align>allcenter</align>
+        </textarea>
+
+        <button name="prev_title" from="basebutton">
+            <position>255,470</position>
+            <value>Previous</value>
+        </button>
+
+        <button name="next_title" from="basebutton">
+            <position>635,470</position>
+            <value>Next</value>
+        </button>
+
+        <button name="ripaway" from="basebutton">
+            <position>200,530</position>
+        </button>
+
+    </window>
+
+</mythuitheme>
diff --git a/mythtv/themes/default/dvd-ui.xml b/mythtv/themes/default/dvd-ui.xml
new file mode 100644
index 0000000..33bcb03
--- /dev/null
+++ b/mythtv/themes/default/dvd-ui.xml
@@ -0,0 +1,246 @@
+<mythuitheme>
+
+    <!-- The dvd ripping/transcoding screen -->
+    <window name="dvd_rip">
+        <imagetype name="banner">
+            <filename>md_rip_banner.png</filename>
+        </imagetype>
+
+        <textarea name="title" from="basetextarea">
+            <font>baselarge</font>
+            <area>200,25,600,95</area>
+            <value>Rip/Transcode</value>
+        </textarea>
+
+        <imagetype name="progress_background">
+            <filename>md_progress_background.png</filename>
+            <position>50,120</position>
+        </imagetype>
+
+        <!--
+            Context 1 & 2
+            Warnings or Status Messages
+            -->
+
+        <textarea name="warning" from="basetextarea">
+            <multiline>yes</multiline>
+            <area>100,170,600,300</area>
+            <align>allcenter</align>
+        </textarea>
+
+        <!--
+            Context 3
+            Browse active jobs
+            -->
+
+        <textarea name="overall_text" from="basetextarea">
+            <area>50,150,700,30</area>
+            <align>allcenter</align>
+        </textarea>
+
+        <textarea name="job_text" from="basetextarea">
+            <area>50,300,700,30</area>
+            <align>allcenter</align>
+        </textarea>
+
+        <textarea name="numbjobs" from="basetextarea">
+            <area>325,450,150,30</area>
+            <align>allcenter</align>
+        </textarea>
+
+        <progressbar name="overall_progress" from="baseprogressbar">
+            <position>132,190</position>
+        </progressbar>
+
+        <progressbar name="job_progress" from="baseprogressbar">
+            <position>132,340</position>
+        </progressbar>
+
+        <button name="next">
+            <area>485,435,37,64</area>
+            <statetype name="buttonstate">
+                <state name="active">
+                    <imagetype name="background">
+                        <filename>mv_next_off.png</filename>
+                    </imagetype>
+                </state>
+                <state name="selected" from="active">
+                    <imagetype name="background">
+                        <filename>mv_next_on.png</filename>
+                    </imagetype>
+                </state>
+                <state name="disabled" from="active" />
+                <state name="pushed" from="active">
+                    <imagetype name="background">
+                        <filename>mv_next_pushed.png</filename>
+                    </imagetype>
+                </state>
+            </statetype>
+        </button>
+
+        <button name="prev">
+            <area>255,435,37,64</area>
+            <statetype name="buttonstate">
+                <state name="active">
+                    <imagetype name="background">
+                        <filename>mv_prev_off.png</filename>
+                    </imagetype>
+                </state>
+                <state name="selected" from="active">
+                    <imagetype name="background">
+                        <filename>mv_prev_on.png</filename>
+                    </imagetype>
+                </state>
+                <state name="disabled" from="active" />
+                <state name="pushed" from="active">
+                    <imagetype name="background">
+                        <filename>mv_prev_pushed.png</filename>
+                    </imagetype>
+                </state>
+            </statetype>
+        </button>
+
+        <button name="ripscreen" from="basebutton">
+            <position>225,530</position>
+        </button>
+
+        <button name="cancel" from="basebutton">
+            <position>425,530</position>
+        </button>
+    </window>
+
+    <window name="title_dialog">
+
+        <imagetype name="banner">
+            <filename>md_rip_banner.png</filename>
+        </imagetype>
+
+        <textarea name="title" from="basetextarea">
+            <area>200,25,600,95</area>
+            <font>baselarge</font>
+            <value>Rip/Transcode</value>
+        </textarea>
+
+        <imagetype name="progress_background">
+            <filename>md_progress_background.png</filename>
+            <position>50,120</position>
+        </imagetype>
+
+        <!-- A bunch of text "labels" -->
+        <textarea name="playtime_text" from="basetextarea">
+            <area>70,150,250,30</area>
+            <value>Length:</value>
+            <align>right</align>
+        </textarea>
+
+        <textarea name="ripcheck_text" from="playtime_text">
+            <position>70,178</position>
+            <value>Select:</value>
+        </textarea>
+
+        <textarea name="ripname_text" from="playtime_text">
+            <position>70,228</position>
+            <value>Name:</value>
+        </textarea>
+
+        <textarea name="ripquality_text" from="playtime_text">
+            <position>70,273</position>
+            <value>Quality:</value>
+        </textarea>
+
+        <textarea name="ripaudio_text" from="playtime_text">
+            <position>70,318</position>
+            <value>Audio Track:</value>
+        </textarea>
+
+        <textarea name="ripacthree_text" from="playtime_text">
+            <position>70,363</position>
+            <value>AC3 Audio:</value>
+        </textarea>
+
+        <textarea name="subtitle_text" from="playtime_text">
+            <position>70,398</position>
+            <value>Subtitles:</value>
+        </textarea>
+
+        <textarea name="ripview_text" from="playtime_text">
+            <position>70,436</position>
+            <value>View:</value>
+        </textarea>
+
+        <!-- Widgets that actually do things -->
+
+        <textarea name="playlength" from="basetextarea">
+            <area>330,150,300,40</area>
+            <value>0:00:00</value>
+        </textarea>
+
+        <checkbox name="ripcheck" from="basecheckbox">
+            <position>330,178</position>
+        </checkbox>
+
+        <textedit name="name" from="basetextedit">
+            <position>330,213</position>
+        </textedit>
+
+        <buttonlist name="quality" from="baseselector">
+            <position>330,268</position>
+        </buttonlist>
+
+        <buttonlist name="audio" from="baseselector">
+            <position>330,313</position>
+        </buttonlist>
+
+        <checkbox name="ripacthree" from="basecheckbox">
+            <position>330,358</position>
+        </checkbox>
+
+        <buttonlist name="subtitle" from="baseselector">
+            <position>330,393</position>
+        </buttonlist>
+
+        <button name="view">
+            <area>330,435,32,32</area>
+            <statetype name="buttonstate">
+                <state name="active">
+                    <imagetype name="background">
+                        <filename>blankbutton_off.png</filename>
+                    </imagetype>
+                </state>
+                <state name="selected" from="active">
+                    <imagetype name="background">
+                        <filename>blankbutton_on.png</filename>
+                    </imagetype>
+                </state>
+                <state name="disabled" from="active" />
+                <state name="pushed" from="active">
+                    <imagetype name="background">
+                        <filename>blankbutton_pushed.png</filename>
+                    </imagetype>
+                </state>
+            </statetype>
+        </button>
+
+        <textarea name="numb_titles" from="basetextarea">
+            <area>266,468,266,30</area>
+            <value>Title 1 of 1</value>
+            <align>allcenter</align>
+        </textarea>
+
+        <button name="prev_title" from="basebutton">
+            <position>255,435</position>
+            <value>Previous</value>
+        </button>
+
+        <button name="next_title" from="basebutton">
+            <position>485,435</position>
+            <value>Next</value>
+        </button>
+
+        <button name="ripaway" from="basebutton">
+            <position>200,530</position>
+        </button>
+
+    </window>
+
+</mythuitheme>
diff --git a/mythtv/themes/default/images/mv_next_off.png b/mythtv/themes/default/images/mv_next_off.png
new file mode 100644
index 0000000000000000000000000000000000000000..4abe8904207c78d16c4cab67ad71e338ae1a9685
GIT binary patch
literal 1515
zcmV<H1r+*;P)<h;3K|Lk000e1NJLTq002Ay002A)1^@s6I{evk00006VoOIv0RI60
z0RN!9r;`8x010qNS#tmY3lRVS3lRZ-WM7d0000McNliru(*+d*D<r<IAu0d>1$aqB
zK~!ko?V3w(+*B0D|M%LS_ltItP)%vGf(2PXR;9`s!b3bHB%mx<6txj4e1Npj3g{<b
zLpOW@SimmbPiFFHCyQiOY(}CF3Wbu%B=h!Vaj(brJUrLVILg9DI&w6!{`vpr9G`nV
zHV{M*K?D&*5J3bHL=cmW!gd*qv0fIo%dR!v|LQgh+hxWW`_ahacDeH2m$yGS(Xd{j
z1#H<0Y(js3a)1rMVV}8y7O-W6;><`J^tJEY84JbD^c&a)T`Ic=j-+{plRfCdcDeHI
z^0#lg0*<74hLipS+o5;mfg@>#_!L88h94to6S}lpd1vXSoUuq6h))5D8GekU{Regf
z-2;wg8B#fh%z1{)IfmpJhG@nH{r1w=uZ%So%L1t!kU0-z&H>3YKs0kCRw{E6Ap`*M
z+N&>1RT`86iV7$ipoRf00%%c?*r}^RXZ8A(kA8jY%8i%2=pg!>zrgOH2>=BkDnLVk
z5&_gGpv7#^H<muWyZHI_tQQ@x(A3Sz($IwPq!geEuaX)D)QEsS-Glz-i%;&oad{=-
zMF-JS{sPNG6M#^FDBLL303~D^4aGp>*&g)G<x9J-UtZC?=pc65UtlR{qcTorH9PdJ
z<x9VN)o}w&y<Ysz&_q<H&#cm4p*To<ss~*t?N$cuQ7Ik7vi<@)LmLLIX*C<>(^liV
zD3X}AK<`v+Q<}=_AU@?Ua6h!Y6@@ulssL4abquqi1Q1GqB%c@1b0##^hG;nJAU^Fc
zuoZfAOZQcXD5hD}s89kV{elU7f2RVfaWJB|(s6>G2=D;3v6K)BP-3>Gk&0+bRRgpz
zpSGa{5Ke+*U*yp9bE}2BKUet1LmAW<r4!~lNX+;PY^SFqTH2CS1xWw!G1_~^g#PU(
zUTLDb)JXz~>0<(RY-vkUaXl)UFl#I|adXL<pIa^b@<U~Ccsc2aHCl@gELlEPcns)J
zvtkITVV+bocVzQ(tI|4D1yoUOp<~^VslHXXzoi{dX8<GO``0Z)$~qSm(K%yubOI3F
z^1tmms(%$Gd|(kVU`F3m0*oI3o&TYC0M;G6b8-Y0Iz))E?ob`o*P(@R6=ncq0P6ru
z2fD&wrw-^{u!E;}0HCl{TI5<}ypFB|ofgn(^mK6e&oQ(#`mV8&l@*ofG<oW6pxppF
z`1=k3tZm#|T=?wPET7aeIt`$G2sCRzy8#?NJ&p>KzKuT}58FNf+I67Y2CF^cu<M(P
z3!kpcLXEi7X;%61;I9E|69cyYMC3HItnJt3CR>KdL$JL+IBaoaapA*jvj`_eD^oe0
z#y&sRp7^)%82CNRcH?eM@i}yWwMF~YfaV_1s@h>MUYG^z*mrJHI{QHFPye=-2JBjK
zW5ha4EK36s!--#~Xw`tm9?+_RRUg}70e)_82+HX=!5$gd3cGOe!eC1qZAhraq!=u%
z8qoL;Xzqhm9}U7<zdT7D>_7JJ_HZ;T%qkeIZB(n<=1WCW61Ml{jn|QZ^$hF?Ya3d^
zq;9ldottYs6R-~@V8`oV|B<wJb@H$<cSKB>WL<8uwGY&v0nIAd-h(l)ayqC!bmd>2
zJgni9@%Gcj6m3>r!j9K*3+oD48rEn%y#sWcK!@=qqy8_@*c)7WJnEqOz|-teCk_h$
z-4<Uibg=_!R^7uo=y-*d0(K1x@V%_D4tJYCyY3!#gw9c5$38tYKF=4|Wp((|!&HtT
zbyj4q_tY?7T(7t?mdXLCvm$eo+v_{M0gx|ly3w%!=lWnbDz1&Ca%N643Z>nl?|9_b
zx7_Lsea9oezE#0Vi$ZC~2D`Rd@~UHdizmNv|K!025kwF{1QA3KK?LDL{0}ZK2>R;7
R*OmYP002ovPDHLkV1firzpMZN

literal 0
HcmV?d00001

diff --git a/mythtv/themes/default/images/mv_next_on.png b/mythtv/themes/default/images/mv_next_on.png
new file mode 100644
index 0000000000000000000000000000000000000000..465ff7dc5875b354d9686193edd631f28979b3cb
GIT binary patch
literal 1261
zcmV<J1QPp+P)<h;3K|Lk000e1NJLTq002Ay002A)1^@s6I{evk00006VoOIv0000B
z02J@cfa3rF010qNS#tmY3lRVS3lRZ-WM7d0000McNliru(*+C@2Pw(h=W74}1bRtC
zK~!ko?V8Vv<U|z5zg4Mpbtm1-x~{7*xWei|5fQxli$&3c-enc_u;A5$xBVMD_y_E9
zLA>liMf|yX@hT#M2bqD@)zx*JwbQ>+NvFy~Rep8%q|<TI6C@9cG)eKD_sM(pUR4;N
zwboi|t+m!#Ypu1`j>X7viXBcb-gJ9%ck%vYN`E=+zW+cIfa!6Ht%3yr*OBKACl_!0
z?;<SJD+&NO|2VxTUalVLj+_1tCe4d*UYP-ufp<U2Mf$e)>JL?Pzy}QmrVOw;0P6y*
z3*P%Qd9*W#9^1e5`qe5r=<YNX*iId_dw}hLJD(+wckc^c`{~9T?^e-4?^F|kDPS?c
zvH`{cTRY61&yy+V&xv=w|M|_gtLUJ2SJT!o0bl`y0ki{HU4X@rPN5%p$bawJ^|v0a
zqEi*R9$-TBpcJ5%juPW0H63v0i)89c7luE+c<FM#iVk|G8x&ze0b*%Kb8FE7Iu5w|
zWitE2D|@3CE?u^(=)k$VK@l!;*3LtJbY(B7s<R1njca&?v({pSTyXcRrHxD8Jz7c!
z&Y32pbarH&<)+QJ8oGadH8iDql+=NH&q=1VaV|Glx|xWb?eu|8AAIo5GBmYUXcX(f
zJ==toUWgE}QfFBlp+5M|w|Qu4YcOJMq*DaVYKw53iqt?ano{~%oVHXu&(C}ZaqxtO
z{_AnY@82h|tW<BU4o!>Q_|I*nG(94vGlMdKEEb<Qy}wQ){p)!hX~H(t836sWO-Sj?
zpk_T<wsAIYHEynDiT!)ka`7tCF+JLLms(cMMXSU}oQ+RLTn}pJc4Vb>C<9o0!qPg~
z9T}^)EoD-#aJm8%G4Eeyid5$N1hLkCuOJGL1Ryf=xAQvn6)i&2f<=oGNdZb<0I7e-
zIiRBDlT#tE(IG}mMJsh!twjs#BCK?kRdYZ|ATkclXMl_#CeLT)TKR|{r6VOU4}iI!
z=wSNy7E&4uYwXC#nn=ur9x?<%A7b)cGLt_%Cc09W(eZ(B3WzZf`oQ#HOMRFuROxlF
z;RFb0KomlZFQl*!9uTnZW;(*t*U9ZIZ9EE#RyO@2?PL%;IfWQLnZoYw5%7UYWm-<h
zAL;9gO~;l#0Az=`4+*Hyq~912Lm=?-u;c>*HP7$dO6iP%@gFC3c*q{@%w|MMAkym;
z!5Hv|Krn{zp3TDodTvq#%jp!s)_**V(~!`Nlcul)W5E9h5F-fhnPu4Q%PXma(XA6a
z9wJk?;%G&oZWW>=Z1VEf>y&}r!Uq83q>R&Vrk(Te7}%#vz^>Q9==ai|)!2v4?nz4B
zHo}=MD6>0&@F0dyt${741MjzuJY)6oDxH4PR8iq=2)kZqQ`q`|rPLdNNC0!CTgL1V
z@Q2H-r=kwLo0VLv2RI6JyO3rFB)rXG3v{Z&)(0F;(>@#tAe?OudxXw^fvpc%MLHU$
z;*?&qYjmot*)3J+xU`}=?1Ij5zydY>%fl+G23uRhtQWc|u&uS$T5GMf)>><=)oK3%
XM7TpRUiRiN00000NkvXXu0mjfF^X13

literal 0
HcmV?d00001

diff --git a/mythtv/themes/default/images/mv_next_pushed.png b/mythtv/themes/default/images/mv_next_pushed.png
new file mode 100644
index 0000000000000000000000000000000000000000..e3b42bf062f4e001efc7f6b83b238723fca25b75
GIT binary patch
literal 1286
zcmV+h1^N1kP)<h;3K|Lk000e1NJLTq002Ay002A)1^@s6I{evk00006VoOIv0000B
z02J@cfa3rF010qNS#tmY3lRVS3lRZ-WM7d0000McNliru(*+C?I~A0Lh$H|21d~Zb
zK~!ko?V3wZRA(5+pN+Q4O<=gqh09!E7-4{VL)+p79TY|Zi&9Fu!dR1P)3vrSX=|5$
z2;KE7=&Ds5L6j+_V0G11S6x-(!sPh;&*Om^m|@PFX5bBZ|H%{PTym1%d9Lq!ATlyC
zGBPqUGBPsKPb1&lnwb0ZrIjfh4_~`Ax-Eg%!e&GNwEdtRz))vk#a5sf8T#svYS24N
zR!w){#Bi%^r`Q}lS$tug`}&77O28jhh<#9|Kk!%IcG;E%{l{Nc^2*I#R}TbeNexkH
zo&3eI?!Z6a?p+5xyYSo^y7GN@!3Xa45S9Cg_B63I5|uR&?b@S1a6ah4%ipza_`uRy
zqDqFX4ikAIL{%;P0svj9H}IWbj^>3ved&fLKQM=KWsqT`M74W~YT6k(C|=hAIv?;|
z2F?rp`?57Kb-gs_1Iy|eFvPGiqWU;nC;x7jb2fC9zQFf>P2`21Vd%uv^&RVhIee=*
zl<OGO+r#z|QA3w_8|N$hoafbg0^k2FQ4o6F1IxV}&aLcOhV<<x@*j}D4L$M_aIGS+
zb<l-?=a-Ud(B*!~-v%z|{)0pT?q-2Q^4q&l!rap)6@0fxKj8FovM_XdX%!kE$X|pq
zU>lFTx5IMmJ0LFu#SE<ry;?WmzyBF22tECDL7-8b5V`<s{Ftce(+vAW&iN0?3qf92
za@#7Y)eqPe^xVR831`k%f3H9`AI-L=J~<y?k9#?{YdfTkZ5Fg!;D7%ca}SL|)x@4`
zVZh+=_11EXtxxVjZX>S|8R+5K0KXbjg9cQvpD1)Px8WM#oBJfUQPr!$GO6hT{QB)h
zHR$juqHrR=h4^}?Up$Twho_O##cWwBz;CQ^fqo^>xQ2V~W<V!0peZsy6gj=Ig$Kmr
z2!Dik4cCCu`r=JwMFnmhBx)ThV0=%Q!GkBn%c$IC-r{+=sKC)AQS|Hv#@E{z8j*l}
zhKDhfpm^y3tOEORW^R$9!$j>Pd5o_`&xwbT%jnO@;bKo<N>$n=?1R*7+V&j4V&`+%
zs9bAHO7TKpM(^H?eyjrQ3ii?CwB2%$pMcvtw#Gh_^YAW;7KRZ_UApyQSFqEmv^_nw
z92f7!7_ehJ!!9!L1@`W!yb#=n`>P^SnRS}9T)@gKjfDX~P?P`|pLlPd6LpS@hf%B$
z1(?XHHxbq?u!}HWT`i&T02oCHfL)VpUkG%^1qo&JT`VB5HpYg5ZmT8NunsVKD#A9-
zpxs{zG~jU#MGB)N+RtXgx&c;#T><Ww!URwN!@D>}kqR7<X$r%IjyoPour_d)^i||4
zfa8-=og-(Y*J9z1%{(3Vw3K0O;BEnqF>vRE6fRU`EdFa^TMJtVSQ*x-(kM#ES9lif
z34;Y@WbAk8{^dal7OIQOat|XT!nj!@*h1fylwl!k@i^N%&gw@O*j&K>3l^$qlw8GL
z6^06(VAldWpGvb~XDp=$q9_5<HXmsx2h8~xp0&hF&05M2w1Itk!a}L^a?bzpc=&kE
wqV1~G{8AR|^z5_k3u|O#WMpJyWMq_~cesBE7WxK+j{pDw07*qoM6N<$f~q}ZmjD0&

literal 0
HcmV?d00001

diff --git a/mythtv/themes/default/images/mv_prev_off.png b/mythtv/themes/default/images/mv_prev_off.png
new file mode 100644
index 0000000000000000000000000000000000000000..6a062d2feccf2f85858f1c4c4df83ee4e4415426
GIT binary patch
literal 1569
zcmV++2HyFJP)<h;3K|Lk000e1NJLTq002Ay002A)1^@s6I{evk00006VoOIv0RI60
z0RN!9r;`8x010qNS#tmY3lIPR3lIUVBfWJ1000McNliru(+3s+DGy84k_Z3*1+Ga%
zK~#90?V8JP8&wpCzZs9;v6D70Dwom~EXsniYD?Bo9-<%?KqXd1bwwy^)Rq<j-LtI!
z1cZcGuz-EyBz-uGCJV%-5`98wY2qY)WiE?*=ar1(8GF(NnxAwvR-F0yd_HH+xnmn*
z#flXxR;*aDV#WG@>D2kF@6RnR-w{GwvsQI+S-khf)zDtm#btyL_Np!}??J=^=+yb|
z*bb}Ka&>W8gz?%AyLZs3yt6{+)aT!NU`geLwS*AMLWsbTx?$b&``chj7a%h%R|w#D
zr@wi#>V{1h1esyELIPK7{;&`=aAp|t<1jQSkD1{>r@eFT3f0<@1DhEZ<i`a=lk%7u
z4h&qaE$s>w9dLF83I|~15RAM4#S-MkdY<<7xvyUFz-C7Tg#&_-LxPbP1jUjdHx>xE
z7c6*zjgW|rvil&J0V4yt0YZQVnC)Fpd+Y3_moA?D@aN-4kNgUt<@T3JW<&dcggt)r
z2mqR<1q!=A;Oss~=D<ipA`O}j<`!TgqxILxPcM#LI``3UUfA$H&>t-H1DxHDoe?7?
zvw{W)Fg57%;%}U}Fm(B|k8e7#qY5^h5A+WUVS#g_3N{Og6eJAL5;903WQKe)^ZJ<!
z$t%;Rmu%SlSeaBVv=0mh3t@nBqq2;XSy_I%0eV7aLI}`I`Pe6jucuG{;eqYbXHeMS
zz_~H(j2LOqlTMJb!>Gr)TAm>9II!boQuzQr)`}K37;t`EWj5C(NF_}NT`fDv+Yao|
zgoF*^v#q3~g6$2QpI~Q@#?Bzo<Ta=z<p0>PFH6|Mb7fLPA$)XCNk;{{J8*siC&&yW
zl1?Y}dtoi1uE!+RTQ1n)=OwI>4d~-v(ow)dH{hX337g8hf=mFqe~<zo0T@(&`SH&2
zR~78oi)GRU*@=yG03QLSx-4AJM+FOhz(W&|DyULcV`H}<K|ZHzRDZhWz!oOU6iO=V
zMsHY4c1i2q|7QSsfpepf%*&2!UvEKz6jXos-hs`Jl}Q(+hpvNWsAkr~2hp{pqml!h
z-7lMok@oI>v_y{}WuP`}ZnSKdu#r|XH3+Qqv9lXt8N1~GTY*{KR!g`t6Clv8KDrA!
z0EBhUo@W?9Y=PO4M+9iXwd?6oihe!_<c&Zgn2#wy*ShYsqL9-WHvW-!DxFQ}G@#Q0
z)0CYP-6#95MS|*$+DQPhzEZJ$wpy^&0TIwgdF^G>^15!UK)V6WI<z+=xTylR=B9m(
zxtGRkpIkmXyKqxM|6QTofYv&+H=)xE=wpHIT}khJ8`uAW_Bu3I<uPcm0;W!Xd3bjI
zx`eJjs?c16)>=3p?OBzyTlGgWJB>AY>@;P$cPmS)0}GR>52g>#&MipjmES8go<d_a
zn2)>BxiTE(Cyw1Ol=?%No#s<$*JXK&HufEjt~oag?wyh7Fm>XX1O4>R3a!=PKDzFk
z;i#Z@?+o>a(5ge@sXVqDu+{b{OKa?)p2G{h`k)fZXWJZ}om+?ux_2vFdjQQfX#6XK
z?KGUui)-fkY%ILc_bb7Dyd^z#;#g$R!Fs<Nx>;8vr)_6*w;9_Nx|h$+H!l+C;KOe1
zzJh)tk8KsK=?>O^oOq${RR-`G7&_c^U%e;C)#ej5ZZ_rT$ENApZ26B9ZzH=~8Ng>C
z=<wSaH*|AVZct3CEXA(-g|5)yefoy(Z~wM>S9aXZ$8y}X)?rI+EUeP(9;|m{_3zUc
zbpIPx3wq<RYC>yj+_ZY0>I>bUPiW}DcIY<rinlZa$RD~dpGfC)FcnKsJg8PF)TuLb
z^Uk-3#gd?SP_0s^?}umR=AY5`!<LFAXNA<v+`=~KQfOf5bNw0p0w4m-%-`_;jYn-M
zRHQTWH~fF&QCr%p(EHcS!Y%Kwcxt!%O3Uo^+BVqRQHL5UR;*aDV#SITYlr>==^`B=
Tx?_}%00000NkvXXu0mjfaclag

literal 0
HcmV?d00001

diff --git a/mythtv/themes/default/images/mv_prev_on.png b/mythtv/themes/default/images/mv_prev_on.png
new file mode 100644
index 0000000000000000000000000000000000000000..6891e3aae694bf5d518ca61cb6caa69d9d06617a
GIT binary patch
literal 1370
zcmV-g1*Q6lP)<h;3K|Lk000e1NJLTq002Ay002A)1^@s6I{evk00006VoOIv0RI60
z0RN!9r;`8x010qNS#tmY3lIPR3lIUVBfWJ1000McNliru(+3s+DJhxQ7xe%D1m{Ua
zK~#90?OD%{+e8%pX6$5QdzYoVOF`PI2jBog2yreyRDs|CcLWGHRN~5kTmJ?Q`~f{y
zLcMSRgn%xE3s-~?5{GILm3G@wEp6i@yRnnl9NvsQ**M9J<7_zilPr5SJ73=C_vXDf
z6QD+o8Z~Ovs8ORvjY_~)ZGgi4-n+K~KRJK$@4aJwu<3tsuBz|hRS_+MX<`8&@RFS>
zzss$RsTt(YanE?#NwGqFlYJINZ&zcRhH3<hb%4oWNruML?uGCD9{8hNZ0lQqyVg85
zSX^*x18|xoI8BVF{dMPqs~hX_^J*--?*O-D&0~wj1bdGHt_L^`0F1nnrgNwLdF#W^
zcAkjdS7YIS4>Wvho-!ye*gFF>TI3b(l7S3BGMG8-x0@e*^5pscr)n(xAAp8u%~KZT
z1bb)5Bd!1(L1CDT03?`I>At-2@pI2U-TqvSNvu83BCsz@-ljCNB@J}}?f{$vjL}tq
zH!odYd+TER4>cD4^-?^G!p_6~mJC0S5|!fu%mI+fP~<4`%o~?3H@>>E*HL2;>;g^S
znx_hw3--6jBMpzjk4uj*CXGy{dgkjZd$D>J!ER}uDqtqq-_AYa3V=6qBPqkkXO5Gr
zBud}O(ya)7qy}X!kGiVIe8ItE(j)#9BPAH8^~ZC;V`A5CkXRF*m4$S0w!lbt(nv5`
zgUq4-!3nYJKLgD*3m(3LkPgmjMz*La;I1^Pz!>Jp_1G8}yYUP0xSk=;DnfegaWb+Q
zXhu2!ro8zS02}}=qT4UzVz+;#KHF)^(ld`I1rnZ@rX^rf@Y-3Rxh_LlmW^3P0`wVY
zi2gpOh4D|o`i}IvJ726q7ShYvxsD6=w}3`K897^TCPt=+Zf<MYcoz_l5C`V~b7eA{
z=ehJ0L)zP<Wa0|h{WN7_aSXyMZ}f$KJr7}5$eL;*R`MwCE<L1`VJh1)NArxi;7J~?
zi8c_S=A25>N=I^QHUhovRO@=?gklj7QqV@gG2=;6fU~7`T6tzT`j>Vp!((9B2Zk|_
zBywNM3%svga59>x_j=AVih<FPHuNSuiff5UYn=7y5E%4<s0$2^NO&R*R&_I5WBSD)
zp6O;TiF&UQPuv3r$G|W$<WWMG7t)ijv3Cy`^nfU&yQ#4$Af7tRMRzX(Q3r@Sc0BB~
zLRv@nAM#GWL-%1sVLB}=RR&HIh@HJ$^x=y@zYX+5GafzBo%#Vl_bz!SY6F8Vg?BnY
zwxi)J-z?~zQ96WR*K*PA3qTy2^DOxQV0LEc-UZ?=c`5GFx*QD(!cvtTWG9YeqQh71
zc$Qd)=cmHX9a@Y1hh*%qpJ!fZHMgL#7#IDD1<xu%T8Az=>dKNc$h<kL#!eMIk7s2b
zR_NT8#y+6?KpLCq#uj^KT=dJOd8&Y2bq^1yTpd4<<>r{qkCQ}ewu%iMPh>BZ=2;Z>
z?Tjuu3aLR!R9L1n?VKvwl4lW=JBSbW^JfOCt&CA)k<9*GNU&>6orpy33v?n<f~PFX
zH>}}4m6@aaG6{8Lxrygaov70#dCFk14m}fnI3Ah?C>CwcV~fSNB;h_8*MCTcrX%C2
z6QWD<*r1v{Sa<+Rul7H2P9(CDJf>JuF0_Y!w0jczOIZ~E8^J)a=qkn5s8ORvjT$v-
c)L16|18MYBhs?WpW&i*H07*qoM6N<$g7heP&;S4c

literal 0
HcmV?d00001

diff --git a/mythtv/themes/default/images/mv_prev_pushed.png b/mythtv/themes/default/images/mv_prev_pushed.png
new file mode 100644
index 0000000000000000000000000000000000000000..e1088737b2539e14cec9279fe7d5f186ab670016
GIT binary patch
literal 1403
zcmV->1%&#EP)<h;3K|Lk000e1NJLTq002Ay002A)1^@s6I{evk00006VoOIv0RI60
z0RN!9r;`8x010qNS#tmY3lIPR3lIUVBfWJ1000McNliru(+3s+DglQ;?92cF1qew*
zK~#90?V8(f6jdC@KWAq4+9gtMN&*@{t>GfdwS|2KZxM(uNQ4)RfmGntpnwXz`{=)5
zOb8Fggm=2Mg@Ql?nxKt}Rt33qm+o$NcgBZv+L_(%%+9vk-O|iAIhk#mnLVHR{^s}l
zoihu80tE^bC{Un4fdb7f?K*OH&%mv_mQw?_?pnK#p8c@Zb8EPE9XT@z)(PF}`BhiA
z%^r1V*QclV4E$`vu3EQzVvMVi(=-}#mB>60n*3}QeV_Jz_t$TqIK21VhSjS8*s;5V
zRV!lv{PJtIAycc=^ns(#fgYB?mg)Pn_YR%vJb8HUj~iFN3`p3OD<tgD(9FOBXwy17
zHXlN92*tpNN^mVy^R#ylop|F^_r6OT*SrGQurIwBo7QyvXzC8f+94E`pqc@e1p+V&
zo~OO@$rl}8c7Jqj)7n>o=EA~M9gek2XN?%>QP9F53_wRxSJzt~f4=CeBm3`EgI%^P
zGNq~1tNI;|EwDq_2upVnfCZ)iQ5|^a!Q+Y3NB7@%gLS`6ja7XP#}`64uH1DzvziV<
zSDAY9)OQ>_9y)#OKzh@<4*7Ql?9vyS<1W<WaD1Vip!A4zR@0@UmIcC;pQ|{0=GcL;
z%^t8WK`|rp=Wu+HY$%-0>J`okp)OZ`$^IL6EHBu_i^B~@@>Xq!+ZHQl<6uM_AuK2h
zU!j4fhEo6a+cjaE=`PfAxNQl96LO4)vaS-9FqFF$L)GEb)tlDl*IxtNVHdPFrqQcM
z?%y~LI}yeqJ0n-KMd<3e4v`wTIoS2)T3~j;f*Ww+dF5=I16BvL>aZ5b8f=jI;rqd^
z4YKxl!6p(0nT-FwyHT19oLB<kc`8Z8R0w;(g8ZK*NS*uEH*C`iZ-vT%;|n3w=BTw1
zAFzP1NPYK>Z`f#5BbWET&}gJ=;MfA0aEwTK7bSFWSO6@>VRt%UmoJO3bg6`GpKp+u
zXAq5OXnKq6#R)8gs;ADZYp60)8~9mKc}QC&xq!DyfCa*GbWdK;&knF%he!VdvjoK~
z6mw7<1JjgkBU%;r9Rr=z<*T;<E}S1^Xei5Xzi0X5UY_CMJooR9@#t}pOu9%eZ(^2O
zcZ13skI@HE$U!~>g;5D^7S&FMaD;v35NzLna!pU)l^fs>x>cIoX+8ZH3Qr+FB9Fzq
zKWGb*`#xLW)7$S0x>c&)T4w%%v8Rwr%VRMw!`&^s$IF&wlKh~1eb1%7Sqtsn-(~)W
z1Tt4?%2iFRh=fs*$kgH=z$%j5*17&-s@K}ywUrC!2idv1qv}_*&!0`bG)U-)EbUkV
ziVA39+S{~h=Q6piQ(U~%XKnA?;tAbs)m{&$hasPa++!Ha$V66hKGRxxSUZ&L+A4Z_
z`vLdxZnpfzRC*YDm1JjTXO?!W)yb}{v&w1zds^wgl+%yov5<vQLDp)pZ-5K5m($Hu
zeVceAf68)|eFS3)+EmaJy+rknY_>qxzc1~C&X33j#Vn|2+Vbo`y`Y<=scpoM+=JW`
z$UcPp6IrWEszEWmyQo$}PyOA}IP~a4nZfgE*_M`SXI?kxW@vgZ(<Y!Fl!v$vxk1nL
zJErLYgM==ODwjvp($b$K^ktwNdc}&FgPuMx$V7(4RMy4Gt}P<fcLlJahla8fFUIGr
zdin;c{>G#C`kiNIccEUTE?+B${pt4Hg$)!aP@q780tK3L`XBFLu<MJMZs`C3002ov
JPDHLkV1f@}wdeo<

literal 0
HcmV?d00001

diff --git a/mythtv/themes/defaultmenu/media_settings.xml b/mythtv/themes/defaultmenu/media_settings.xml
index 90f99e0..a161824 100644
--- a/mythtv/themes/defaultmenu/media_settings.xml
+++ b/mythtv/themes/defaultmenu/media_settings.xml
@@ -20,7 +20,7 @@
     <button>
         <type>SETTINGS_VIDEO</type>
         <text>Videos Settings</text>
-        <description>Configure playback and metadata</description>
+        <description>Configure playback, metadata and DVD ripping</description>
         <action>MENU video_settings.xml</action>
     </button>
 
diff --git a/mythtv/themes/defaultmenu/optical_menu.xml b/mythtv/themes/defaultmenu/optical_menu.xml
index 1fa1015..44af861 100644
--- a/mythtv/themes/defaultmenu/optical_menu.xml
+++ b/mythtv/themes/defaultmenu/optical_menu.xml
@@ -25,6 +25,12 @@
     </button>
 
     <button>
+      <type>DVD_RIP</type>
+      <text>Rip DVD</text>
+      <action>DVD_RIP</action>
+   </button>
+
+    <button>
         <type>EJECT</type>
         <text>Eject media</text>
         <description>Eject Disc from drive</description>
diff --git a/mythtv/themes/defaultmenu/video_settings.xml b/mythtv/themes/defaultmenu/video_settings.xml
index 48bce80..9a8bd1f 100644
--- a/mythtv/themes/defaultmenu/video_settings.xml
+++ b/mythtv/themes/defaultmenu/video_settings.xml
@@ -28,4 +28,12 @@
       <description>Associate new file extensions</description>
    </button>
 
+   <!-- MythDVD -->
+   <button>
+      <type>DVD_RIP</type>
+      <text>Rip Settings</text>
+      <action>DVD_SETTINGS_RIP</action>
+      <description>DVD Rip and Transcode options</description>
+   </button>
+
 </mythmenu>
diff --git a/mythtv/themes/mediacentermenu/media_settings.xml b/mythtv/themes/mediacentermenu/media_settings.xml
index e4bd339..0220132 100644
--- a/mythtv/themes/mediacentermenu/media_settings.xml
+++ b/mythtv/themes/mediacentermenu/media_settings.xml
@@ -12,7 +12,7 @@
     <button>
         <type>SETTINGS_VIDEO</type>
         <text>Videos Settings</text>
-        <description>Configure playback and metadata</description>
+        <description>Configure playback, metadata and DVD ripping</description>
         <action>MENU video_settings.xml</action>
     </button>
 
diff --git a/mythtv/themes/mediacentermenu/optical_menu.xml b/mythtv/themes/mediacentermenu/optical_menu.xml
index cfcb818..e522c49 100644
--- a/mythtv/themes/mediacentermenu/optical_menu.xml
+++ b/mythtv/themes/mediacentermenu/optical_menu.xml
@@ -25,6 +25,12 @@
     </button>
 
     <button>
+      <type>DVD_RIP</type>
+      <text>Rip DVD</text>
+      <action>DVD_RIP</action>
+   </button>
+
+    <button>
         <type>EJECT</type>
         <text>Eject media</text>
         <description>Eject Disc from drive</description>
diff --git a/mythtv/themes/mediacentermenu/video_settings.xml b/mythtv/themes/mediacentermenu/video_settings.xml
index 48bce80..9a8bd1f 100644
--- a/mythtv/themes/mediacentermenu/video_settings.xml
+++ b/mythtv/themes/mediacentermenu/video_settings.xml
@@ -28,4 +28,12 @@
       <description>Associate new file extensions</description>
    </button>
 
+   <!-- MythDVD -->
+   <button>
+      <type>DVD_RIP</type>
+      <text>Rip Settings</text>
+      <action>DVD_SETTINGS_RIP</action>
+      <description>DVD Rip and Transcode options</description>
+   </button>
+
 </mythmenu>
diff --git a/mythtv/themes/themestrings.h b/mythtv/themes/themestrings.h
index 07d58f4..dad2274 100644
--- a/mythtv/themes/themestrings.h
+++ b/mythtv/themes/themestrings.h
@@ -32,7 +32,7 @@ void strings_null() {
     ThemeUI::tr("Music Settings");
     ThemeUI::tr("Configure playback and CD ripping");
     ThemeUI::tr("Videos Settings");
-    ThemeUI::tr("Configure playback and metadata");
+    ThemeUI::tr("Configure playback, metadata and DVD ripping");
     ThemeUI::tr("Images Settings");
     ThemeUI::tr("Configure display of image gallery");
     ThemeUI::tr("Game Settings");
@@ -967,5 +967,40 @@ void strings_null() {
     ThemeUI::tr("a nice transparent theme to use your own background if you want. just copy your favorite picture (be sure that its resolution is 1920x1200) to /usr/share/mythtv/themes/TransBlue/background.jpg");
     ThemeUI::tr("A UI and OSD theme with focus on fanart, banners and cover display.");
     ThemeUI::tr("blootube-ng is a theme based on the original blootube-wide by Justin Hornsby (justin.hornsby@gmail.com) which uses very large graphics associated with every menu entry. All changes where made to bring this theme forward to MythTV 0.24.");
-    ThemeUI::tr("Blue-abstract is a modern looking theme meant for widescreen HD displays. The blue background and the consistent layout makes it an attractive and elegant looking theme. This theme can be used with MythTV 0.26 and later.");
+    ThemeUI::tr("Select a Title to Rip");
+    ThemeUI::tr("Select the parts of the DVD you wish to copy.");
+    ThemeUI::tr("Film Name:");
+    ThemeUI::tr("Track Length:");
+    ThemeUI::tr("0:00:00");
+    ThemeUI::tr("Rip Quality:");
+    ThemeUI::tr("Audio Track:");
+    ThemeUI::tr("Subtitle:");
+    ThemeUI::tr("Rip AC-3 Audio");
+    ThemeUI::tr("Preview this title");
+    ThemeUI::tr("Rip This Track");
+    ThemeUI::tr("Title 1 of 1");
+    ThemeUI::tr("Previous Title");
+    ThemeUI::tr("Next Title");
+    ThemeUI::tr("Begin Ripping");
+    ThemeUI::tr("No Current Jobs");
+    ThemeUI::tr("Select a Track to Rip");
+    ThemeUI::tr("Name of Film:");
+    ThemeUI::tr("Selected track length:");
+    ThemeUI::tr("Check this box to select this track:");
+    ThemeUI::tr("Check to rip AC-3 audio:");
+    ThemeUI::tr("Subtitles:");
+    ThemeUI::tr("Press to view excerpt:");
+    ThemeUI::tr("Previous");
+    ThemeUI::tr("Next");
+    ThemeUI::tr("Rip/Transcode");
+    ThemeUI::tr("Job 1 of 1");
+    ThemeUI::tr("Length:");
+    ThemeUI::tr("Select:");
+    ThemeUI::tr("Name:");
+    ThemeUI::tr("Quality:");
+    ThemeUI::tr("AC3 Audio:");
+    ThemeUI::tr("View:");
+    ThemeUI::tr("Rip Settings");
+    ThemeUI::tr("DVD Rip and Transcode options");
+    ThemeUI::tr("Rip DVD");
 }
-- 
1.7.9.5

