From b95baffa57e236caa0ec0d70951b5643b9fa0889 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Tue, 21 May 2013 20:27:09 +0100
Subject: [PATCH 010/227] ffmpeg: Reduce livetv startup delay

av_find_stream_info parses the input stream and calls has_codec_parameters()
for each discovered stream.  However, some MP3 audio streams (tag 0)
have incomplete information, missing sample rate and channels.  This
causes av_find_stream_info to run until the default timeout of 5 seconds.

This change reduces the time spent in av_find_stream_info to around 1 second.

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythtv/external/FFmpeg/libavformat/utils.c |   24 ++++++++++++++++++------
 1 file changed, 18 insertions(+), 6 deletions(-)

diff --git a/mythtv/external/FFmpeg/libavformat/utils.c b/mythtv/external/FFmpeg/libavformat/utils.c
index 95998ae..b811e98 100644
--- a/mythtv/external/FFmpeg/libavformat/utils.c
+++ b/mythtv/external/FFmpeg/libavformat/utils.c
@@ -2581,8 +2581,10 @@ int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
             int fps_analyze_framecount = 20;
 
             st = ic->streams[i];
-            if (!has_codec_parameters(st))
-                break;
+            if (!has_codec_parameters(st)) {
+                if (st->codec->codec_type != AVMEDIA_TYPE_AUDIO || !hasaudio)
+                    break;
+            }
             /* if the timebase is coarse (like the usual millisecond precision
                of mkv), we need to analyze more frames to reliably arrive at
                the correct fps */
@@ -2597,8 +2599,12 @@ int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
                 break;
             if(st->parser && st->parser->parser->split && !st->codec->extradata)
                 break;
-            if(st->first_dts == AV_NOPTS_VALUE && st->codec->codec_id != CODEC_ID_DSMCC_B)
-                break;
+            if(st->first_dts == AV_NOPTS_VALUE && st->codec->codec_id != CODEC_ID_DSMCC_B) {
+                if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO && !hasaudio)
+                    break;
+                if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && !hasvideo)
+                    break;
+            }
             if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
                 hasvideo = 1;
             else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO)
@@ -2628,7 +2634,7 @@ int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
         /* we did not get all the codec info, but we read too much data */
         if (read_size >= ic->probesize) {
             ret = count;
-            av_log(ic, AV_LOG_DEBUG, "Probe buffer size limit %d reached\n", ic->probesize);
+            av_log(ic, AV_LOG_WARNING, "Probe buffer size limit %d reached\n", ic->probesize);
             for (i = 0; i < ic->nb_streams; i++)
                 if (!ic->streams[i]->r_frame_rate.num &&
                     ic->streams[i]->info->duration_count <= 1)
@@ -2763,7 +2769,13 @@ int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     // close codecs which were opened in try_decode_frame()
     for(i=0;i<ic->nb_streams;i++) {
         st = ic->streams[i];
-        avcodec_close(st->codec);
+        if (!has_codec_parameters(st)){
+            char buf[256];
+            avcodec_string(buf, sizeof(buf), st->codec, 0);
+            av_log(ic, AV_LOG_WARNING, "Could not find codec parameters (%s)\n", buf);
+        }
+        if(st->codec->codec)
+            avcodec_close(st->codec);
     }
     for(i=0;i<ic->nb_streams;i++) {
         st = ic->streams[i];
-- 
1.7.9.5

